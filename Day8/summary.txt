
날짜를 직접 작성하는건 비효율적. 물론 db 쓰면 db 서 처리해주겠지만 우리는 지금 db 안쓰고 있으므로 컬렉션 이용해야됨

private Timestamp regDate; 
Timestamp now = new Timestamp(System.currentTimeMillis());  
member.setRegDate(now);


ms 단위의 시간을 예쁘게 포맷하는 법: 
<fmt:formatDate value="${element.redDate}" pattern="yyyy-mm-dd"/>
---------------------------------------------------------------------------------------------------------------

jstl 같은 경우는 이미 스프링에 내장되어있다 (디펜던시로)

    <c:set var="c" value="값"/>

<c:out value="값">

    <c:if test="${num1>num2}'></c:if>



<c:forEach begin="1" end="100" items="${list} var="element">
       ${ element.name } <br>
	${element.age} <br>
    </c:forEach>

<c:forEach var="i" begin="1" end="10">
        <c:out value="${i}" />
</c:forEach>

---------------------------------------------------------------------------------------------------------------

타입에 해당하는 빈 자동 주입 >> 
@Autowired
private MemberDAO dao;

---------------------------------------------------------------------------------------------------------------

Model 객체와 request 객체
	: Model 객체는 Request 를 대신하는거다. Request 가 더 넓은 영역에서 쓰일 수 있따. model 에 담으면 해당 view 에서만 사영 가능하다(<< Parameter 느낌인듯?)





똑같은 url 이라도 방식에 따라 다른 메서드와 메핑 가능
	@GetMapping("/join") // 얘는 get 방식이니까 다른거임 (아래와)
	public String joinForm() {
		return "member/joinForm";
	}

	
	// 회원 가입 후에 등록 요청
	@PostMapping("/join")
	public String join() {
		return "";
	}


----------------------------------------------------------------------------------------------

스프링에서의 리다이렉트
	: https://amy-it.tistory.com/111
	return "redirct:/경로";
RedirectAttributes ra >> 이걸 파라미터에 추가해줌 또 DI 시켜준다.
	: redirect 통해 이동하는 경우  RedirectAttributes 객체를 통해 데이터 전달 가능
		: model 객체에 넣어줘도 상관 없지만 페이지를 새로 고침한다 했을떄 model 객체 안의 데이턴는 유지가 된다

	: ra.addFlashAttribute("msg","같은 아이디가 존재합니다");
		: addFlashAttribute( ) 는 리다이렉트 직전 프래시에 데이터를 저장하는  메서드. 
		: 일회성 데이터를 보내주기 때문에 리다이렉트 이후에는 소멸한다


	: redirect, forward 
		: 스프링 컨테이너의 

----------------------------------------------------------------------------------------------
jsp 에서 get 방식으로 전달하기

        <a href="/mvc/member/info?id=${element.id}">이름:</a>${element.name } <br>


@ModelAttribute 는 저장할 객체가 해당 메서드에 아예 파라미터로 넘어올때 , 그걸 통째로 model 객체에 attribute 로 저장하기 위해 사용하는거다.

@RequestMapping 은 "request 객체를 DI 시켜 생성한후 getParam 하지 않고"도  파라미터명을 통하여 바로rquest 객체의 파라미터값을 메서드의 파라미터로 받을 수 있게 해준다

----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
form 태그 자체에도 이름을 붙일 수 있따
	<form name="modifyForm" action="/mvc/member/modifyForm" method="post">


JS
			var check = confirm('회원탈퇴를 하시겠습니까?'); // 확인을 누르면 true, 취소 누름 false 반환
				var modify = document.modifyForm // document == 현재문서	
												// modifyForm 이건 우리가 폼에 붙인 name 
					modify.method ="post";
					modify.action="/mvc/member/delete";
					modify.submit(); // 바로 전송----------------------------------------------------------------------------------------------

새로만든 프로젝트 설정은 걍 복붙한다. 서블릿 설정 파일은 함 안된다.
	web.xml , pom. xml 만 해준다

JDBC 간의 비교
기존 Java DataBase Connectivity
JDBC(Java DataBase Connectivity)는 데이터베이스에 연결 및 작업을 하기 위한 자바 표준 인터페이스이다. JDBC 를 사용하여 데이터베이스 작업을 하여도 되지만 반복적인 작업이 계속되는 단점이 있다


Spring JDBC
Spring JDBC는 JDBC의 모든 반복적인 로직의 처리를 스프링 프레임워크에 위임하므로 Connection의 연결과 생성 및 종료 Statement 준비와 실행 및 종료 ResultSet 처리와, 예외 처리, 트랙젝션 등의 반복되는 작업을 Spring이 해줌으로 개발자가 직접 작성하지 않고 Database에 대한 작업을 수행할 수 있다


커낵션 풀 >> 커낵션 관련 저장해두는 풀,
웹 컨테이너(WAS)가 실행되면서 DB와 미리 connection(연결)을 해놓은 객체들을 pool에 저장해 두었다가, 클라이언트 요청이 오면 connection을 빌려주고, 처리가 끝나면 다시 connection을 반납 받아 pool에 저장하는 방식을 말한다. 스프링의 JDBC Template과 커넥션풀을 관리하는 HikariCP 라이브러리를 사용하기 위해 <dependency> 태그로 pom.xml 에 추가한다. 
	: 그러니까 톰캣에 내장되있는게 아니다
	: 커맨드 객체랑 다르다

1. ojdbc8 >> 걍 젤 클릭수 많은거
2. spring jdbc >> 5.2.3 버전 맞춰서
3. hikaricp >> 걍 젤 클릭수 ㅏㅁㄶㅇ느거


root 설정 파일
	<!--  db 관련 빈 등록을 하고 관리하는 설정 파일 -->	
	<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
		<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"></property>
		<property name="jdbcUrl" value="jdbc:oracle:thin:@Localhost:1521:xe"></property>
		<property name="username" value="C##javauser"></property>
		<property name="password" value="java2024"></property>
	</bean>
	
	<!-- 히카리 데이터 소스 클래스 빈 등록 설정 -->
	<bean id="hikariDataSource" class="com.zaxxer.hikari.HikariDataSource">
		<constructor-arg ref="hikariConfig"></constructor-arg>
	</bean>




hikari 빈 설정 tip
	: 클래스 풀 네임으론 걍 java 파일에서 import 해서 그거 복붙한다


마찬가지로 dao 클래스는 interface 먼저 만든다음에 만든다
