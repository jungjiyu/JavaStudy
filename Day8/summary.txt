

체크박스로 한 name 으로 여러 value 를 받는 경우해당 필드의 타입은 List<어쩌고> 여야되고, 받은 후 el 표현식으로 꺼낼때 그냥 객체.리스트필드명 만 해줘도 잘 보인다

---------------------------------------------------------------------------------------------------------------
: 3계층
	: Presentation Layer << 여기선 service 계층 객체 사영
		- 클라이언트의 요청 및 응답을 처리
		- 서비스계층, 데이터 엑세스 계층에서 발생하는 Exception을 처리
		- @Controller 어노테이션을 사용

	: Service Layer << 여기선 커맨드 객체 사용
		- 비즈니스 로직 처리와 비즈니스와 관련된 도메인 모델의 적합성 검증 트랜잭션 관리 및 처리
		- 프리젠테이션 계층과 데이터 엑세스 계층 사이를 연결하는 역할
		- 주로 인터페이스를 먼저 만들고 그걸 기반으로 서비스 (구현) 클래스를 만듬
		- @Service 어노테이션을 사용

	: Data Access Layer << DAO
		- ORM (Mybatis, Hibernate)를 주로 사용하는 계층
		- Dabase에 data를 CRUD(Create, Read, Update, Delete)하는 계층
		- 주로 인터페이스를 먼저 만들고 그걸 기반으로 DAO (구현) 클래스를 만듬
		- @Repostiory 어노테이션 사용


---------------------------------------------------------------------------------------------------------------

날짜를 직접 작성하는건 비효율적. 물론 db 쓰면 db 서 처리해주겠지만 우리는 지금 db 안쓰고 있으므로 컬렉션 이용해야됨

private Timestamp regDate; 
Timestamp now = new Timestamp(System.currentTimeMillis());  
member.setRegDate(now);


ms 단위의 시간을 예쁘게 포맷하는 법: 
<fmt:formatDate value="${element.redDate}" pattern="yyyy-mm-dd"/>
---------------------------------------------------------------------------------------------------------------

jstl 같은 경우는 이미 스프링에 내장되어있다 (디펜던시로)

    <c:set var="c" value="값"/>

<c:out value="값">

    <c:if test="${num1>num2}'></c:if>



<c:forEach begin="1" end="100" items="${list} var="element">
       ${ element.name } <br>
	${element.age} <br>
    </c:forEach>

<c:forEach var="i" begin="1" end="10">
        <c:out value="${i}" />
</c:forEach>

---------------------------------------------------------------------------------------------------------------

타입에 해당하는 빈 자동 주입 >> 
@Autowired
private MemberDAO dao;

---------------------------------------------------------------------------------------------------------------

Model 객체와 request 객체
	: Model 객체는 Request 를 대신하는거다. Request 가 더 넓은 영역에서 쓰일 수 있따. model 에 담으면 해당 view 에서만 사영 가능하다(<< Parameter 느낌인듯?)





똑같은 url 이라도 방식에 따라 다른 메서드와 메핑 가능
	@GetMapping("/join") // 얘는 get 방식이니까 다른거임 (아래와)
	public String joinForm() {
		return "member/joinForm";
	}


	// 회원 가입 후에 등록 요청
	@PostMapping("/join")
	public String join() {
		return "";
	}


----------------------------------------------------------------------------------------------

스프링에서의 리다이렉트
	: https://amy-it.tistory.com/111
	return "redirct:/경로";
RedirectAttributes ra >> 이걸 파라미터에 추가해줌 또 DI 시켜준다.
	: redirect 통해 이동하는 경우  RedirectAttributes 객체를 통해 데이터 전달 가능
		: model 객체에 넣어줘도 상관 없지만 페이지를 새로 고침한다 했을떄 model 객체 안의 데이턴는 유지가 된다

	: ra.addFlashAttribute("msg","같은 아이디가 존재합니다");
		: addFlashAttribute( ) 는 리다이렉트 직전 프래시에 데이터를 저장하는  메서드. 
		: 일회성 데이터를 보내주기 때문에 리다이렉트 이후에는 소멸한다


	: redirect, forward 
		: 스프링 컨테이너의 

----------------------------------------------------------------------------------------------
jsp 에서 get 방식으로 전달하기

        <a href="/mvc/member/info?id=${element.id}">이름:</a>${element.name } <br>


@ModelAttribute 는 저장할 객체가 해당 메서드에 아예 파라미터로 넘어올때 , 그걸 통째로 model 객체에 attribute 로 저장하기 위해 사용하는거다.

@RequestMapping 은 "request 객체를 DI 시켜 생성한후 getParam 하지 않고"도  파라미터명을 통하여 바로rquest 객체의 파라미터값을 메서드의 파라미터로 받을 수 있게 해준다

----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
form 태그 자체에도 이름을 붙일 수 있따
	<form name="modifyForm" action="/mvc/member/modifyForm" method="post">


JS
			var check = confirm('회원탈퇴를 하시겠습니까?'); // 확인을 누르면 true, 취소 누름 false 반환
				var modify = document.modifyForm // document == 현재문서	
												// modifyForm 이건 우리가 폼에 붙인 name 
					modify.method ="post";
					modify.action="/mvc/member/delete";
					modify.submit(); // 바로 전송
