
f12 >> 개발자 모드
	: 쿠키 확인하는 법
		sol(1) network-밑에뜨는 파일- cookie
			: response , request 각각 볼 수 이써서 좋음. 개추.
		sol(2) application-cookie 
			: 간단하게 확인 가능

-----------------------------------------------------------------------
클라이언트가 새로운 request 를 하는 것 >> 아예 창을 닫고( 브라우져의 X 버튼을 누름) 다시 해당 URL 로 접속하는 것ㅅ

클라이언트가 재request 하는 것 >> 단순 탭 새로고침하거나 , 다른 탭에서 URL 로 접속하는 것(브라우져 자체의 X 버튼을 누른게 아니라)

서버가 꺼지는 것 >> 이클립스에서 서버의 ■ 버튼 누르거나 다시 실행 버튼 누르는 것
	: 다시실행버튼 누르는 건 서버를 껐다 다시 키는거임

-----------------------------------------------------------------------

-----------------------------------------------------------------------

Http 프로토콜의 특성
	(1) connectionless : 클라이언트가 response 를 받으면 서버와의 연결(=통신)이 끊어짐 
	(2) stateless : 통신이 끝나면 상태 정보를 유지하지 않음

Http 프로토콜의 특성 때문에, 그러니까 통신이 끝난 이후에도 관계 유지를 위해, 쿠키,세션,어플리케이션을 사용.
	: DB에 저장해놓음 되는거 아냐 ? 할 수 있지만 비추되는게 DB 는 최대한 냅두고 어플리케이션 선에서 끝나는게 과부하 안걸리고 좋다.

https://dololak.tistory.com/553

Session Data
	: 특정 클라이언트의 연결에 관한 전반적인 정보

Session Cookie
	: 서버가 보낸 세션데이터를 쿠키의 형태로 클라이언트에게 저장해놓은 것.
	: JsessionID
		: tomcat 을 사용하여 구현한 서버를 사용하면 "클라이언트"가  세션쿠키를 "JessionID" 란 이름으로 저장하게 한다.

	: 단순히 "새로고침" 혹은 "url 복사해서 새로운 탭에서 연다"고 (=재request)한다고 세션쿠키값이 변하진 않는다.  아예 큰 x 자 눌러 창 닫고 다시 페이지를 열어야된다(= 새로운 request). 
	
SessionID
	: 서버가 접속된 클라이언트들을 구별하기 위해 클라이언트에게 발급하는 고유한 키 값
	: sessionID 는 서버와 클라이언트에 저장됨
		: 쿠키 만료 시 클라이언트 상에서 해당 쿠키는 없어지지만 , 서버에서는 해당 쿠키가 가지던 sessionID가 자동으로 삭제되진 않으므로 따로 삭제해야된다.(invalidate 시키기)
	

	: 과정
		0. 클라이언트가 서버에 JsessionID 없이 || 처음보는 JSessionID로 request를 날림
			: 서버에 저장되어있는 sessionID 값을 가진 쿠키와 함께 request 하면 또다시 서버가 sessionID 를 발급해주지 않는다
		1. 클라이언트가 서버로부터 고유한 sessionID 를 발급받음
		2. (tomcat을 사용하는경우)클라이언트는 sessionID 를 JsessionID 라는 이름을 가진 쿠키의 형태로 저장함
		3. 클라이언트가 서버에게 "재request" 할때마다 request 헤더에 JsessionID 쿠키를 포함시켜 서버에 전달함
		4. 서버는 전달받은 JsessionID로 클라이언트를 식별하여 작업하고 response 함


세션 Session
	: 원래는 클라이언트가 웹 서버와 연결되고, 종료되기까지의 "기간"을 의미. 근데  통상적으로 세션이라고 하면 "세션에 대한 종합적인(단순히 시간만 가리키는게아니라) 데이터" 를 서버에 저장하고, 클라이언트에게도 부여함으로써 서버가 클라이언트를 식별하게끔 하는 "방식" 자체를 의미하는 경우가 많음.

	: 세션도 결국 쿠키를 이용하는 방식(sessionID 를 쿠키로 저장)이다. 그래도 그냥 쿠키보다는 보안 측면에서 뛰어나다
		: 쿠키 자체에 데이터를 담아서 통신하는게 아니라 단순 sessionID 값만 보내고( 세션ID 그 자체로 유의미한 값을 가지고 있진 않다), 서버 내부에서 따로 그 sessionID 로 데이터를 처리하는거니까

	: 서버의 저장공간을 잡아먹는 것은 단점이다.

	: JsessionID를 기준으로 생성되는 것이므로 일시적인 클라이언트 단위 관리 할땐 유용하다
		: 프로젝트 단위로 

	: 세션의 기본 사이클
		0. 클라이언트가 서버에 접속
		1. 클라이언트가 서버로부터 고유한 sessionID 를 발급받음
			: sessionID >> 서버가 접속된 클라이언트들을 구별하기 위해 클라이언트에게 발급하는 고유한 값
		2.  클라이언트는 sessionID 를 JsessionID 라는 이름을 가진 쿠키의 형태로 저장함
		3. 클라이언트가 서버에게 request 할때마다 request 헤더에 JsessionID 쿠키를 포함시켜 서버에 전달함
		4. 서버는 전달받은 JsessionID로 클라이언트를 식별하여 작업하고 response 함
		
	: 세션을 종료하는 법
		(1) 명시적으로 서버에서 세션을 종료시킴
		(2) 명시적으로 서버에서 세션의 유효시간을 정해둠

	
	: 세션관련메서드
		(1) setAttribute(String name, Object value)
			: 세션 객체에 이름과 값을 맵핑하여 저장
			: Object >> 자바의 최상위 클래스. 모든 객체를 저장이 가능
			: ex) 	session.setAttribute("sessionName","sessionValue");


		(2) Object getAttribute(String name)
			: 세션 속성명이 name 인 속성의 값을 Object 타입으로 리턴
			: 만약에 존재하지 않으면 null 반환
			: Object 타입이라 강제 형변환 시켜줘야됨
				String name = (String)session.getAttribute("sessionName");


		(3) Enumeration getAttributeNames()
			: 세션 속성의 이름들을 Enumeration 객체 타입으로 리턴함
			: 세션 안에 저장된 이름들의 목록을 enumeration 타입으로 가져옴

		(4) String getId()
			: 세션에 할당된 고유 식별자를 String 타입으로 리턴
			: JsessionId 값으로 저장됨 << 서버가 자동 생성 시키는 쿠키 << 세션 쿠키로 저장됨.
				: 클라이언트와의 연결시 클라이언트별로로 한 브라우저랑 고유한 아이디어가 생성됨. 따라서 웹 브라우져 별로 생성되어진 세션을 구분 가능
				: 세션 쿠키 << 자동 생성되고 웹 브라우져 창 닫을 시 소멸되는 쿠키.
				: 그래서 창 닫으면 로그인 자동으로 해제된는거다. JsessionId 가 나가버리니까
					: 웹 브라우져 별로는 유지된다 << edge 에서 로그인해놨어도 chrome 에선 소용없다
				

		(5) int setMaxInactiveInterval(int interval) 세션 유지시간을 초 단위로 설정한다.
			: 기본 30분
			: 비활성화 간격. 아무것도 안하고 있어도 되는 최대 시간. 해당 시간이 지나면 소멸된다.

		(6) getMaxInactiveInterval() 세션의 유효시간을 초 단위로 얻는다.
		(7) removeAttribute(String name) 세션 속성명이 name인 객체를 삭제한다.
		(8) invalidate() 세션의 모든 데이터를 삭제한다
			: 세션을  무효화한다고 보면된다.
			: 세션 쿠키 까지 없어지는거라 세션 객체를 날려버린다고 봄 된다.

		(9) IsRequestedsessionId Valid( )
			: session객체가 유효한지(=request 에 sessionID 값이 함께 담겨왔는지) 확인
				: session 객체가 유효하면  true, 아님 false 반환
			: request 객체를 대상으로 사용하는거다
			: ex) 
				if(request.isRequestedSessionIdValid()){ 
					out.print("유효 세션 있음<br>");
				}else{
					out.print("유효 세션 없음<br>");
				}


---------------------------------------------------------------------------------------------


Page 객체>>this 객체. 현재JSP 페이지 자체를 타타냄.
pageContext >> JSP 페이지와 관련된 정보를 나타냄


웹어플리케이션 >> 우리가 만든 프로젝트 하나

어플리케이션 Application 
	: application 객체는 웹 자신이 속한 웹어플리케이션에 대한 정보들을 가진 객체이고, 해당웹어플리케이션 내부의 모든 JSP파일에서 "공유"됨.
	
	:  jsp 내장 객체여서 별도로 직접 객체를 생성하지 않는다

	: 클라이언트 별로 생기는게 아니라 한 어플리케이션 당 하나가 생기게 되는거다
		: 웹 브라우져가 종료된다고 없어지지 않는다. 서버 자체가 꺼져야 application 객체가 없어진다
			:  서버를 재시작 하면 없어지는거 주의

		: 클라이언트 개별적인 관리가 아니라 "딱히 구분지을 필요가 없는 관리(?)" 혹은 "집계"를 할때 유용하다 
			: ex) 방문자수 같은거 집계할때 도움이 된다
		
	: javax.servlet.ServletContext 에 대응하는 객체다 << web.xml 을 반영하여 만들어지고, 어플리케이션 내 모든 파일들이 공유한다
		: Servlet 의 경우 웹 어플리케이션이 구동될때 WEB-INF 내부의 web.xml 을 참고하도록 되어있다. 
			WEB-INF/ web.xml 파일
				: 배포서술자 Deployment Descriptor 라고도 한다
				: 웹 어플리케이션에 대한 전반적인 (초기)설정을 하는 파일
				: 왜 쓸까?
					: 일일이 servlet 파일마다 안적어도 되니까 유지보수성이 높아진다.
		
	: 메서드 
		(1) setAttribute(String name, Object Value) 어플리케이션에 값을 저장	
		(2) Object getAttribute(String name) setAttribute()로 저장할때 사용했던 변수값으로 어플리케이션에 저장된 데이터를 불러옴
		(3) removeAttribute(String name) 해당 변수명으로 저장된 어플리케이션값을 삭제



---------------------------------------------------------------------------------------

객체.getAttribute("어쩌구").toString( ) 바로 못하게 막아뒀다.  먼저 if( 객체.getAttribute("어쩌구") != null) 로 확인하고 써야된다.

---------------------------------------------------------------------------------------


엔트리란?
---------------------------------------------------------------------------------------
-------------------------------


---------------------------------------------------------------------------------------

ㅇㅖ외페이지
	:  jsp 에서도 예외가 발생할 수 있는데 , 톰캣에서는 기본적으로 예외페이지를 제공한다.  근데 우리가 따로 만든 예외 페이지를 띄울 수 있다

	:상태 
		: 다 못 외우므로 유명한 것만 외우자
		: 종류
			(1) 200 >> 정상상태
				: 그러니까 에러가 난 상태가 아니라 찐으로 정상이란걸 의미한다
			(2) 404 >>요청한 페이지가 없음
			(3) 500 >> 서버에서 자바를 실행하다가 에러가 남
				: 10/0 같은거 함 글케 됨.

	: 예외 페이지 설정 절차
		0. 일단 예외 페이지를 제작 << jsp , html ... 파일로 제작 한다
				step1) <%@ page isErrorPage="true" %>
					: 이 지시자를 사용해야 Exception이란 객체를 사용 가능하다
					: 젤 위에 써준다
					: 필수

				step2)  <% response.setStatus(200); %>
					: body 부분 맨 앞에 적는다
						: 본격적으로 페이지에 표시할 내용을 적기 전에 상태를 정상상태로 만들어놓고 표시하는거다

		1. 예외 페이지를 등록(?)
			방법1) WEB-INF/web.xml 이용
				: 해당 웹프로젝트 내부의 파일 모두에 적용 시키고 싶을 경우 이 방법을 택한다
				: how ) 

			방법2) 지시자 이용
				: 해당 웹프로젝트 내부의 특정 파일에만 적용시키고 싶을경우 이 방법을 택한다
				: how ) <%@page errorPage %>

	
 					
	: 방식
		1. page 지시자를 이용 << 단점 : 일일이 jsp 파일마다  <%@page errorPage="포워딩할 페이지" %>  를 써줘야된다
			0. 현재 jsp 파일에서 예외가 발생했을때 사용자에게 보여줄 예외화면을 처리할 jsp 페이지의 경로를 지정. 그러니까 포워딩 시키겠다.
					ex)   <%@page errorPage="포워딩할 페이지" %> 

			


		2.  WEB-INF/web.xml 이용 << 장점 : 별도로 파일마다 지시자  안써도 된다
			: 경로 설정 존나 주의 
				주의사항(1)  context path 없이(=프로젝트명 빼고 적고) 경로를 적어야된다 
					>> 왜냐면  WEB-INF/web.xml 은 해당 프로젝트에만 적용되는 설정 파일이기 때문에 따로 프로젝트를 명시하지 않아도 되는거다
						: context path 를 안적어도 된다는게 아니라 적으면 걍 오류가 나므로 반드시 적지 말라	
				주의사항(2) 절대경로로 써야된다 (앞에 짝대기 쓰고 써야된다.)
						: context path 를 쓰지 않았다고 상대경로라는게 아니다

	
  <error-page>
  	<error-code>500</error-code>
  	<location>/error/ErrorPage/Error500.jsp</location>
  </error-page>


