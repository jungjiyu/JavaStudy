view Name 
	: 따로 그런 클래스가 있는건 아니고 컨트롤러에서 반환하는 String 객체를 "view name" 이라고 한다

Asterisk : 아스테리스크
---------------------------------------------------------------------------------------------------------------------------

 


Spring (Annotation)
	1. 빈 등록으로 사용되는 대표적인 어노테이션
		@Component : 해당 클래스를 스프링의 Bean으로 등록할 때 사용하는 어노테이션.
			: @Controller , @Service , @Repository 는 다 @Componet 로 부터 파생된거다 

		@Controller : 해당 클래스가 Controller임을 명시			
		@Service : 해당 클래스가  Service 클래스임을 명시
		@Repository : 해당 클래스가 DAO 역할을 한다고 명시


	2. "클래스 혹은 메서드" 와 "특정 url"을 매핑시켜주는 어노테이션
		: 해당 url 로 request 가 들어올 경우 해당 클래스 혹은 메서드를 호출시켜준다

		: URL 표현 tip
			: 어노테이션에 매핑시킬 URL ==  contextPath 다음 url 이고 ,  "/" 로 시작한다
			:  반환될 view Name == WEB-INF/views/ 아래의 jsp 파일의 URL 이고, "/" 로 시작 안한다

		: 클래스와 매핑시킨 URL은 해당 클래스의 전체 메서드들의 공통 url 을 의미한다

		@RequestMapping("매핑URL")
			: get 방식과 post 방식 모두 받을 수 있다 << @GetMapping, @PostMapping 은 @RequestMapping 에서 파생된거다
				:  get , post 중 특정 방식으로만 받게할려면 따로 method, value 속성 명시 필요

		@GetMapping : GET 방식일때만 사용
  
		@PostMapping : Post 방식일때만 사용


---------------------------------------------------------------------------------------------------------------------------

컨트롤러의 method
	1. HttpServletRequest 타입 매개변수 사용 >> Spring 이 자동으로 request 객체를 DI 시켜준다
		: request 객체를 대상으로 getParameter( ) 하여 파라미터 값을 추출하게 된다
		: request 객체를 대상으로 setAttribute( )  하여 포워드 되는 페이지에 데이터를 전달하게 된다

	2. @RequestParam 어노테이션 적용된 매개변수 사용 &&   Model 타입 매개변수 사용 >> 헤당 파라미터의 값을 자동으로 해당 매개변수에 바인딩 시켜준다 && Spring 이 자동으로 model 객체를 DI 시켜준다
		 : @RequestParam(value="파라미터명", required=false) 의 꼴로 주로 활용한다
			: ( value 는 필수고 ) required 속성은 필수가 아니긴 한데 , 이거 없음 해당 파라미터가 존재하지 않을 경우 오류 발생되기 때문에 써주는게 좋다
				: required=false 하면 해당 파라미터가 없어도 오류를 발생시키지 않고 ,단순 null 값을 대입해준다
				: 따라서 @RequestParam 이 적용될 파라미터는 레퍼런스타입으로 해줘야된다 (null 값을 받을 수도 있으니까)
			: defalutValue 속성을 주면 null 값이 아닌 기본값을 주게 할 수도 있다

		: model 객체를 대상으로 addAttribute( ) 하여 포워드 되는 페이지에 데이터를 전달하게 된다


뭘로 했든 포워딩된 jsp 페이지에선 ( ${name } , ${age } 같은걸로 해당 값을 사용할 수 있다 

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

Command Object 커맨드 객체

	: 스프링에서 HttpServletRequets 를 통해 전송 정보를 얻을 수도 있고 @RequestParam 으로 데이터를 해당 매개변수에 바인딩하여 전송정보를 얻을 수도 있다. 하지만 이 두 방식은 파라미터 갯수들이 많아지면 하나하나 명시를 하여 처리해야되서 가독성이 떨어지는 등의 단점이 있다. 따라서 스프링은 커맨드 객체(Command Object) 를 지원하고 있다. 



	: Http request 파라미터의 이름을 사용한 setter 메서드를 작성한 클래스를 만들고 이 클래스의 커맨드 객체를 메서드의 매개변수에 작성을 해주면 파라미터 값들이 객체의 속성 값으로 자동으로 바인딩되어 전송정보를 얻을 수 있따


	@RequestMapping("/data3") 
	public String paramData3(ParamMember member){ // DTO 객체랑 느낌 비슷한듯?
		
		System.out.println("이름:"+member.getName()+", 나이:"+member.getAge());
		return "param/paramPrint";
	}



	: jsp 에서 setProperty 를 <jsp:setProperty name="myStudent" property="*" /> 와 같이 간편하게 작성할 수 있었던것과 비슷한 원리다
		: https://dololak.tistory.com/531
		: 그러니까 myStudent 라는 객체에 모든 param값을 자동으로 해당 멤버에 할당해준단 얘기다
		: 원래느 ㄴ	<jsp:setProperty name="myStudent" property="sID" param="paramsID"/> 로 일일히 작성해줘야됬었는데 한꺼번에 넘겨주는거
			: <jsp:setProperty name="myStudent" property="sID" param="paramsID"/> 의 의미 == myStudent 의 sID라는 필드값에 파라미터명이 paramsID 인 파라미터에 할당된값을 할당해준다
			: property 속성 >> 해당 객체의 필드명
			: param 속성 >> parameter값.  그러니까 request.getParameter(어쩌구)



		: 그래서 커맨드 객체 활용할때도 setter 메서드가 필요했던거다

	: 커맨드 객체를 쓴다고 자동으로 setAttribute 나 addAttribute 가 되는게 아니므로 따로 model 객체도 함께 파라미터로 받고, 그 model 객체를 대상으로 커맨드 객체를 통째로 저장해준다
	: 객체를 넘겨주는거라 꺼내쓸때도 그 객체를 대상으로 접근하는거 주의
		${member.name}<br>
		${member.age}<br>

		이런식으로 객체를 대상으로하여 꺼내써야한다


체크박스로 한 name 으로 여러 value 를 받는 경우해당 필드의 타입은 List<어쩌고> 여야되고, 받은 후 el 표현식으로 꺼낼때 그냥 객체.리스트필드명 만 해줘도 잘 보인다


@ModelAttribute
addAttribute 안해도 model 객체에 데이터를 넣을 수 있따
: Command 객체의 앞에 @ModelAttribute 를 사용하여 선언해주면 model 객체에 자동으로 Command ㄱ객체가 attribute 로 저장된다

: 예시
	@PostMapping("/data")
	public String studentData(@ModelAttribute("student")Student student,Model model) {
		return "student/studentInfo";
	}
	

스프링의 구성 == Spring 의 3가지 계층 + Domain Model
: Domain Model == DTO , VO
	: 커맨드 객체를 의미
	: Data Transfer Object  
		: 계층간 데이터 교환을 위한 객체
		: Value Object. 데이터를 가지고 있는 객체 . DTO랑 거의 같음
: 3계층
	: Presentation Layer
		- 클라이언트의 요청 및 응답을 처리
		- 서비스계층, 데이터 엑세스 계층에서 발생하는 Exception을 처리
		- @Controller 어노테이션을 사용

	: Service Layer
		- 비즈니스 로직 처리와 비즈니스와 관련된 도메인 모델의 적합성 검증 트랜잭션 관리 및 처리
		- 프리젠테이션 계층과 데이터 엑세스 계층 사이를 연결하는 역할
		- 주로 인터페이스를 먼저 만들고 그걸 기반으로 서비스 (구현) 클래스를 만듬
		- @Service 어노테이션을 사용

	: Data Access Layer << DAO
		- ORM (Mybatis, Hibernate)를 주로 사용하는 계층
		- Dabase에 data를 CRUD(Create, Read, Update, Delete)하는 계층
		- 주로 인터페이스를 먼저 만들고 그걸 기반으로 DAO (구현) 클래스를 만듬
		- @Repostiory 어노테이션 사용



보통 만들때는 reposior-roty 부터 만든다. DTO . Vo. ??


개꿀팁 >> list.add( ) 매서드 같은 경우는 자체적으로 잘 넣어지면 true, 아니먄 false 를 반환한다

boolean bool = list.add(member);
return bool;



