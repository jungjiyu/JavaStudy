에러 error	
	: 하드웨어적 문제로 오류가 발생하는 것
	: 유명한 에러
		XXX cannot be resolved to a type >> 타입 철자 틀린것(ex : Interrupted 를 Interrutped 으로 잘못씀)

예외 exception
	: 사용자의 잘못된 코딩으로 발생하는 프로그램 적 오류
	: 예외가 발생하면 원래 에러와 같이 바로 종료되지만 예외처리하면 계속 실행이 가능하다
	: 예외도 클래스임 << 예외가 발생한 것은 예외 클래스의 객체가 생성된 것
		java.lang.Exception 클래스를 상속받아 만든 클래스들로 이루짐 
			: 모든 예외가 java.lang.Exception 을 상속받아 만든 것이긴 하지만 모든 (자식) 예외클래스들이 java.lang 에 속해있는 것이 아니기에 필요에 따라서 따로 import 해줘야될 수도 있다
		: 자식클래스 종류 << java.어쩌구.저쩌구Exception 형태임
			1. java.lang.RuntimeException  또는 이의 자식 클래스>> 실행 예외 runtime exception
				: 컴파일러 non 체크 예외라고도함
					: 컴파일러가 체크하지 않는 예외임. 그러니까 컴파일 타임엔 멀쩡함
				: 실행 예외에 대하여 예외 처리 코드를 넣으면 예외가 발생해도 계속 실행됨
				: 대표적인 자식 클ㄹ스
					(1) java.lang.NullPointerException
						: 아무것도 참조하고 있지 않은 레퍼런스 변수(=null 값을 가지는 레퍼런스 변수)를 대상으로 접근(활용)하려 할때 발생
							 : 그냥 그 레퍼런스 변수 자체만 print 했을땐 에러 안난다 (걍 null 이라고 정상적으로 뜸)
								:ex) 
									String str = null ;
									System.out.println(str.equals("fuck")); // 걍 단순히 System.out.println(str); 하면 에러 안난다

					(2) java.lang.ArrayIndexOutOfBoundsException
						:  존재하지 않는 배열의 인덱스로 접근할때 밣생

					(3) java.lang.NumberformatException
						: parseXXX( ) 메서드를 이용하여 문자열을 숫자로 바꿀때 숫자로 바꿀 수 없는 문자가 들어있음 발생하는 오류
					(4) java.lang.ClassCastException
						: 아슬아슬하게 올바르지 못한 강제형변환 시도시 발생
							: 똑같은 클래스를 상속한 자식 클래스로강제  형변환하려고  혹은 똑같은 인터페이스를 구현한 다른 클래스로 강제형변환 하려고 하면 나는 예외임

								ex)
									class A { }
									class B extends A{ }
									class C extends A{ }  상황일 때

									public static void main(String[] args){

										A b = new B( ); // 여기까진 다형성 구현이니 문제 없음
										C c = (C) b ; // 다른 자식 클래스로 형변환 시도햇서 실패

	


										}

							: instanceof 연산자를 사용하여 애초에 방지 가능
								ex)
   								 	A b = new B();
    									if( b instanceof B ) B bb = (B) b;
    									else C c  = (C)b;

					(5) java.lang.IllegalMonitorStateException
						: synchronized 메서드에서 써야될 메서드를 synchronized 되지 않은 메서드에서 썼을떄 발쌩

										
			2.  java.lang.RuntimeException 이 아닌 클래스 >> 일반 예외 exception
				: 컴파일러 체크 예외라고도 함 
					 컴파일 단계에서 발생하는 예외
				: 실행 예외에 대하여 예외 처리 코드를 넣으면 예외가 발생해도 계속 실행됨
				: 대표적인 자식클래스
					(1) java.io.IOException
						: java.lang 패키지가 아니라 java.io 패키지에 있는 클래스긴 하지만 자바 api 사전 보면 Exception 의 자식 클래스가 맞다고 뜬다
						: 파일관련한 입출력 클래스의 경우 대부분 throws IOExcpeption 과 함께 선언되어있기 때문에(해당 클래스의 멤버(생성자 , 메서드) 쓸때 try( ... ){ ... }catch(IOException e){}  의 꼴로 써야된다.(=해당 멤버를 호출한 쪽에서 try-catch 구문으로 예외처리 해줘야되니까) 
							: scanner 도 그냥 키보드로 입력받을땐 별처리 안해줘도 괜찮지만 파일을 arg 로 하여 입력받을떈 throws IOExcpetion 이 되어있기에 try-catch 구문 써줘야되는거다
					
				

	:예외 처리 exception handling
		: 일반 예외 , 실행 예외 모두 예외처리 코드로 프로그램 중단되는걸 막을 수 있음

		: 방법
			(1) try - catch - finally 블록
				:  메서드 뿐 아니라 생성자 내부서도 쓸 수 있음
				: 형식)
						try{
	
						예외발생시킬수도 있는 코드

						}catch(발생할 수 있는 에외클래스 타입의 매개변수){

							예외발생시 수행할 코드

						}finally{
							예외발생하건안하건 수행할 코드
						}

				: try 블럭 ) 
					: 블럭에는 예외발생 가능성있는 코드를 포함
					: try 옆에 괄호 치고 arg 넣을때도 있고 안넣을 때도 있음(대부분 안씀)
						: 괄호 치고 뭐 넣는 특수한 경우
							1. 파일 입출력할때 
								: 스트림 클래스의 객체 참조 변수를 arg 로 씀 
									: try 의 arg 로 넣음 예외가 발생해서 종료됬건 예외없이 끝까지 실행해 종료됬건 try 구문이 종료되면 arg로 넣은 스트림을 자동으로 close( ) 시키는 기능 쓰려고 많이 한다
									
					: 실제로 예외가 발생하면 
						: 예외 발생한 라인 이후 라인들은 실행 안하고 곧바로 catch블럭 실행
							: 예외발생했더라도 catch 문으로 가면 프로그램이 종료가 되진 않음
	
					:  try 블럭 끝까지 예외가 발생하지 않으면
						: (finally 블럭이 있다면) finally 문으로 감
				
				: catch 블럭 )
					: 매개변수 꼭 선언해야됨 << 매개변수 타입의 예외가 발생하는지 검사 함
						: 매개변수 부분에는 발생가능한 예외클래스 타입의 매개변수 선언을 함
					: 블럭에는 예외 발생시 실행할 코드를 포함
						: 아무것도 안써도됨
						: 주로 매개변수.printStackTrace( ); 를 내용으로 많이 씀
							: 프로그램 중단하고 나오는에러코드랑 존똑이 코드가 나오는데 프로그램이 실제로 종료되진 않게 함 
					: 다중 catch 블럭 
						: catch 문을 여러개 (이어) 써서 여러가지 발생가능한 예외에 대비한 것
						: catch 문 여러개 쓴다고 여러개 실행되는게 아니라 1개 이하로 실행됨
							: 아예 예외 발생이 안되거나 예외가 발생되거나(try 문에서 예외 밠생하면 바로 탈출해서 예외가 2개 이상은 발생 불가함)
						: 예외검사 순서 ) 위에서 아래로
								: 위-->아래로 갈수록 매개변수 내용이 상위클래스의 예외여야된다
									: 효율적이지 않아서 그런것도 있지만(충분히 세세하게 에러 체크가 가능했었는데 굳이  뭉뚱그려서 에러를 검사할 이윤 없으니까) 순서를 지키지 않으면 에러난다
									: 주로 상위 클래스 에러는 Exception  을 의미한다 
						: 형식
		
							catch( 매개변수1 ){
								실행내용
							}catch( 매개변수2 ){
								실행내용
							}

								: 위-->아래로 갈수록 매개변수 내용이 상위클래스의 예외여야된다
								:중첩이 아니라 다중임을 주의 (줄줄이 나오는 형식이지 양파같은 형식이 아님)
				
					: (만약에 실행된다면 ) 다 실행하면 finally 블럭으로 감
 
				: finally 블럭 )
					: 필수는 아님
					: try 문, catch 문에 " return " 이 있더라도 반드시 실행되는 강력한 블럭임

			(2) thorws 예외클래스명
				: 메서드 혹은 생성자 내부서 발생한 예외를 메서드 혹은 생성자를 호출한 곳으로 다시 떠넘긴다.
				: 자바 api 사전에서 생성자나 메서드 선언부에 thorws 예외1 , 예외2 ... 포함되어있으면 그 생성자나 메서드 사용하려면 try-catch 구문 내부서 활용해야된다.
				: 참고 ) (main(String[] args) 옆에 throws 키워드 붙이면 ) 메인 메서드에서도 메인메서드 내에서 발생한 예외를 떠넘기기를 (JVM을 향해) 할 수 있고, 이경우 예외문구 출력과함께 프로그램을 종료시킨다. 하지만 이렇게 잘 안한다고 한다
					
				: 형식 		
					step1. 
						 ... 메서드명 throws 예외명1, 예외명2 ...
							: 예외 발생 가능한 메서드 선언부의 메서드명 바로 옆에다 throws 추가
							: 예외명 여러개 쓸 수 있다

					step2.
						try{
					      ....   메서드명( ) ;	//메서드 호출

						}catch(예외명1 ){
							예외처리코드
						}catch(예외명2 ){
							예외처리코드
						}
							:  메서드 호출을 try 구문에서 해놓고 해당 메서드에서 throw 하게한 예외의 처리를 try문 뒤에 catch 로 해줌

					: 예시)
						  public static void main(String[] args) {
    	
    						  		try {
   						   			uu();
    						  		}catch(ClassCastException e) { // 떠넘긴 예외를 처리한다
    							  		System.out.println ("~올바르지 못한 강제 형변환~");
    						  		} 	
    
							}
    
    						public static void uu() throws ClassCastException{ // 예외처리를 호출된 곳으로 떠넘긴다

    								A b  = new B();
    								C c = (C)b;
    	
    							}
  
 

						

			
