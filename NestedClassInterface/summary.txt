중첩 클래스 Nested Class
	: 클래스 내부에 선언한 클래스 
	: 종류가 뭐가 됬건(멤버이건 로컬익건) 중첩 (inner) 클래스도 하나의 클래스이기 떄문에 컴파일 하면 대응하는 클래스 파일이 생겨난다
	: 왜 쓰는가 >> 특정 클래스에서만 의존성을 가지는(== 필요로 하는) 클래스이면 굳이 따로 선언하지 않고 내부 클래스로 선언

	: 종류
		1. 멤버 클래스
			: 컴파일하면 'outer클래스$inner클래스.class' 로 클래스 파일이 생성된다
			
			(1) 인스턴스 멤버 클래스
				: static 이건 , 인스턴스 타입 이건 inner 클래스의 레퍼런스변수 타입은 'outer클래스.inner클래스' 라고 봄 된다.
				:  inner 클래스 객체를 생성할 경우 자동적으로 outer 클래스 객체의 생성이 선행되고, 이  outer객체를 참조하여 inner 클래스 객체가 생성됨
					: 이떄문에 인스턴스 inner 멤버 클래스의 경우엔 'qualified this' 를 사용 가능하다
						: quaified this, 즉 정규화된 this >> outer클래스.this 로 헤당 inner 클래스의 객체가 참조하는 outer 클래스의 객체를 활용 가능하다
					: inner 클래스가 컴파일되어 생성된 outer클래스$inner클래스.class 파일을 디컴파일 해보면(사이트에서 프로그램 돌림 됨)  inner 클래스의 생성자는 ( 생성자의 arg 가 따로 있던 말건간에) 추가적인 arg 로 outer 클래스의 객체를 받아와서,  내부의 레퍼런스 필드로 그 outer 클래스의 객체를 가리키게함을 알 수 있다.

public class A {
	B b =null;
	A( ){
		System.out.println("A생성자 실행됨");
		b = new B(10); // b = this.new B(10); 이랑 같은 표현
	}
	
	public void doSomething() {
		b.sayB();
	}
	
	class B{ // 인스턴스 inner 클래스
		int num = 0;
		B(int b){
			System.out.println("B생성자 실행됨");
			num = b;
		}

		public void sayB() {
			System.out.println("B"+num);
		}
	}
	

}

를 컴파일해서 생긴 클래스 파일을 디컴파일 하면 아래와 같다

class A$B {
   int num;
   // $FF: synthetic field
   final A this$0;

   A$B(A var1, int b) {
      this.this$0 = var1;
      this.num = 0;
      System.out.println("B생성자 실행됨");
      this.num = b;
   }

   public void sayB() {
      System.out.println("B");
   }
}

				: 클래스 외부서 인스턴스 inner 클래스 객체 생성 방법 ) 
					outer클래스타입.inner클래스타입 레퍼런스변수명 = new outer클래스( ).new inner클래스( ) ; 
						: outer 클래스 혹은 inner 클래스의 생성자가 별도의 arg 를 필요로 한다면 arg 를 넣어도 된다.
						: 한꺼번에  new outer클래스( ).new inner클래스( ) ; 안하고 먼저 outer 클래스의 객체를 따로 생성한 후  outer클래스객체.new inner클래스( ) ; 해도 된다.

				: 클래스 내부에서 인스턴스 inner 클래스 객체 생성 방법 ) 
					inner클래스타입 레퍼런스변수명 = new inner클래스( ) ; 
						: 사실상 outer클래스타입.inner클래스타입 레퍼런스변수명 = this.new inner클래스( ) ; 
 인거다

				: 주로 outer 클래스의 내부에서 사용할 목적인 클래스일 경우 사용한다
					: 외부에서도 사용할 inner 멤버 클래스를 만들고 싶으면, inner 멤버 클래스가 아닌 static 멤버 클래스를 활용해야한다
						: 메모리 누수 문제 때문 >> outer 클래스 객체를 생성하고 싶지 않아도 inner 클래스를 생성하기 위해선 반드시 그를 참조하는 outer 클래스의 객체가 생성되어있어야하므로 메모리를 꽤나 많이 차지하고, 이게 누적되면 stack overflow 를 일으킬 수 있다.
					: 따라서(<< 외부에선 잘 사용 안하므로) 주로 private 접근 제한자로 선언된다.
					: outer 클래스의 static 멤버에선 사용하지 못하고, 인스턴스 멤버에선 맘껏 사용 가능하다
						: 인스턴스 inner 클래스도 결국 인스턴스 멤버라서 static 멤버에선 사용하지 못하는거다
						: outer 클래스의 생성자 부분에서도 사용 가능하다
							: 생성자 내부에서 this 를 통해 생성자가 다 끝마치기 이전에도 해당 클래스 내부의 멤버에 접근 가능하고, inner 클래스 또한 인스턴스 멤버인걸 생각함 이해가 잘 된다.
							: 그러니까 생성자 내부의 ' new inner클래스 ( ); ' 는 사실상 ' this.new inner클래스( )' 이기 때문에 여기서도 일단 outer 클래스 객체 먼저 생성하고 inner 클래스 객체 생성한거다

					
			(2) static 멤버 클래스 
				: outer 객체를 별도로 생성하지 않고 inner 클래스의 객체를 생성 가능
				: 클래스 외부서 static inner 클래스 객체 생성 방법 ) 
					outer클래스타입.inner클래스타입 레퍼런스변수명 = new outer클래스.inner클래스( ) ; 
						: outer 클래스 혹은 inner 클래스의 생성자가 별도의 arg 를 필요로 한다면 arg 를 넣어도 된다.
						: instance 일때 outer 클래스의 객체 자리였던걸 outer 클래스로 대체한꼴이다

				: 클래스 내부에서 static inner 클래스 객체 생성 방법 ) 
					inner클래스타입 레퍼런스변수명 = new inner클래스( ) ; 
						: 사실상 outer클래스타입.inner클래스타입 레퍼런스변수명 = new outer클래스타입.inner클래스( ) ;  인거다

				: 주로 outer 클래스의 외부에서"도" 사용할 목적인 클래스일 경우 사용한다.
					: 따라서(<< 외부에선 잘 사용 안하므로) 주로 public,  접근 제한자로 선언된다.

				: 헷갈리지 말아야할 것은 static inner 클래스 도 인스턴스 멤버를 가질 수 있다
					: inner 클래스 타입이 static 인건 outer 객체가 아닌 outer 클래스를 대상으로 객체의 생성이 가능한거란 의미이고, 해당 클래스의 객체를 생성할 수 있는 만큼 내부적으로 인스턴스 멤버를 가질 수 있다.
					: 물론 outer 클래스의 타 인스턴스 멤버를 이용할 순 없다. 

		2. 로컬 클래스
			: 컴파일 하면 'outer클래스$1inner클래스.class' 로 클래스 파일이 생성된다.
			: 블럭 내(<< 메서드, 생성자 ... )에서 선언된 클래스로, 블럭이 실행될떄 생성되고 블럭이 끝나면 소멸된다.
			: 주의)
				1. 로컬 클래스 내에서 클래스 외부의 외부 로컬 변수 사용에 대한 제약이 있다
					(1) 일단 로컬 변수 값을 수정할 수 없다
						: ㅈㄴ 주의해야할 것은 막상 인스턴스 변수는 수정까지 가능하다
					(2) 로컬 변수 값을 가져다가 쓸 순 있는데 final 의 형태로 사용해야된다(물론 로컬 변수가 static 은 아니니까 static final 은 아니고 걍 final 임) 
 						: 이것 때문에 (1) 이 강제되는것도 있다

				2.  java17 부터 로컬 클래스의 static 멤버 선언도 가능해졌다


중첩 인터페이스
	: 특정 클래스 내부에서 선언된 인터페이스를 의미한다
	: 안드로이드 같은 UI 프로그램에서 이벤트를 처리할 목적으로 많이 활용된다고 한다
	: 중첩 inner 클래스와 다르게 static 만 가능하고, static 을 명시하지 않을 경우 자동으로 static 이 추가되어 컴파일 된다.
		: 왜>> 인스턴스 inner 클래스의 경우 컴파일하면 inner 클래스의 생성자의 arg 로 받은 outer 클래스의 객체를 인스턴스 final 변수에 담아두는걸 알고 있을 것이다. 근데 생각해보면 인터페이스의 경우 필드는 static final 밖에 가질 수 없고, 생성자도 기본적으론 없다.
		: 로컬은 ... 딱히 필요가 있을까?
