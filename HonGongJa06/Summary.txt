
객체지향프로그래밍
	: 단계
		1. 클래스 설계
		2. 클래스로 인스턴스 생성
		3. 인스턴스 활용


객체 0bject 혹은 instance
	: instance 는 특정 클래스로 만들어진 객체를 의미
		: 그러니까 객체가 더 큰 범주인것
	: 부품 
	: 객체지향프로그래밍
		: 객체를 사용하는 프로그래밍
	
	: 객체 간의 관계
		1. 집합  관계:  부품과 완성품의 관계
			ex) 타이어(=부품)와 완성품(=자동차)

		2. 상속 관계: 부모객체(=상위 객체)와 자식객체(=하위객체)의 관계
			: 부모객체 ) 종류. 자식객체의 큰 범주
			: 자식 객체 ) 구체적인 사물 같은 것
			ex) 기계(=상위객체)와 자동차(=하위객체)

		3. 사용 관계: 객체간의 상호작용
			: 집합도 , 상속도 아닌 관계
			ex) 사람과 자동차
	: 객체는 힙 영역에 저장

클래스 Class
	: 객체 instance를 만드는 설계도 역할
		: 인스턴스화 ) 클래스로부터 인스턴스(들)을 만드는 것 
	: main() 메서드가 
		있다 >>  걍 쓴다 (? 어캐??)
		없다 >> 객체를 만들고 써야된다

	: 클래스의 종류
		1. 라이브러리 ( API ) 클래스
			: 다른 클래스에서 이용할 목적으로 만들어지는 클래스
			: 한 프로그램에 여러개 존재 가능

		2. 실행 클래스
			: 코드를 실행시키는 클래스 .
			: 전체프로그램 중에 단 1개 존재

		3. 라이브러리인 동시에 실행클래스 
			: 귀찮아서 라이브러리 클래스 내부에 실행 클래스 만들어둔것
			: 비추 >> 대부분 1.과 2. 로 분리해서 만든다


	: 클래스 선언
		선언 위치 종류
			: 다른 소스파일로 세분해 놨냐 여부와 상관 없이(종류1이든 종류2든) 바이크 코드 파일(.class)는 선언된 클래스의 개수만큼 생성됨
			1. 클래스명.java로 새로운 소스파일에 생성
				: 종류1을 추천	
					: public 접근 제한자) 소스파일명과 동일한 이름의 클래스 선언에만 사용 가능
			2. 기존 작업 중이던 소스파일에 생성	
			
	: 객체 생성
		형식: 클래스명 참조변수명 =  new 생성자;
			: 생성자 == 클래스명( )	
			new 연산자 : 클래스로부터 객체를 생성시키고 생성된 객체의 주소를 반환하는 연산자
				: 반환된 주소를 해당 클래스의 참조타입변수에 할당하여 객체를 사용함
					: 클래스는 메소드영역에 존재해있었던거고 이걸로 힙 영역에 새롭게 객체를 생성시킨거고
					  참조변수는 새롭게 스택영역에  생성되며 앞서 생성됬던 객체의 주소를 받는거임
						: 참조변수명으로 힙에 객체가 생성되는게아니고 걍 해당 클래스의 객체로서 객체가 생성되는거다(= 객체를 부를때 해당클래스의 instance라고 하지 참조변수를 객체라고 하진 않는다) 

			

	: 클래스의 멤버의 세세한 종류
		: 선언된 클래스 내부에서 필드, 메서드를 사용할땐 그냥 필드명, 메서드명으로 활용하면 되지만 
			: 선언된 클래스 외부에서 정적 멤버를 활용할 경우 클래스 자체적으로 존재하는거지, 객체 내부에 존재하는게 아니라서 별도의 객체 생성 없이 "클래스명.멤버명" 으로 클래스 외부에서 사용 가능
			:선언된 클래스 외부에서 인스턴스 멤버를 활용할 때는 객체를 생성한 후에 , 그 객체를 밝혀 사용해야됨
			: 선언된 클래스 외부에서 인스턴스 필드, 메서드가 존재하지 않으니까 함부로 못쓰고 객체 생성해서 그 필드, 메서드도 존재하게 해야 쓸 수 있음
				: 형식)
					클래스명 참조변수명 = new 생성자 ; // 객체 생성
					...... 참조변수명.필드... // 필드 활용 
					..... 리턴값 = 참조변수명.메서드명(arg1, arg2.. ); ... // 메서드 활용
				
			: 참조변수명.필드 혹은 메서드
				: 도트 연산자 == . == 객체접근연산자

 			: 선언된 클래스 내부에서 필드, 메서드를 사용할 때도 객체를 밝혀 사용할 수 있음
				: 형식)
					this.필드혹은메서드
				: this 라는 객체는 자기자신을 나타내는 변수로 별도로 객체를 생성하는과정은 필요 없음
				: 쓰는경우
					:주로 생성자나 메서드 내부에서 (가독성 높이기 위해) 변수를 인스턴스 필드명과 같은 이름으로 선언할때 필드와 변수를 구분하기 위해

				: ex)
					String name ;
					int age;
	
					Student(String name , int age){
						this.name = name;
						this.age = age;
						}

		: 오버로딩 vs 오버라이딩
			 오버로딩 : (하나에) 많이 싣는다
				1. 생성자 오버로딩: 생성자 여러개 만드는것 ( 생성자들의 이름은 당연히 하나다)
				2. 메소드 오버로딩: 하나의 메서드명으로 여러개의 메서드 만드는것

			오버라이딩 :


		1. 필드 Field (==속성)
			: "생성자 블럭"과 "메서드 블럭" 영역을 제외한 클래스 내부 영역에서 선언된 변수 역할하는 것.
				: 변수 vs 필드
					: 값을 저장하는 역할은 똑같은데 선언 위치가 다르다(그래서 생성과 소멸 시점도 다르다)
						: 생성자 블럭과 메서드 블럭에 선언된 변수는 로컬변수로 , 블럭이 끝나면 없어지고, 이를 필드라고 하진 않고, 변수라고 한다
			: 객체와 함께 생겨나고 소멸됨
			: 초기화 시켜놔도 되고 안시켜놔도됨(단순 선언만 해나도 됨)
				: 초기화 시키지 않을 시 0 비스무리한 값으로 자동 초기화
					:0 , 0.0, '\u0000', false 같은
			: 관례적으로 첫글자 대문자 안한다(띄어쓰기 구분을 위한 뒷 부분은 대문자한다)

	
		2. 생성자 Constructor
			: 객체 생성과 초기화 역할 담당

			: new 연산자로 호출됨

			: 메소드랑은 다른거임
				1. 리턴타입이 없음
					: 선언할때 이름앞에 void 조차도 명시 안한단 소리임 
				2. 이름이 자신이 소속된 클래스명임

			: 한 클래스에 반드시 컴파일러에 의해서든 직접 명시하든 하나 "이상" (여러개의 생성자 존재가능)의 생성자 필요		

			: 명시적인  생성자 선언
				:형태) 
					public 클래스명( param1 , param2 ... ){  어쩌구 저쩌구  }
						: public 써도 되고 안써도 됨
						: param 선언은 생성자 블럭 내부에서 필요하면 쓰는거고 불필요하면 안써도 됨

			: 명시적이지 않은 생성자 선언
				: 소스파일의 클래스 내부에 명시적으로 선언한 생성자가 하나도 없을시 컴파일러가 new 연산자 만나 객체 만들때 바이트 코드 파일에 기본 생성자를 자동으로 선언함( public 클래스명( ){     }; 꼴로 . 블럭 부분 비어있는거임. )
					:기본생성자: 
						: 형태: public 클래스명( )
						: 클래스가 public 으로 선언되있음 public 붙이고 public 없었음 public 안붙임

					: 그러니까 딱히 객체 생성시 초기화 과정이 필요없음 코드에서 생성자를 생략해도 됨
					: 명시적으로 선언한 생성자가 하나라도 있을시 기본생성자는 생성되지 않음 
			
			: 생성자 오버로딩
				: 매개변수 구성( 타입 , 개수 , 순서)이 다른 생성자를 여러개 선언하는 것
					: 구성이 다른 ex) 
						ClassEx( String name, int Age , int Score );
						ClassEx( String name, int Age );
						ClassEx( int Age ,  String name );
						ClassEx( String name );

					:  단순히 매개변수 이름만 다르게 선언하는건 오버로딩이 아니다
						: 구성이 같은 ex) 
							ClassEx( String name, int Age , int Score);
							ClassEx( String names , int Ages , int Scores);
				: 생성자가 오버로딩 되있으면 new 연산자로 생성자를 생성할때 제공된 arg 의 구성에 따라 자동으로 해당 매개변수 구성의 생성자를 매치시켜줌
				: 까먹지 말아야할것은 명시적인 생성자를 한 경우 기본생성자는 자동 생성되지 않기 때문에 만약에 기본생성자도 택할 수 있게 하려면 직접 기본생성자를 명시해야됨
				: 생성자의 중복 코드 제거하는 법( 다른 생성자를 호출하는 법)  : this( arg1 , arg2, ... ) 사용 
					: 이게 왜 필요 ) 매개변수 구성만 다르고 블럭 내용이 거의 또이또이한 상황에서 공통적으로 해당하는 부분을 각 생성자 블럭에 일일이 쓰기 귀찮으니까 겹치는 부분은 따로 정리하고 그걸로 짧게 대체하는 것
					: this( arg1 , arg2, ... )
						: 자신이 속한 클래스의 다른 생성자를 호출하는 코드
						: 오직 "생성자"의 "첫줄" 부분에서만 사용 가능
						: 생성자의 형태인 "클래스명( )"에서 클래스명이 this 로 대체된 것.
						: 선언한 생성자의 형태에 맞춰서 쓰기만 하면 알아서 잘 찾아간다
							ex)
							public class Student {
	
								String name;
								int age;
	
								Student(){ } // 기본생성자
	
								Student(String  name){ // 생성자1
									this(name , 70); // 똑같은 코드 귀찮게 또 쓰지 않기 위해 첫줄에 this( ) 사용
									System.out.println("1번째 Student 생성자애 들어왔습나다");

								}
								
								Student(int age){ // 생성자2
									this("Trump",age);
									System.out.println("2번째 Student 생성자애 들어왔습나다");

								}
		
	
								Student(String name , int age){ // 생성자3
									this(age,name);
									System.out.println("3번째 Student 생성자애 들어왔습나다");
								}
	
								Student( int age, String name){ // 생성자4
									this.name = name; // 필드명과 겹치는 param명을 사용하기 위해 this 객체( 클래스 자기자신)를 사용
									this.age = age;
									System.out.println("4번째 Student 생성자애 들어왔습나다");

								}
	

								void PrintInfo() {
									System.out.println("이름: "+name);
									System.out.println("나이: "+age);
								}

							}

				
		3. 메소드 Method
			: 클래스 내부에서 선언된 함수
			: 객체와 객체들 간의 상호작용은 메소드를 통해 이루어짐
			: 메소드 선언 == 메소드 시그니처 + 메소드 실행 블럭
				: 메소드 시그니처 (=메소드 선언부)	
					: 형식)
						리턴타입 메서드명( param1, param2 ..선언 )
							: 리턴값이 없는 경우 리턴타입은 void 로 설정
								: 리턴타입이 void 여도 강제 종료의 목적으로 return 문 사용 가능) return ; 함 됨 (리턴 바로 뒤에 세미콜론 갈기기)

					: arg의 자동타입변환을 허용함( 그러니까 param을 넉넉한 걸로 잡는게 좋다. 그래야 꼭 똑같은 타입이 아니더라도 arg를 받을 수 있을거니까)
			
					: 다양한 갯수의 arg 를 한 메서드로 받을 수 있게 하는 법
						: 메소드 오버로딩 아님 주의 (메소드 오버로딩은 똑같은 메서드 명으로 여러개 선언하는 것)
						sol1 )  매개변수를 배열 타입으로 선언하기 : 비추
								: 단점 ) 무조건 객체를 생성하고 넘겨야됨(씁 근데 이게 글케 귀찮은가)
									: arg 로 넘길 객체 생성 case
										방법1) 괄호 밖 부분에서 객체 와 참조변수 생성하고 참조변수를 arg 로 함
										방법2) 괄호 안에서 객체만 생성하기	
											: 주의해야할 것이 변수 선언과 동시에 일어나는게 아니기 때문에 쌩 {val1 , val2 ...} 처럼 중괄호는 안되고 new. .. 아니 그럼 안에서 변수 선언을 하면? 안되는 거임?
										: 참고로 괄호 안에서 객체와 참조변수를 생성할 순 없음(arg 받아야할 부분에서 변수 선언만 했지 넘길 대상을 쓰지 않았잖아)
 	

									ex)
									클래스 부분에서   mthd( int[ ] ary ); 로 메서드가 선언되있다 치고
									실행파일에서 객체가 poop 로 생성되있다 칠때
										// 방법1: arg 밖 부분에서 객체 만든것을 넘기기
											int [ ] ary = {1,2,3,4}; 
											poop.mthd(ary); 
										// 방법2:  arg 안에서 객체 생성하기	
											poop.mthd( new int[ ]{1,2,3,4} );
										// poop.mthd(int [ ]hehehe = {4,5,6,7}); 은 불가
		
				
					 	sol2 ) 매개변수를 ... 를 이용하여 선언하기 : 추천
								: 장점 ) 객체 생성없이 콤마로 구분지은 값 목록만 넘겨줘도 되고 걍 객체를 넘겨줘도 됨
								: 작동 방식 ) 콤마로 구분지은 값을 받으면 자동으로 메서드의 param 부분에서 배열을 생성함. (물론 걍 객체를 넘겨받은 경우라면 걍 그 객체를 활용함)

				: 실행 블럭 : {  어쩌구 저쩌구 }
					: 존나 신기한게 자바에서는 메서드 내에서도 arg 로 받은 array의 사이즈를 length 를 이용하여 측정할 수 있다 

					: 참고로 자바에서는 존나 정확하게 실행블럭의 마지막 return 문 다음에도 실행할 코드가 존재하면 에러 내버린다( return 문 사이의 문장은 괜찮다)
						ex) 
						int mthd( ){
						System.out.println(" 쏼라쏼라");
						return 2;  
						System.out.println("쌀국수"); //가능: 마지막 리턴문의 앞에 위치해서
						return 3; // 마지막 리턴문					
						System.out.println("포베이"); // 불가: 마지막 리턴문의 뒤에 위치해서
						}

			: 메소드 오버로딩
				: 클래스 내에 param종류가 다른 같은 이름의 메소드를 여러개 선언하는 것
					: 주의해야할게 반환형은 메소드 오버로딩에 전혀 관여 안함
						: 메소드 오버로딩의 기준도 아니고(반환형이 같든 다르든 param 종류에 따라서만 오버로딩 가능 여부 정해짐) 오버로딩 시킬때 메소드끼리 타입이 같을 필요없음
					: param이 다르다의 기준은 생성자오버로딩에서와 같음( 단순히 매개변수명만 다름 안되고 매개변수의 순서,타입,개수 중 적어도 하나가 달라야됨)

				: 헷갈리지 말아야할 점은 생성자 오버로딩에서처럼 this( )를 사용할 수 없음
					: this 는 클래스, 객체 자기자신을 나타내는건데 생성자처럼 형태가 "클래스명( )" 인게 아니라 걍 "쏼라쏼라( )"꼴이니까

				: 오버로딩 상황에서 메소드 pick 우선순위
					1st 자동형변환 고려 안해도  param 타입 == arg 타입 인거
					2nd 자동형변환 고려했을때 param 타입 ==  arg 타입인거
						ex)
							클래스에서
							mthd(int a, int b) , mthd(double a, double b) 가 선언되있을떄
							
							활용 파일에서
							객체.mthd(10.2 , 3); 하면 두번째 메서드( mthd(double a, double b) )가 사용됨. 일단 완전 타입 일치하는건 없는데  자동형변환 고려했을때는 가능한거니까
							
				
	: 클래스 멤버의 큰 종류
		: 왜 굳이 이렇게 나눠야되나) 
			:객체마다 필드가 달라야 되면 객체마다 당연히 해당 필드를 가져야됨.
			: 객체의 필드값이 모두 같은 경우에 객체마다 갖고 있게하면 메모리 낭비이고( 에러가 나는건 아니지만 ), 오히려 해당 필드는 한곳에 위치시키고 공유하게 하는 쪽이(공용으로 쓰게하는 쪽이) 더 효율적임

		1. 인스턴스(instance) 멤버 :
			: 객체를 생성한 후에 존재하는(사용가능한) 필드와 메서드로, 클래스 밖에서의 사용을 위해선 객체를 명시하고 써야 쓸 수 있음(  객체참조변수명.메서드 혹은 필드명으로 )
				: 객체마다 가지고 있는거임
			: 종류 세분화
				: 인스턴스 생성자라는 표현은 없는듯( 왜냐하면 생성자는 걍 객체 별로 무조건 필요한거고 , 객체가 없음 따로 세팅할 필요는 없으니까 굳이 인스턴스, 정적이라는 개념을 도입할 필요가 없는 듯)
				(1) 인스턴스 필드 : 정적필드가 아닌(static 키워드와 선언되지 않은) 필드
				(2) 인스턴스 메서드 :  정적 메서드가 아닌 (static 키워드와 선언되지 않은) 메서드
					: 보통 내부적으로 인스턴스 필드 포함하지 않으면 static 붙여 정젓메서드로 선언하니까 인스턴스 메서드는 대부분의 경우 인스턴스 필드를 포함하는 메서드라고 보면 됨
						
			: 저장위치
				인스턴스 필드 : 객체와 함께 힙에 저장됨 
				인스턴스 메서드 : 클래스와 함께 메서드 영역에 저장됨

				: 컴파일 타임에 메모리에 올라감 == static binding <---> Dynamic binding == 런타임에 메모리에 올라감
					: 힙 영역에 저장되는 값들은 모두 런타임에 저장된다
						: 객체들은 런타임에 생성된다

			: 메서드는 왜 인스턴스 멤버로 분류될까? 코드가 객체 별로 다른 것도 아니고, 클래스와 함께 메서드 영역에 존재하는데?
				: 메서드 내부 블럭에 인스턴스 필드 등을 포함하고 있어 ( 코드 자체는 같을 지라도 ) 객체 없이는 ( 인스턴스 필드값을 가져올 수가 없어) 실행이 불가하기 때문
	
			: 인스턴스 멤버 선언 , 생성 방법) 일반적인 방법으로 생성

			: this
				: 클래스 내부에서 객체 자신을 의미하는 변수
				: 이름이 같은 "인스턴스 필드"와 "클래스 변수"를 구분하기 위해 사용
					: 정적 메서드에서는 쓰이지 못하는게 당연한게 this 를 쓰는 순간 클래스 내부에 있는 필드를 사용한다는게 되기 때문

		2. 정적(static) 멤버 
			: 객체 생성 없이 사용할 수 있는 필드와 메서드
			: 클래스에 위치하여 객체들이 공유힌다(객체 각각이 가지고 있는게 아니라)
				: 클래스에 고정되어있는 멤버들이라 클래스 로더가 클래스(바이트 코드)를 읽어서 메소드 영역에 적재된(데이터를 저장시키면) 후 바로 사용이 가능하다
				: 사용할땐 클래스명.멤버명 으로 사용한다 ( 객체명.멤버명 이 아니다 )
					: 사실 객체명.멤버명으로도 사용이 가능하긴 한데 정적멤버는 걍 클래스명.멤버명으로 활용하는걸 추천( 경고 표시 남)
				: 컴파일 타임에 메서드 영역에 저장된다. 
					
			: 종류 세분화
				: 정적 생성자라는 표현은 없는듯
				(1) 정적 필드: static 키워드와 함께 선언된 필드
				(2) 정적 메서드: static 키워드와 함께 선언된 메서드 
					: 블럭 내부적으로 인스턴스 필드를 포함하지 않으면 (꼭 필수는 아니지만) 정적 메서드로 선언하는게 "매우" 효율적임
						: 객체 별로 다를 수가 없으니까 메모리 아껴야징 :~D

					: 정적 메서드여도 내부적으로 인스턴스 필드를 사용 가능함
						: 그냥은 안되고 내부에서 (자신이 속한 클래스의) 객체 선언 후 사용햐야됨
					
					: 정적메서드의 내부에서 (같은 클래스 내에 선언되 있는) 다른 정적 멤버는 (클래스 명시없이도) 그냥 사용 가능함		
										ex)

											public class StaticCar {
												//정적필드 : 모든 객체가 공유
												static String company = "Tesla";
												static String CEO= "Jiyu";
	
												static void shoutoutCEO() {
													// 정적 메소드 내부에서  같은 클래스 내의 정적 멤버는 다른 명시 필요없이 사용가능하다.
													System.out.println(CEO+CEO+CEO);
												}
	
											}

				: 정적 메서드 내부에서 this 키워드 못쓰는거 주의
					: this 의미가 객체를 나타내는거니까 객체적인 접근은 옳지 않음

				: public static void main( String[ ] args )에도 적용되는 사항임 (static 으로 선언되있으니까)

								

			: 정적 멤버 선언 ) 인스턴스 멤버 선언문 젤 앞에다 static 키워드 추가한 꼴
				: 형식)
					(1) static 타입 필드명 
						: 정적필드는 인스턴스 필드 선언할 때와 마찬가지로 선언과 동시에 초기화 해놀 수 있음
						
					(2) static 반환형 메서드명( param1 ,... ){  어쩌구   }
		
: 싱글톤 Singleton
	: 전체 프로그램에서 단 하나의 객체만 만들도록 제한해놓는것
	: 자바 내부적으로 singleton 이란 기능이 있는게 아니라 직접 구현하자는거
	: how
		1. 생성자에 private 걸어둠
		2. 클래스 블럭 내부의 모든 블럭의 외부에서 new 연산자 써서 객체를 하나 생성하고 그걸  static 필드로 참조함 
		3. getInstance( ) 라는 메서드를 static 으로 선언하고 만들어둔 객체를 리턴하게 함

	: 원리
		: 어떻게 전체 프로그램에서 단 하나의 객체만 존재하게 할까
			: 생성자에 private 걸어놔서 외부에선 (new 통해) 생성 못하게 막고 클래스 내부서 new 연산자를 통해 한 객체를 생성해둔다
				: 이때 static 키워드 써서 참조 변수 선언해야된다(이유는 바로 다음 줄에)

		 : 그럼 어떻게 해당 객체를 외부에서 사용할까? 
			:  " getInstance( ) "라는(꼭 이름이 이거여야되는건 아닌데 통상적으로 이 메서드명을 많이 사용한다 ) 메서드를 만들고 이를 호출하면 객체를 리턴해 외부 클래스에서 이를 받아 사용, 수정한다
				:  " static "으로 선언하여 외부에서 객체 생성 없이도 사용할 수 있게 한다
					: 메서드가 static 으로 선언되있으므로 내부에 생성해둔 객체참조변수를 사용하기 위해서는 그 변수도 static 키워드 써서 선언했어야 된다
						: 그냥 객체참조변수를 인스턴스 형으로 선언하고 getInstance( )내부에서 따로 객체를 만들어 사용하면 안되는 이유는 getInstance( ) 호출할때마다 새로운 객체가 생성되어 기존 내용 못쓴다
 

: final 필드 
	: 사용법 : ( static 이 있다면 static 뒤에 ) 멤버명 앞에 위치 시킨 후 선언
			ex) public static final int answer ; 
			ex) public final int answer ; 
	: 최종적 . 수정 불가 라는 의미
	: 초기화 시점 이후 수정 불가( 처음에 가진 값을 쭉 가져감)
		: final 필드 초기화 가능 시점
			: 오직 아래의 2가지 케이스 중 하나로만 초기화 가능
				1. final 필드 선언과 동시에 초기화 - 객체 별로 다른 final 값을 가지게 할게 아니면 이게 효율적
					: 주로 이 경우엔 그냥 final 이 아니라 static final 로 선언하겠지
						: 객체별로 다른것도 아닌데 굳이 객체별로 여러개 만들 필요 없으니까

				2.  생성자 부분에서 초기화 - 주로 객체 별로 다른 fianl 값을 가지게 해야되는 상황에서 사용
					: 주로 이 경우엔 그냥 final 로 선언하겠지
						: 객체별로 다른 final 값인니까


			: 초기화 가능 시점이 위의 2가지인 이유 - 클래스가 만들어질때 혹은 객체가 태어날 때 가진 값을 쭉 가져가겠단 의미가 큼

	: 상수 constant
		: 단순히 final 을 써서 고정값 만든건 상수가 아님
			: 객체별로 다른 고정값을 가질 수 있으니까
		: static final 로 선언한게 상수임
			: 전체를 통틀어 하나의 고정값을 가지니까
		: 대문자로 쓰는게 관례적

				




패키지  
	: 패키지 표현 ) 내림차순으로 적고(포괄적인 것부터 먼저 적고), 쩜으로 구분
		ex)
			패키지3
				▼패키지2
					▼패키지1		일때 패키지 1 == 패키지3.패키지2.패키지1

	
	
	: 패키지 선언 
		: 해당 클래스가 어떤 패키지에 속할 것인지 선언하는것
		: 클래스 선언의 윗 부분에 적음
		: 형식 )
			package 클래스가속할패키지;
				: 찐으로 클래스가 속하게될 패키지를 적는거다. 여기에 클래스명까지 적는게 아니다
	
	
	: 왜 필요) 
		1. 파일 시스템의 폴더 기능
			: 클래스를 체계적으로 관리하기 위해 (=유지보수위해)
		2. 클래스 간의 식별자 기능
			: 이름이 같은 클래스여도 다른 패키지에 있음 다른 클래스로 인식됨
				: 사실 클래스의 풀클래스명은 "속한패키지.클래스명 " 으로, 패키지도 클래스의 일부이다.
					: 특정 패키지에 있던 클래스는 클래스만 외부로 불러선 쓰지 못하고 쓸꺼면 클래스가 속한 패키지 전체를 불러야됨( 패키지까지 클래스의 일부니까)
	

	: 다른 패키지의 클래스, 인터페이스 사용하는 법
		: import 문 사용
			: 형식 ) import 풀클래스명;
				: 단순 속한풀패키지명 이 아니라 풀클래스명 이니까 끝은 항상 클래스명으로 끝나는거다
				: 특정 패키지 내부의 모든 클래스를 불러오고 싶음 * 쓰면 된다
					: ex) import 패키지1.패키지2.* ; // 패키지2 "내부"의 모든 클래스 불러온다

				: 주의할 것은 " import 한 클래스가 속한 패키지"의 "하위 패키지의 클래스"까지 불러와 지는게 아니라 딱 그  클래스만 불러와지는거다
					: * 을 써서 불러와도 * 바로 앞에 적은 패키지 내의 모든 클래스만 불러와지지, 그 패키지의 하위 패키지는 불러와 지지 않고, 하위 패키지들의 클래스들은 더더욱 불러와지지 않는다.

				: 또 주의할 것은 클래스를 import 했다고 그 클래스를 반드시 쓸 수 있는게 아니라 그 클래스, 생성자의 접근 제한자에 따라서 못쓰는 상황이 발생할 수 있다
			
			: import 문 위치 ) 패키지 선언과 클래스 선언 사이에 적는다	
			
		: 불러온 클래스 사용하는법 ) 불러온 클래스는 원래부터 해당 패키지,파일 내에 존재했던 클래스였던것처럼  쓰면 된다.
				: "기존 파일에 찐으로 존재하는 클래스 내부"에 있었던 것처럼 쓰라는게 아니다. 클래스 내부에 클래스가 있는건 불가하니까 찐으로 존재하는 클래스 외부에 존재했던 것처럼 쓰라는거다
					: import 문으로 불러온 클래스의 static 으로 정의된 멤버를 사용할 경우 main( )을 포함하는 클래스 내에 있었던 것처럼 걍 멤버명만 써서 쓰면 안되고 , 그 외부에 존재했던 것처럼 클래스명을 밝히고 써야된다.

				: 만약에 여러 패키지의 클래스를 불러온 상태서 이름이 겹치는 클래스를 사용해야되는 상황이면 사용할때 풀네임으로 써야한다
					: 일부 클래스명이 겹친다고 그 패키지 내부의 모든 클래스를 풀네임으로 불러야된다는게 아니라 겹치는 클래스명만 풀네임으로 부르면 된다는거다



접근제한자 Access Modifier
	: 접근을 제한하기 위하여 사용
	: 접근 제한자 종류 
		: public >  protected > default ( 얘는 우리가 붙이는게 아니긴 함) > private
		: 클래스 , 멤버 의 제한자로 모두 쓸 수 있다는게 아니고 대상이 누구냐 따라 쓸 수 있는/없는 생성자가 있음
		: default 는 대상이 누구냐에 따라 붙여지는 경우가 다름
			: 클래스 , 필드 , 메서드의 경우 암것도 안썼을때 컴파일러에 의해 default 붙여지는데, 생성자의 경우 단순히 암것도 안썼다고 default 붙여지는게 아니고 자신이 속한 클래스를 따라감( public 혹은 default )(그도 그럴것이 생성자명이 클래스명이니까)

	: 클래스 접근 제한자 
		: 종류
			1. public : 외부 패키지에서까지 사용 가능
			2. default :같은 패키지 내에서만 사용 가능
				: 접근 제한자를 지정하지 않았을떄 컴파일러에 의해 자동적으로 붙여짐

		: 왜 클래스의 접근 제한자는 저거 밖에 없을까(protected , private 는 왜 안될까)
			: 일단 private이 가능해지면 클래스를 열심히 만들어도 그 클래스 외부에선 사용을 못해 쓰레기가 되서 그런듯.
		
	: 생성자 접근 제한자
		: 오버로딩할때 생성자 별로 같은 접근제한자 사용할 필요 없음. 원한다면 각각 다른 접근 제한자 써도 됨
		: 종류
			1. public : 외부 패키지에서도 쓸 수 있게 함
			2. protected : "같은 패키지 내부"에서만 혹은 "다른 패키지의 자식 클래스 내부"에서만 쓸 수 있게 함 
			3. default : 같은 패키지 내부에서만 쓸 수 있게 함
				: 주의해야할게 생성자의 경우 아무 접근 제한자를 안쓰면 무조건 default 가 붙여지는게 아니라 자신이 속한 클래스의 접근 제한자가 붙여짐
			4. private : 해당 클래스 내부에서만 쓸 수 있게 함


	: 필드와 메서드의 접근 제한
			1. public : 외부 패키지에서도 쓸 수 있게 함
			2. protected : "같은 패키지 내부"에서만 혹은 "다른 패키지의 자식 클래스 내부"에서만 쓸 수 있게 함 
			3. default : 같은 패키지 내부에서만 쓸 수 있게 함
				: 접근 제한자를 안쓰면 컴파일러가 자동으로 붙여짐
			4. private : 해당 클래스 내부에서만 쓸 수 있게 함
