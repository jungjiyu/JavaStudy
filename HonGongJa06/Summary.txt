
객체지향프로그래밍
	: 단계
		1. 클래스 설계
		2. 클래스로 인스턴스 생성
		3. 인스턴스 활용


객체 0bject 혹은 instance
	: instance 는 특정 클래스로 만들어진 객체를 의미
		: 그러니까 객체가 더 큰 범주인것
	: 부품 
	: 객체지향프로그래밍
		: 객체를 사용하는 프로그래밍
	
	: 객체 간의 관계
		1. 집합  관계:  부품과 완성품의 관계
			ex) 타이어(=부품)와 완성품(=자동차)

		2. 상속 관계: 부모객체(=상위 객체)와 자식객체(=하위객체)의 관계
			: 부모객체 ) 종류. 자식객체의 큰 범주
			: 자식 객체 ) 구체적인 사물 같은 것
			ex) 기계(=상위객체)와 자동차(=하위객체)

		3. 사용 관계: 객체간의 상호작용
			: 집합도 , 상속도 아닌 관계
			ex) 사람과 자동차
	: 객체는 힙 영역에 저장

클래스 Class
	: 객체 instance를 만드는 설계도 역할
		: 인스턴스화 ) 클래스로부터 인스턴스(들)을 만드는 것 
	: main() 메서드가 
		있다 >>  걍 쓴다 (? 어캐??)
		없다 >> 객체를 만들고 써야된다

	: 클래스의 종류
		1. 라이브러리 ( API ) 클래스
			: 다른 클래스에서 이용할 목적으로 만들어지는 클래스
			: 한 프로그램에 여러개 존재 가능

		2. 실행 클래스
			: 코드를 실행시키는 클래스 .
			: 전체프로그램 중에 단 1개 존재

		3. 라이브러리인 동시에 실행클래스 
			: 귀찮아서 라이브러리 클래스 내부에 실행 클래스 만들어둔것
			: 비추 >> 대부분 1.과 2. 로 분리해서 만든다


	: 클래스 선언
		선언 위치 종류
			: 다른 소스파일로 세분해 놨냐 여부와 상관 없이(종류1이든 종류2든) 바이크 코드 파일(.class)는 선언된 클래스의 개수만큼 생성됨
			1. 클래스명.java로 새로운 소스파일에 생성
				: 종류1을 추천	
					: public 접근 제한자) 소스파일명과 동일한 이름의 클래스 선언에만 사용 가능
			2. 기존 작업 중이던 소스파일에 생성	
			
	: 객체 생성
		형식: 클래스명 참조변수명 =  new 생성자;
			: 생성자 == 클래스명( )	
			new 연산자 : 클래스로부터 객체를 생성시키고 생성된 객체의 주소를 반환하는 연산자
				: 반환된 주소를 해당 클래스의 참조타입변수에 할당하여 객체를 사용함
					: 클래스는 메소드영역에 존재해있었던거고 이걸로 힙 영역에 새롭게 객체를 생성시킨거고
					  참조변수는 새롭게 스택영역에  생성되며 앞서 생성됬던 객체의 주소를 받는거임
						: 참조변수명으로 힙에 객체가 생성되는게아니고 걍 해당 클래스의 객체로서 객체가 생성되는거다(= 객체를 부를때 해당클래스의 instance라고 하지 참조변수를 객체라고 하진 않는다) 

			

	: 객체 , 클래스의 구성 멤버
		: 선언된 클래스 내부에서 필드, 메서드를 사용할땐 그냥 필드명, 메서드명으로 활용하면 되지만 선언된 클래스 외부에서 활용할 때는 객체를 생성한 후에 , 그 객체를 밝혀 사용해야됨
			: 선언된 클래스 외부에서 그 필드, 메서드가 존재하지 않으니까 함부로 못쓰고 객체 생성해서 그 필드, 메서드도 존재하게 해야 쓸 수 있음
			: 형식)
				클래스명 참조변수명 = new 생성자 ; // 객체 생성
				...... 참조변수명.필드... // 필드 활용 
				..... 리턴값 = 참조변수명.메서드명(arg1, arg2.. ); ... // 메서드 활용
				
				: 참조변수명.필드 혹은 메서드
					: 도트 연산자 == . == 객체접근연산자
 			: 선언된 클래스 내부에서 필드, 메서드를 사용할 때도 객체를 밝혀 사용할 수 있음
				: 형식)
					this.필드혹은메서드
						: 객체를 this로 하는것.
				: this 라는 객체는 자기자신이라 별도로 객체를 생성하는과정은 필요 없음
				: 쓰는경우
					:주로 생성자나 메서드 내부에서 (가독성 높이기 위해) 변수를 필드명과 같은 이름으로 선언할때 필드와 변수를 구분하기 위해

				: ex)
					String name ;
					int age;
	
					Student(String name , int age){
						this.name = name;
						this.age = age;
						}

		: 오버로딩 vs 오버라이딩
			 오버로딩 : (하나에) 많이 싣는다
				1. 생성자 오버로딩: 생성자 여러개 만드는것 ( 생성자들의 이름은 당연히 하나다)
				2. 메소드 오버로딩: 하나의 메서드명으로 여러개의 메서드 만드는것

			오버라이딩 :


		1. 필드 Field (==속성)
			: "생성자 블럭"과 "메서드 블럭" 영역을 제외한 클래스 내부 영역에서 선언된 변수 역할하는 것.
				: 변수 vs 필드
					: 값을 저장하는 역할은 똑같은데 선언 위치가 다르다(그래서 생성과 소멸 시점도 다르다)
						: 생성자 블럭과 메서드 블럭에 선언된 변수는 로컬변수로 , 블럭이 끝나면 없어지고, 이를 필드라고 하진 않고, 변수라고 한다
			: 객체와 함께 생겨나고 소멸됨
			: 초기화 시켜놔도 되고 안시켜놔도됨(단순 선언만 해나도 됨)
				: 초기화 시키지 않을 시 0 비스무리한 값으로 자동 초기화
					:0 , 0.0, '\u0000', false 같은
			: 관례적으로 첫글자 대문자 안한다(띄어쓰기 구분을 위한 뒷 부분은 대문자한다)

	
		2. 생성자 Constructor
			: 객체 생성과 초기화 역할 담당

			: new 연산자로 호출됨

			: 메소드랑은 다른거임
				1. 리턴타입이 없음
					: 선언할때 이름앞에 void 조차도 명시 안한단 소리임 
				2. 이름이 자신이 소속된 클래스명임

			: 한 클래스에 반드시 컴파일러에 의해서든 직접 명시하든 하나 "이상" (여러개의 생성자 존재가능)의 생성자 필요		

			: 명시적인  생성자 선언
				:형태) 
					public 클래스명( param1 , param2 ... ){  어쩌구 저쩌구  }
						: public 써도 되고 안써도 됨
						: param 선언은 생성자 블럭 내부에서 필요하면 쓰는거고 불필요하면 안써도 됨

			: 명시적이지 않은 생성자 선언
				: 소스파일의 클래스 내부에 명시적으로 선언한 생성자가 하나도 없을시 컴파일러가 new 연산자 만나 객체 만들때 바이트 코드 파일에 기본 생성자를 자동으로 선언함( public 클래스명( ){     }; 꼴로 . 블럭 부분 비어있는거임. )
					:기본생성자: 
						: 형태: public 클래스명( )
						: 클래스가 public 으로 선언되있음 public 붙이고 public 없었음 public 안붙임

					: 그러니까 딱히 객체 생성시 초기화 과정이 필요없음 코드에서 생성자를 생략해도 됨
					: 명시적으로 선언한 생성자가 하나라도 있을시 기본생성자는 생성되지 않음 
			
			: 생성자 오버로딩
				: 매개변수 구성( 타입 , 개수 , 순서)이 다른 생성자를 여러개 선언하는 것
					: 구성이 다른 ex) 
						ClassEx( String name, int Age , int Score );
						ClassEx( String name, int Age );
						ClassEx( int Age ,  String name );
						ClassEx( String name );

					:  단순히 매개변수 이름만 다르게 선언하는건 오버로딩이 아니다
						: 구성이 같은 ex) 
							ClassEx( String name, int Age , int Score);
							ClassEx( String names , int Ages , int Scores);
				: 생성자가 오버로딩 되있으면 new 연산자로 생성자를 생성할때 제공된 arg 의 구성에 따라 자동으로 해당 매개변수 구성의 생성자를 매치시켜줌
				: 까먹지 말아야할것은 명시적인 생성자를 한 경우 기본생성자는 자동 생성되지 않기 때문에 만약에 기본생성자도 택할 수 있게 하려면 직접 기본생성자를 명시해야됨
				: 생성자의 중복 코드 제거하는 법( 다른 생성자를 호출하는 법)  : this( arg1 , arg2, ... ) 사용 
					: 이게 왜 필요 ) 매개변수 구성만 다르고 블럭 내용이 거의 또이또이한 상황에서 공통적으로 해당하는 부분을 각 생성자 블럭에 일일이 쓰기 귀찮으니까 겹치는 부분은 따로 정리하고 그걸로 짧게 대체하는 것
					: this( arg1 , arg2, ... )
						: 자신이 속한 클래스의 다른 생성자를 호출하는 코드
						: 오직 "생성자"의 "첫줄" 부분에서만 사용 가능
						: 생성자의 형태인 "클래스명( )"에서 클래스명이 this 로 대체된 것.
						: 선언한 생성자의 형태에 맞춰서 쓰기만 하면 알아서 잘 찾아간다
							ex)
							public class Student {
	
								String name;
								int age;
	
								Student(){ } // 기본생성자
	
								Student(String  name){ // 생성자1
									this(name , 70); // 똑같은 코드 귀찮게 또 쓰지 않기 위해 첫줄에 this( ) 사용
									System.out.println("1번째 Student 생성자애 들어왔습나다");

								}
								
								Student(int age){ // 생성자2
									this("Trump",age);
									System.out.println("2번째 Student 생성자애 들어왔습나다");

								}
		
	
								Student(String name , int age){ // 생성자3
									this(age,name);
									System.out.println("3번째 Student 생성자애 들어왔습나다");
								}
	
								Student( int age, String name){ // 생성자4
									this.name = name; // 필드명과 겹치는 param명을 사용하기 위해 this 객체( 클래스 자기자신)를 사용
									this.age = age;
									System.out.println("4번째 Student 생성자애 들어왔습나다");

								}
	

								void PrintInfo() {
									System.out.println("이름: "+name);
									System.out.println("나이: "+age);
								}

							}

				
		3. 메소드 Method
			: 클래스 내부에서 선언된 함수
			: 객체와 객체들 간의 상호작용은 메소드를 통해 이루어짐
			: 메소드 선언 == 메소드 시그니처 + 메소드 실행 블럭
				: 메소드 시그니처 (=메소드 선언부)	
					: 형식)
						리턴타입 메서드명( param1, param2 ..선언 )
							: 리턴값이 없는 경우 리턴타입은 void 로 설정
								: 리턴타입이 void 여도 강제 종료의 목적으로 return 문 사용 가능) return ; 함 됨 (리턴 바로 뒤에 세미콜론 갈기기)

					: arg의 자동타입변환을 허용함( 그러니까 param을 넉넉한 걸로 잡는게 좋다. 그래야 꼭 똑같은 타입이 아니더라도 arg를 받을 수 있을거니까)
			
					: 다양한 갯수의 arg 를 한 메서드로 받을 수 있게 하는 법
						: 메소드 오버로딩 아님 주의 (메소드 오버로딩은 똑같은 메서드 명으로 여러개 선언하는 것)
						sol1 )  매개변수를 배열 타입으로 선언하기 : 비추
								: 단점 ) 무조건 객체를 생성하고 넘겨야됨(씁 근데 이게 글케 귀찮은가)
									: arg 로 넘길 객체 생성 case
										방법1) 괄호 밖 부분에서 객체 와 참조변수 생성하고 참조변수를 arg 로 함
										방법2) 괄호 안에서 객체만 생성하기	
											: 주의해야할 것이 변수 선언과 동시에 일어나는게 아니기 때문에 쌩 {val1 , val2 ...} 처럼 중괄호는 안되고 new. .. 아니 그럼 안에서 변수 선언을 하면? 안되는 거임?
										: 참고로 괄호 안에서 객체와 참조변수를 생성할 순 없음(arg 받아야할 부분에서 변수 선언만 했지 넘길 대상을 쓰지 않았잖아)
 	

									ex)
									클래스 부분에서   mthd( int[ ] ary ); 로 메서드가 선언되있다 치고
									실행파일에서 객체가 poop 로 생성되있다 칠때
										// 방법1: arg 밖 부분에서 객체 만든것을 넘기기
											int [ ] ary = {1,2,3,4}; 
											poop.mthd(ary); 
										// 방법2:  arg 안에서 객체 생성하기	
											poop.mthd( new int[ ]{1,2,3,4} );
										// poop.mthd(int [ ]hehehe = {4,5,6,7}); 은 불가
		
				
					 	sol2 ) 매개변수를 ... 를 이용하여 선언하기 : 추천
								: 장점 ) 객체 생성없이 콤마로 구분지은 값 목록만 넘겨줘도 되고 걍 객체를 넘겨줘도 됨
								: 작동 방식 ) 콤마로 구분지은 값을 받으면 자동으로 메서드의 param 부분에서 배열을 생성함. (물론 걍 객체를 넘겨받은 경우라면 걍 그 객체를 활용함)

				: 실행 블럭 : {  어쩌구 저쩌구 }
					: 존나 신기한게 자바에서는 메서드 내에서도 arg 로 받은 array의 사이즈를 length 를 이용하여 측정할 수 있다 

					: 참고로 자바에서는 존나 정확하게 실행블럭의 마지막 return 문 다음에도 실행할 코드가 존재하면 에러 내버린다( return 문 사이의 문장은 괜찮다)
						ex) 
						int mthd( ){
						System.out.println(" 쏼라쏼라");
						return 2;  
						System.out.println("쌀국수"); //가능: 마지막 리턴문의 앞에 위치해서
						return 3; // 마지막 리턴문					
						System.out.println("포베이"); // 불가: 마지막 리턴문의 뒤에 위치해서
						}

			: 메소드 오버로딩
				: 클래스 내에 param종류가 다른 같은 이름의 메소드를 여러개 선언하는 것
					: 주의해야할게 반환형은 메소드 오버로딩에 전혀 관여 안함
						: 메소드 오버로딩의 기준도 아니고(반환형이 같든 다르든 param 종류에 따라서만 오버로딩 가능 여부 정해짐) 오버로딩 시킬때 메소드끼리 타입이 같을 필요없음
					: param이 다르다의 기준은 생성자오버로딩에서와 같음( 단순히 매개변수명만 다름 안되고 매개변수의 순서,타입,개수 중 적어도 하나가 달라야됨)

				: 헷갈리지 말아야할 점은 생성자 오버로딩에서처럼 this( )를 사용할 수 없음
					: this 는 클래스, 객체 자기자신을 나타내는건데 생성자처럼 형태가 "클래스명( )" 인게 아니라 걍 "쏼라쏼라( )"꼴이니까

				: 오버로딩 상황에서 메소드 pick 우선순위
					1st 자동형변환 고려 안해도  param 타입 == arg 타입 인거
					2nd 자동형변환 고려했을때 param 타입 ==  arg 타입인거
						ex)
							클래스에서
							mthd(int a, int b) , mthd(double a, double b) 가 선언되있을떄
							
							활용 파일에서
							객체.mthd(10.2 , 3); 하면 두번째 메서드( mthd(double a, double b) )가 사용됨. 일단 완전 타입 일치하는건 없는데  자동형변환 고려했을때는 가능한거니까
							
				
