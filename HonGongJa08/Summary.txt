인터페이스 : 객체의 사용방법을 정의한 타입
	: 다양한 객체를 동일하 사용방법으로 이용할 수 있다
	: 개발 코드와 객체의 중간다리 역할을 한다. 
		: 개발코드가 인터페이스의 메서드 호출 >> 인터페이스가 객체의 메서드 호출 >> 객체의 메서드 실행
		: 객체의 메서드 리턴값을 인터페이스에 전달 >> 인터페이스가 개발코드에 리턴값 전달 >> 개발 코드가 리턴값 전달받음
	
	: 물리적 형태는 클래스와 동일하다
		: 소스파일 자체는 .java 이고 컴파일 시 .class 로 컴파일 된다

	: 선언방법)
		public interface 인터페이스명{ 어쩌구저쩌구 .. }
			: 통상적으로 인터페이스의 첫 글자는 대문자이다
 			: class 키워드 없고, interface 키워드가 있다
			: 상수필드와 추상메서드 만을 멤버로 가질 수 있다.'	
				: 생성자를 멤버로 가지지 못하기 때문에 찐으로 인터페이스의 객체 생성은 일어나지 않는다(구현 클래스의 객체가 생성될때도)
				: 필드  선언
					: 인스턴스필드, 정적필드는 선언 불가하고 상수 필드만 선언 가능한거다
						: 왜 상수필드만 선언이 가능할까? >> 인터페이스는 데이터를 저장할 수 없기 때문이다.. 라고 한다
					: 형식	
						public static final 타입 필드명 = 초기화값 ;
							: 상수이므로 선언과 동시에 초기화해야된다(생성자를 가질 수 없기에 반드시 선언과 동시에임)
							: public static final 은 생략해도 되고 ( 타입 필드명 = 초기화값; 만 해도 됨), 생략시 컴파일러가 자동으로 붙이고 컴파일한다.

				: 추상 메서드 선언
					: 왜 메서드는 추상 메서드만 선언 가능하게 한걸까
						: 인터페이스의 메서드를 호출했을때 인터페이스 내의 메서드가 실행 되는게 아니라 객체의  메서드를 실행시키는 것이기 때문
					: 형식)
						pubic abstract 리턴타입 메서드명(매개변수 , ... );
							: 인터페이스 내부의 모든 메서드는 다 추상 메서드라 굳이 풀로 다 안쓰고 " 리턴타입 메서드명(매개변수 , ...); " 만 써도 알아서 컴파일 할때 public abstract 붙인다
		
					: 인터페이스 내의 메서드는 추상메서드 , 객체의 메서드는 실체메서드 라고 한다
		: 인터페이스 객체 생성은 불가해도 인터페이스 타입의 필드를 만들 수 있다(물론 로컬변수로도 가능)  
			: 인터페이스 타입의 참조변수로 가리키는 객체에서 해당 인터페이스에 선언된 필드.메서드만 사용이 가능하다(다중인터페이스 상속받은 클래스로 생성된 객체라 할때 특정인터페이스 변수로 다른 인터페이스에 의해 정의된 메서드 사용 불가)
			: 뭔가 아닌것같지만 의외로 맞는 것은 클래스의 생성자의 param 으로 문자열을 받을 수 있는것처럼, 클래스의 생성자의 param을 인터페이스 변수로 선언하고 arg 로 인터페이스의 구현 객체를 받을 수 있다.
					ex)
						public interface Animal {
							public abstract void sound();
						}

						public class Cat implements Animal{
							Cat(Animal animal){
								System.out.println("고양이가 꼬리를 밟았습니다.");
								animal.sound();
							}

							@Overriding
							public void sound(){
								System.out.println("mewooo");
							}
						}

						일때 실행 클래스에서 Animal animal = new Cat(new Dog()); 가능 (물론 Dog클래스가 Aniaml 인터페이스의 구현 객체일때)

		: 자동형변환) 해당 인터페이스 타입의 참조 변수는 해당 인터페이스로 생성된 모든 객체를 가리킬 수 있고, 객체가 변수에 할당되는 과정에서 해당 인터페이스 타입으로 자동형변환된다
		: 강제형변환) 자동형변환시킨 대상의 정보는 유지하면서 객체의 원래타입으로 복구하는것(객체의 생성자 타입)
			: 물론 해당 구현클래스 타입의 참조변수로 받아야된다.
			: 인터페이스에 정의되있지 않은 객체내의 멤버를 활용하기 위해 한다
			: 일반적인 클래스에서의 강제형변환에서처럼 instanceof 연산자를 통해 점검 후에 강제형변환시키는게 안전하다
			


	: 구현 클래스
		: 인터페이스 내부에 선언된 추상메서드의 실체 메서드가 선언된 클래스
			: 인터페이스의 상수 필드는 강제적 오버라이딩 대상이 아니라 걍 쓰고 싶음 쓰고 안쓰고 싶음 안쓰는거. 
		: 구현 객체를 생성하는 클래스
			
		: 선언 형식)
			public class 클래스명 implements 인터페이스명{  어쩌구 저쩌구... }
				: 일반적인 클래스 선언과 같은데 implements 키워드가 추가된 꼴
					: extends 가 아니라 implements 임을 주의	

		: 상속 받는거랑 다른 것이지만 느낌이 비슷하다
			: implements 키워드 앞의 클래스는 자식 클래스 느낌이고 , 그 뒤의 인터페이스는 부모 클래스 느낌이다
				: 구현 클래스는 인터페이스 내부의 필드와 메서드를 사용가능하고 , 인터페이스 타입의 변수는 구현클래스로 생성된 객체들을 모두 가리킬 수 있다

		: 주의해야 할 것이 인터페이스 내의 필드는 모두 정적 필드(그중에서도 static final)이므로 구현 클래스에 같은 필드명으로 새로운 필드를 선언했다고 필드 하이딩이 구현되는게 아니다.(필드 하이딩은 static 변수를 대상으로 일어나는게 아니라 인스턴스 변수를 대상으로 일어나는거다) 그래서 만약 필드명 겹치는 상황서 인터페이스의 필드를 쓰고 싶다면 " super.필드명 "을 쓰는게 아니라 정적필드를 사용하듯이 " 인터페이스명.필드명" 으로 접근함 된다.
			: super, this 는 부모와 자신의 인스턴스를 가리킬때 쓰는거다(즉, 인스턴스 멤버에 한해 사용 가능)
				: 그리고 생각해보면 인터페이스는 객체 생성이 안되기 때문에 애초에 사용을 하지 못함

		: 다중 인터페이스 구현 클래스도 선언이 가능하다
			: implements 뒤에 여러 인터페이스를 쓸 수 있단 말이다
				: 모든 인터페이스의 메서드를 오버라이딩 해야한다

			

	: 구현 객체
		: 구현 클래스로 생성된 객체	
		: 구현 객체 생성 및 참조 변수 선언 형식)	
			인터페이스타입 참조변수명 = new 구현클래스의생성자 ;
				: 클래스의 생성자와 new 키워드로 생성하는 것 까진 일반적인 클래스와 동일한데 참조변수의 타입이 구현클래스 타입이 아니라 인터페이스 타입임을 주의 
					: 주의해야 할 것은 다양한 인터페이스가 implements 된 구현 클래스의 경우(다중 상속)  다양한 인터페이스 타입의 참조 변수가 해당 구현 객체를 가리킬 수 있는데, "인터페이스A"로 선언된 참조변수로 인터페이스B에 의해 정의된 메서드를 사용할 순 없다. 그 메서드를 이용하려면 인터페이스B타입의 참조변수로 객체를 가리키게 하고서 사용해야된다.
					: 또 주의해야 할 것은 new 뒤에 인터페이스 생성자가 오는게 아니다(인터페이스는 생성자가 있지도 않아 객체 생성이 불가) 
		: 인터페이스 타입의 참조변수는 해당 인터페이스의 구현클래스로 생성된 객체이기만 하면 다 가리킬 수 있다

	: 인터페이스 상속
		: 인터페이스 끼리는 상속이 가능한데, 심지어 다중상속도 가능하다
		: extends 키워드를 사용한다
		: 하위 인터페이스는 상위인터페이스들의 모든 추상 메서드를 가지고 있는 것으로 간주되고, 이 하위 메서드를 구현한 클래스는 하위 인터페이스의 모든 추상 메서드의 실체 메서드를 가지고 있어야한다.
			: 하위 인터페이스가 상위 인터페이스의  추상메서드의 실체 메서드를 가져야한다는게 아니다(인터페이스 내부에서는 추상 메서드만 선언 가능)
		: ex)

		interface A{
		public abstract void sayA();	
		}

		interface B{
		public abstract void sayB();	
		}

		interface C extends A, B{
		// public abstract void sayA() , sayB() 모두 있는걸로 간주
		public abstract void sayC();	
		}

		public class Run implements C{
			public static void main(String[] args){
		
			@Overriding
			public void sayA( ){
			. . .
			}

			@Overriding
			public void sayB( ){
			. . .
			}

			@Overriding
			public void sayC( ){
			. . .
			}

		}
		}

		

	: 인터페이스, 추상클래스 모두  다형성을 구현할 수 있다
		: 다형성을 구현하기 위해선 오버라이딩, 자동형변환이 일어나야되는데 둘다 일어나니까
		: 인터페이스 , 추상클래스가 부모클래스고 구현클래스, 실체 클래스가 자식 클래스 역할이고 
		인터페이스,추상클래스타입으로 참조변수 선언하고 구현클래스,실체클래스의 객체를 생성하면 
		자동형변환 일어나는 것처럼 해당 참조변수들은 선언된 타입 내의 필드, 메서드에 한정해 사용이 가능하지만
		자신(인터페이스, 추상클래스)으로부터 만들어진 클래스들로부터 생성된 객체이기만하면 가리킬 수 있어
		하나의 참조변수로 어느 객체를 가리키느냐 따라서 다양한 기능을 수행ㅇ 가능

		: 근데 인터페이스는 확실히 다형성인게 자동형변환개념 뿐 아니라 강제형변환개념까지 존재한다

	 


