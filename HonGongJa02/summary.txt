RAM 메모리 : 값을 저장할 수 있는 주소들로 구성

두 변수 간 값 교환시에는 tmp 변수 써야됨


리터럴(상수)
	1. 문자리터럴
		: ' ' 꼴 값. 2바이트 짜리 유니코드로 변환되어 저장됨.
	2. 정수 리터럴	
	3. 실수 리터럴
	: 정수 리터럴은 기본 int 형, 실수 리터럴은 기본 double 형.
		: 만일 int 형 넘어가는 상수( long 형 범위의 값)를 할당하고 싶음 각 리터럴의 끝에 L 붙여야 에러 안남 

변수:  값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름
	: 선언한다고 변수가 생성되는게 아니고 변수 초기화 시점에서 값이 생성됨
	: 변수 선언 ) 자료형과 변수명을 명시
		: 기호로 _ 뿐 아니라 $ 까지 사용 가능
	: 변수 초기화 ) 변수에 처음으로 값 저장하는 것
		: 꼭 선언과 동시에 대입연산자를 쓴게 아니라 선언 이후 줄에서 = 써서 처음 저장한 것도 해당
	
	: 범위 ) 
		1. 로컬 변수: 블럭 내부 선언 변수
			: 해당 블럭 내부서만 사용가능, 해당 블럭 끝나면 소멸 	

타입
	1. 정수
		1) byte : 1바이트
		2) char : 2바이트 << 아스키코드 아닌 유니코드 저장
			: 양수값 only 저장 가능 (음수 값 할당 불가)
			: 유니코드값(정수값) 그대로를 할당하거나, 문자리터럴을 할당하거나, 이스케이프 시퀀스를 사용하여 문자인데 16진수로써(?) 할당 가능('\uXXXX' 로 뒤에 4자리) 
		3) short : 2바이트 
		4) int : 4바이트
		5) long : 8바이트
	2. 실수
		1) float: 4바이트
		2) double: 8바이트
			: float 에 비해 2배 정도 (소수점 뒷부분을 ) 정밀하게 표현 가능해서 double 형 인거임
	3. 논리값 
		1) boolean : 1바이트
			: true , false 값을 가짐(죄다 소문자)


:이클립스 특인지 모르겠으나 오버플로우 일어나면 에러 발생시키고 L이나 f 안붙임 에러남

자주 쓰는 클래스타입(앞문자 대문자 주의)
	1) String : 문자열 저장

타입변환(=형변환)
	: 캐스팅은 명시적 형변환일때나 사용할 수 있는 용어
	1) 암묵적형변환 : 데이터 손실에 민감하다 생각함 편함 (데이터 잘라먹는데 민감)
		1. 대입 연산 시 발생(범위 작은 타입값이 큰 타입의 변수에 저장될 때) (작은 타입에 큰 타입을 할당할땐 안됨. 데이터 손실 발생하니까)
			: 같은 카테고리의 변수 뿐 아니라 다른 카테고리의 변수에도 적용됨
				: 실수형 변수에는 별도의 명시 없이 바로 정수형 변수나 상수 값 할당 가능함
			: 예외) only 양수값만 가능한 char 변수에는 아무리 작은 타입의 변수라 해도 할당 불가 (걔네는 음수까지 가능하니까)
		2. int 형이하 피연산자 간의 연산시 int 형으로 자동형변환(연산결과는 무조건 int) 
			: 정수형끼리의 연산이여도 long 형 있음 적용 안되는 거임 (연산결과는 long 형)
		3. 이외의 크기 다른 변수끼리의 연산 시 큰 타입으로 자동형변환
			: float 끼리의 연산이면 적용 안되는 거임(연산 결과는 double 형 아닌 long 형)
		4. + 연산자의 피연산자중 하나라도 문자열 타입 있음 나머지 연산자는 문자열 타입으로 자동형변환
			: 피연산자가 변수명이면 변수의 값이 자동형변환 되고 상수이면 상수 그자체로 자동형변환
				ex) 
				int a ,b;
				a= b= 10;
				System.out.println(a+"zzzz"+b); // "10zzzz10"
				System.out.println(10+"zzz"); // "10zzz"
			
			
			: 주의해야할 것은 문자열 아닌 타입끼리의 + 연산까지 문자열로 형변환 된다 생각함 안됨.
				ex)
				int a ,b;
				a= b= 10;
				System.out.println(a+b+"zzzz"); // "20zzzz"이지, "1010zzzz"가 아니다

			: 참고로 + 연산의 경우 앞에서부터 계산되니까 문자열과 묶인 문자열 타입이 아닌 피연산자가 여러개인 경우 '앞'에서부터 차례대로 형변환됨
				ex) 
				int a ,b;
				a= b= 10;
				System.out.println(a+"zzzz"+b); 
				에서 "10"+"zzzz"+b >> "10zzzz"+b >> "10zzzz" + "10" >>"10zzzz10"
			
 
	2) 명시적형변환(=캐스팅): 
		1. 대입 연산 시(범위 작은 타입 변수에 큰 타입 변수 집어넣을때 혹은 오버 플로우 일어나는 상수 값 할당할때)
			: 정수형 변수에 실수형 변수 할당할땐 항상 명시적 형변환 필요
		2. 문자열을 다른 타입으로 형변환
			: 앞글자대문자자료형.parse앞글자대문자자료형(값) 활용
				: 주의해야할 것은 예외적으로 int 형으로 형변환하는 경우 Int.parseInt("29"); 가 아닌 Integer.parase.Int("29");이다
					: 왜냐면 int 타입명만 줄임말이기 때문 (char 형도 줄임명이긴 하지만 문자열을 문자로 형변환 하진 않으니)
				: parse 는 구문을 의미. 
 		3. 다른 타입을 문자열로 형변환
			: String.valueOf(값) 활용
연산자
	1. 대입연산자 = 
	2. 기본연산자 + - * / %
	3. 문자열 연산자 +
		: 피연산자중 하나라도 문자열 타입이면 나머지 피연산자가 문자열로 자동 형변환 되면서 결과는 문자열
			: 숫자 + "쏼라쏼라" == "숫자쏼라쏼라" , 변수 + "쏼라쏼라" == "변수값쏼라쏼라" 

		: 앞에서부터 차례대로 계산됨
			: 뒷부분 계산 우선 적용 원하면 괄호 사용
				ex)
				int a =10, b =20;
				System.out.println("result:"+(a+b)); // 괄호 없음 "result10"+20 되서 "result1020"됨.


자바 프로그램 문장 구성 ) 대상.입출력장치.메서드 ;
	:해석) '대상'의 '입출력장치'에 '메서드'적용
	:

표준 입출력 장치
	in : 표준 입력 장치
	out : 표준 출력 장치


메서드: 어떤 일을 처리하는 실행문들을 모아둔 블럭 , 그러니까 함수. 
	: 중괄호 쓰는데 앞에 class 로 선언되지 않은 블럭 부분. (public class 소스파일명은 클래스 블럭이고, public static void main(String[] args)는 메서드)

 출력 메서드 종류
	1.print(문자열)
		: 형식지정자를 사용하지 않는만큼 자료형 곧이곧대로 활용함
			ex) 
			int a = 65;
			chat c= 65;
			System.out.println("a: "a + "c:"+c); // a: 65 c: A
			System.out.println(a+c); // 65A 가 아닌 130. (그러니까 65+65의 결과)
	2. println(문자열)
		: print 에 '\n'자동 추가되는 것. (ln == line으로 자동 줄바꿈 기능)

	3. printf(형식지정자사용한문자열, 변수1, 변수2....)
		:형식지정자 부분 구성:  [%] [몇번째변수$][정렬방향설정혹은0으로채움][몇자범위][.소수자릿수][변환문자]
			: %와 변환문자 부분은 필수이고 나머지는 옵션임
			: % ) 형식 지정자의 시작을 나타냄
			: 몇번째변수$ ) 1부터 시작하고, 형식지정자사용한문자열 이후의 변수1, 변수2 .. 의 여러 변수중 몇번째 변수를 사용할 건지 택
				: 잘 안씀
			: 정렬방향설정 혹은 채움글자를0으로) 
				: - 쓰면 범위 내에서 해당 변수가 왼쪽으로 붙어 출력됨
					: 문자열에도 사용 가능
				: 0 쓰면 남는 공간이 0으로 채워져 출력됨.
					: 숫자 타입에만 적용가능(문자열에 사용 불가)
				: 왠진 몰라도 -0 , 0- 으로 둘다 동시엔 못씀
			: 몇자범위)  변수 넣을  공간의 크기를 정하는것(만약에 변수가 몇자 범위 넘게 차지함 걍 그 범위는 무시됨)
			: .소수자릿수) 소수몇번째자리까지 표시할지 택
			: 변환문자 ) d , f , c , s , lf 같은거
		: 만약에 printf 내에서 실제로 %를 문자로써 사용 원하면 %%로 씀됨
	


