RAM 메모리 : 값을 저장할 수 있는 주소들로 구성

두 변수 간 값 교환시에는 tmp 변수 써야됨


리터럴(상수)
	1. 정수 리터럴	
		: 일반적인 정수 숫자 뿐 아니라 문자 리터럴도 정수 리터럴임.
			: 문자리터럴도 결국 int 타입이긴 하지만 되도록 char 형 변수에 할당하는 걸 추천
				:형식지정자가 없는 print 나 println 의 경우 타입따라 값 출력하기 때문(int타입변수면 유니코드 그자체 출력, char 타입변수면 문자로 출력)
		: 기본 int 형
			: 특별히 long 타입에 정수 리터럴 할당하고 싶음 L 붙여야됨
			: int 형 범위 넘는 정수는 반드시 L 표기 해야됨 (안그럼 에러)
			: long 형 변수에 할당할거 아님 편하게 정수 리터럴 할당하면 된다는 거임
				: 하지만 정수 리터럴이 아닌 변수를 할당하는 경운 적용이 안됨(int 형 변수를 int 형 미만 변수에 그냥은 할당 못함)
					:ex)
					char a = 69 ; //가능: int 형 리터럴을 char 형 변수에 할당 가능

					int ii = 69; 
					char b = i ; //불가: int 형 변수를 그냥은 char 형 변수에 할당 불가
					char b = (char)i ; //가능:형변환 사용
	2. 실수 리터럴
		: 기본 double 형
			: float 형 변수에 실수 리터럴 할당하고 싶음 F 붙여야됨		
	3. 문자열 리터럴
		: 유니코드 아님
		: String 클래스 타입 변수에 할당하여 사용
	4. 논리 리터럴
		: true 혹은 false (죄다 소문자 이고 1 ,0 으로 대체 불가)

		

변수:  값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름
	: 변수 선언과 생성은 별개임. 변수 선언 이후 초기화 되는 시점에서 생성됨
		: 따라서 변수 절차(?)는 변수 선언 - 변수 생성(초기화) - 변수 활용
	: 변수 선언 ) 자료형과 변수명을 명시
		: 기호로 _ 뿐 아니라 $ 까지 사용 가능
	: 변수 생성, 그러니까 변수 초기화 ) 변수에 처음으로 값 저장하는 것
		: 꼭 선언과 동시에 대입연산자를 쓴게 아니라 선언 이후 줄에서 = 써서 처음 저장한 것도 해당
	
	: 범위 ) 
		1. 로컬 변수: 블럭 내부 선언 변수
			: 해당 블럭 내부서만 사용가능, 해당 블럭 끝나면 소멸 	

타입
	1. 정수
		1) byte : 1바이트
		2) char : 2바이트 << 아스키코드 아닌 유니코드 저장
			: 양수값 only 저장 가능 (음수 값 할당 불가)
				: byte가 char 형보다 작은 타입임에도 그냥은 char 형에 할당 못하고 명시적 형변환 해줘야 간능
			: 유니코드값(정수값) 그대로를 할당하거나, 문자리터럴을 할당하거나, 이스케이프 시퀀스를 사용하여 문자인데 16진수로써(?) 할당 가능('\uXXXX' 로 뒤에 4자리) 
		3) short : 2바이트 
		4) int : 4바이트
		5) long : 8바이트
	2. 실수
		1) float: 4바이트
		2) double: 8바이트
			: float 에 비해 2배 정도 (소수점 뒷부분을 ) 정밀하게 표현 가능해서 double 형 인거임
	3. 논리값 
		1) boolean : 1바이트
			

:이클립스 특인지 모르겠으나 오버플로우 일어나면 에러 발생시키고 L이나 f 안붙임 에러남

자주 쓰는 클래스타입(앞문자 대문자 주의)
	1) String : (문자열) 타입처럼 사용
	2) Scanner : 사용자로부터 문자열 입력받기 위한 도구인 Scanner를 생성 하기 위해 사용
		   : 생성한 Scanner를 이후 코드에 적용할 수 있도록 변수에 담아 사용하기 위해 사용

타입변환(=형변환)
	: 변수 뿐 아니라 리터럴(상수)에도 적용됨
	: 캐스팅은 명시적 형변환일때나 사용할 수 있는 용어
	1) 암묵적형변환 : 데이터 손실에 민감하다 생각함 편함 (데이터 잘라먹는데 민감)
		1. 대입 연산 시 발생(범위 작은 타입값이 큰 타입의 변수에 저장될 때) (작은 타입에 큰 타입을 할당할땐 안됨. 데이터 손실 발생하니까)
			: 같은 카테고리의 변수 뿐 아니라 다른 카테고리의 변수에도 적용됨
				: 실수형 변수에는 별도의 명시 없이 바로 정수형 변수나 상수 값 할당 가능함
			: 예외) only 양수값만 가능한 char 변수에는 아무리 작은 타입의 변수라 해도 할당 불가 (걔네는 음수까지 가능하니까)
		2. int 형이하 피연산자 간의 연산시 int 형 미만의 피연산자는 int 형으로 자동형변환(연산결과는 무조건 int) 
			: 정수형끼리의 연산이여도 long 형 있음 적용 안되는 거임 (int 형 '이하'이니까)
			: ex p.117 )
				char c = 'a' + 1; //  'a' 도 사실 정수리터럴이라 int 형이고 int 형 피연산자 간의 연산이라 딱히 자동형변환 없음 , 그리고 정수 리터럴의 경우 long타입 변수 빼곤 자유롭게 할당 가능하니 별도의 명시적형변환없이 할당가능
				char cc = c + 1 // 불가: int형 미만 피연산자가 있으므로 int형으로 자동형변환되고, 연산 적용한것으로 int 형 변수로 받아야됨
				

			: 결과를 int형변수가 아닌 다른 타입의 변수에 저장 원하면 할당할때 그 타입으로 캐스팅해서 할당함 됨
			
		3. 이외의 크기 다른 변수끼리의 연산 시 큰 타입으로 자동형변환
			:  float 와 double 간의 연산에서 double형 자동형변환되지만 float 끼리의 연산이면 그대로 인거
			: byte 와 long 간의 연산에서 long 형으로 자동형변환 (int 가 아니라)
			: 주의해야할 것은 실수형 리터럴에서 예외 발생 가능
				: f를 붙이냐 안붙이냐따라 소수점 뒷자리수가 달라지는데 0.1 같이 무한 소수인 경우 어디까지 값으로 인정하느냐 따라서 다른 값이 됨
				: 정수형 리터럴에서는 예외 발생 안함(항상 int 형 리터럴과 long 형 리터럴끼리 smooth한 비교 가능)
				: ex  p.120)
					1 = 1L // true
					1 == 1.0 // true
					1.0 == 1.0f // true
					0.1 == 0.1f // false

		4. + 연산자의 피연산자중 하나라도 문자열 타입 있음 나머지 연산자는 문자열 타입으로 자동형변환
			: 피연산자가 변수명이면 변수의 값이 자동형변환 되고 상수이면 상수 그자체로 자동형변환
				ex) 
				int a ,b;
				a= b= 10;
				System.out.println(a+"zzzz"+b); // "10zzzz10"
				System.out.println(10+"zzz"); // "10zzz"
			
			
			: 주의해야할 것은 문자열 아닌 타입끼리의 + 연산까지 문자열로 형변환 된다 생각함 안됨.
				ex)
				int a ,b;
				a= b= 10;
				System.out.println(a+b+"zzzz"); // "20zzzz"이지, "1010zzzz"가 아니다

			: 참고로 + 연산의 경우 앞에서부터 계산되니까 문자열과 묶인 문자열 타입이 아닌 피연산자가 여러개인 경우 '앞'에서부터 차례대로 형변환됨
				ex) 
				int a ,b;
				a= b= 10;
				System.out.println(a+"zzzz"+b); 
				에서 "10"+"zzzz"+b >> "10zzzz"+b >> "10zzzz" + "10" >>"10zzzz10"
			
 
	2) 명시적형변환(=캐스팅): 
		1. 대입 연산 시(범위 작은 타입 변수에 큰 타입 변수 집어넣을때 혹은 오버 플로우 일어나는 상수 값 할당할때)
			: 정수형 변수에 실수형 변수 할당할땐 항상 명시적 형변환 필요
		2. 문자열을 다른 타입으로 형변환
			: Wrapper클래스로써의자료형.parse일반타입(값) 활용
				: 주의해야할 것은 앞부분은 Wrapper 클래스, 뒷부분은 걍 일반 타입이란거
					: int 형으로 형변환하는 경우 Integer.parseInteger("29"); 가 아닌 Integer.paraseInt("29");이다
				: 또 특별하게 주의해야할 것은 char 타입은 parse 어쩌구 메서드로 변환되지 않고 별도의 메서드 문자열객체.charAt(인덱스) 을 사용한다
				: parse 는 구문을 의미. 
 		3. 다른 타입을 문자열로 형변환
			: String.valueOf(값) 활용
연산자
	1. 대입연산자 = 
	2. 기본연산자 + - * / %
	3. 문자열 연산자 +
		: 피연산자중 하나라도 문자열 타입이면 나머지 피연산자가 문자열로 자동 형변환 되면서 결과는 문자열
			: 숫자 + "쏼라쏼라" == "숫자쏼라쏼라" , 변수 + "쏼라쏼라" == "변수값쏼라쏼라" 

		: 앞에서부터 차례대로 계산됨
			: 뒷부분 계산 우선 적용 원하면 괄호 사용
				ex)
				int a =10, b =20;
				System.out.println("result:"+(a+b)); // 괄호 없음 "result10"+20 되서 "result1020"됨.
	
: 문자열끼리 같은지 비교를 위해선 == 안쓰고 equals() 메서드 사용 
	:문자열대상.equals(비교문자열) 

자바 프로그램 문장 구성 ) 대상.입출력장치.메서드 ;
	:해석) '대상'의 '입출력장치'에 '메서드'적용
	

표준 입출력 장치
	in : 표준 입력 장치
	out : 표준 출력 장치


메서드: 어떤 일을 처리하는 실행문들을 모아둔 블럭 , 그러니까 함수. 
	: 중괄호 쓰는데 앞에 class 로 선언되지 않은 블럭 부분. (public class 소스파일명은 클래스 블럭이고, public static void main(String[] args)는 메서드)

 출력 메서드 종류
	1.print(문자열)
		: 형식지정자를 사용하지 않는만큼 자료형 곧이곧대로 활용함
			ex) 
			int a = 65;
			chat c= 65;
			System.out.println("a: "a + "c:"+c); // a: 65 c: A
			System.out.println(a+c); // 65A 가 아닌 130. (그러니까 65+65의 결과)
	2. println(문자열)
		: print 에 '\n'자동 추가되는 것. (ln == line으로 자동 줄바꿈 기능)

	3. printf(형식지정자사용한문자열, 변수1, 변수2....)
		:형식지정자 부분 구성:  [%] [몇번째변수$][정렬방향설정혹은0으로채움][몇자범위][.소수자릿수][변환문자]
			: %와 변환문자 부분은 필수이고 나머지는 옵션임
			: % ) 형식 지정자의 시작을 나타냄
			: 몇번째변수$ ) 1부터 시작하고, 형식지정자사용한문자열 이후의 변수1, 변수2 .. 의 여러 변수중 몇번째 변수를 사용할 건지 택
				: 잘 안씀
			: 정렬방향설정 혹은 채움글자를0으로) 
				: - 쓰면 범위 내에서 해당 변수가 왼쪽으로 붙어 출력됨
					: 문자열에도 사용 가능
				: 0 쓰면 남는 공간이 0으로 채워져 출력됨.
					: 숫자 타입에만 적용가능(문자열에 사용 불가)
				: 왠진 몰라도 -0 , 0- 으로 둘다 동시엔 못씀
			: 몇자범위)  변수 넣을  공간의 크기를 정하는것(만약에 변수가 몇자 범위 넘게 차지함 걍 그 범위는 무시됨)
			: .소수자릿수) 소수몇번째자리까지 표시할지 택
			: 변환문자 ) d , f , c , s , lf 같은거
		: 만약에 printf 내에서 실제로 %를 문자로써 사용 원하면 %%로 씀됨
	

입력 메서드
	1. read():키보드 입력
		: 아스키코드나 유니코드가 아닌 가상 키코드 (virtual keycode)를 입력 받는다
			: 문자가 아닌 정수값을 입력받는거라 char 형 아닌 int 형 쓴다.
		: 엔터를 기준으로 입력받고 (이전에 남아있는게 있음 별도로 엔털 필요로 하진 않는다) 엔터키는 없어지지 않고 입력된다
				: 자바에서는 엔터(줄바꿈) == 13(캐리지리턴) 이후 10(라인피드) 이다
					: 캐리지 리턴 == '\r' ) 젤 왼쪽으로 커서를 옮김 
					: 라인피드 == 개행문자 == '\n' )다음 행으로 커서 옮김	
					: 참고로 에디터 밑의 CRLF 혹은 LF 는 \r\n 으로 줄바꾼다 혹은 \n으로 줄바꾼다 를 표기한거임

		:main 메서드 뒤에 예외 처리 코드(throws Exception) 따로 써줘야 사용 가능하다.
			 public static void main(String[] args) throws Exception{
			int key;
			while(true) {
				key=System.in.read();
				System.out.print(key);
				if(key == 13 || key == 10) System.out.println("(Blank)");	
				else System.out.println("("+(char)key+")");
				}
			}
		: 단점) 키코드를 하나씩 읽는다 . 그래서 잘 안쓰고 scanner 쓴다
			1. 그래서 2개 이상의 키가 조합된 한글(ex . 가 == ㄱ + ㅏ)을 읽지 못한다
			2. 그래서 문자열을 통째로 읽지 못하고 일일이 한자 씩 읽는다
	
	2.  nextLine() :  
		: read()의 단점 보완한것
		: 엔터키를 기준으로 입력받고 엔터키 제외한 이전 내용까지 입력됨
		: 예외 처리 없이 사용 가능함
		: 사용법
		1) java.util 패키지에 들어있는 Scanner 클래스를 불러옴
			: import java.util.Scanner;
		2) 새로운 Scanner 생성과 이를 담을 Scanner 타입의 변수 선언
			: Scanner scanner = new Scanner(System.in); //보통 변수명은 scanner 로 하는 편
		3) Scanner 타입의 변수를 대상으로 nextLine() 메서드 활용하여 입력받음
			: String str = scanner.nextLine();
		: 헷갈리지 말아야할게 System.in 대상으로 쓰는게 아니라 Scanner 객체 대상으로 쓰는 거임
