constraint
	: 데이터 제약조건
	: 데이터의 무결성 지키기 위함
	: primary ket, foregin key 같은거


SELECT 시퀀스명.CURRVAL FROM DUAL;
SELECT 시퀀스명.NEXTVAL FROM DUAL;

INSERT INTO TABLE1 VALUES( .... ,  DEFAULT , .... ,  시퀀스명.NEXTVAL);

ALTER SEQUENCE 시퀀스명 INCREMENT BY -1;


CREATE SEQUENCE 시퀀스명
INCREMENT BY 2
START WITH 100
MAXVALUE 199999
MINVALUE 9
NOCACHE
CYCLE;

DELETE FROM TABLE1 WHERE NAME1='홍길동';
UPDATE 테이블명 SET ROOM1=202 WHERE NAME1 LIKE '홍길동';

ALTER TABLE TABLE1 ADD(컬럼명 NVARCHAR2(100));
ALTER TABLE TABLE1 MODIFY(컬럼명 NUMBER(2));
ALTER TABLE TABLE1 DROP COLUMN 컬럼명 ;
ALTER TABLE TABLE1 RENAME COLUMN 이전이름 TO 이후이름;

-------------------------------------------------------------------------------------------------

DAO data access object
	: db 접근위한 객체
	: 싱글톤
	: 순서
		1. DataSource 객체 생성
			Context context =new InitialContext();
			ds = (DataSource)context.lookup("java:comp/env/jdbc/oracle");


			: 이 과정을 한번만 해주면 conn 객체를 구할때 매번 해야했던 아래 과정을 생략할 수 있게 해줌
				Class.forName(driver); // jdbc 드라이버를 메모리에 올림

		2. 각 메서드에서 아래 과정 되풀이
			(1) connection 객체 생성
				conn = ds.getConnection( ) ;
			(2) prepareStatement 객체 생성 << 쿼리문을 저장
				pstmt = conn.prepareStatment( 쿼리문 );

			(3) 쿼리문 제대로 완성
				setter 계열 메서드 사용	<< 값의 자료형에 맞는 메서드 픽
				pstsm.setXXXX( 물음표인덱스, 값 );

			(4) pstmt 객체 실행 << 쿼리문 실행
				case1. ResultSet excuteQuery( ) << insert 문
					1. 일단 rs 객체 얻음
					2. rs 객체에서 레코드 단위로 값을 뽑음
						while(rs.next( ) )	{
							.	.	.
						XXXX tmp = rs.getXXXX( 컬럼명 );
						}
				case2. int excuteUpdate( ) << update , delete 문


			(5) close( )

	: 활용
		: jsp 에서 DAO 클래스 내의 메서드를 사용하기 위해서 스크립틀릿에서 dao 객체를 getInstance( ) 써서 만들고 그 객체로 메서드에 접근한다
		: 	memberDAO dao = memberDAO.getInstance();
			String id = request.getParameter("id");
			String pw = request.getParameter("pw");
			int flag = dao.loginCheck(id,pw); 



DTO 객체 Data Transfer Object
	: 운반책이지, 실제 데이터 가 아니다
		: 실제 데이터는 dto 객체에 담겨져온 데이터 덩어리중 활용 원하는 값을 선별하여 쿼리문에 넣어 업데이트 하고 그러는거다

	: DTO 활용
		(1) 객체 생성
			case1. 걍 자바 클래스로써
				(1) 객체 생성
					클래스명 dto = new 클래스명( );
				(2) 초기화
					dto.set필드명(초기화값);

			case2. 자바빈으로써
				(1) 자바빈 객체 생성
					<jsp:useBean id="dto" class="com.jsp.memberDTO" scope="page"/>
				(2) 자바빈 프로퍼티 설정
					: 개꿀팁 >>
						<jsp:setProperty name="dto" property="*" />
		
		(2) 객체 저장
			: 다른 jsp 페이지에서 해당 dto 객체의 정보를 사용가능하게 하기 위함
				: 단순히 dao 객체의 메서드의 arg 로 할 목적으로만 만들었지, 다른 페이지에서 직접 사용할 필요 없는 dto의 경우 따로 저장할 필요 없음
			: 내장 객체에 attribute 의 형태로 바인딩해 저장
				ex) session.setAttribute("member",dto);									
				ex) request.setAttribute("member",dto);
				ex) application.setAttribute("member",dto);


		(3) 객체 활용
			: 다른 jsp 페이지서 사용
				1. dto 객체 꺼내기>> 내장객체에 attribute 로 저장되있는거 꺼내서 사용
					memberDTO dto = (memberDTO)session.getAttribute("member");

				2. 해당 dto 객체에서 필드값 뽑아내기
					sol1. el 표현식 활용 >> ${dto객체.필드명}
						: el 표현식의 경우 '객체.필드명' 만 명시해도 알아서 getter 메서드 불러와줘서 가능
						: 물론 직접 ${dto.getXXX() } 하는 것도 됨

					sol2. 스크립틀릿 내부서 꺼내기 >> dto객체.getXXX( )
					sol3. 자바빈 액션태그 >> <jsp:getProperty name="dto객체" property="필드명" >
						: property 부분에 필드명 만 쓸 수 있고, 필드명을 이용하여 gettter 계열 메서드를 자동으로 찾아준다
							: getXXX 를 직접 쓰진 못한다

-------------------------------------------------------------------------------------------------
session , application , request, pageContext
	(1) setAttribute( "이름" , 값 )
	(2) Object getAttribute("이름")
		: Object 타입이라 형변환 필수
	
-------------------------------------------------------------------------------------------------
EL 표현식
	: 변수명 설정하는건 var 속성
	: 태그들
		<c:set var='변수명' value='${값}' /> 
			: 변수 생성

		<c:out  value='${변수명}' /> 
			: 출력
			: <c:out value="${dto.address }"/> 처럼 getter setter 메서드가 존재하는 객체의 경우 el 표현식 내부에서 필드명으로 바로 접근 가능

		<c:forEach var="i" begin="0" end="20" step="3">
			<c:out value="${i}"/><br>
		</c:forEach>
			: 일반for문


		<c:forEach var="i" items="${ 객체에저장된변수 }">
			<c:out value="${i}"/><br>
		</c:forEach>
			: 향상된 for문


		<c:if test="${조건문}">
			어쩌구
		</c:if>
			: if 문

		<c:choose>
			<c:when test="${조건문}">
				어쩌구
			</c:when>
	
			.
			.
			.

			<c:otherwise>
				어쩌구
			</c:otherwise>
			
		</c:choose>
			: choose 문(switch 문과 비슷)


---------------------------------------------------------------------------------------------------------------
업데이트 쿼리문에서 + 1 바로 시킬 수 있다
    	: String query = "UPDATE Board SET hit=hit+1 WHERE board_id=?";
	: 주의해야할 것은 복합대입연산자(+= 같은거)는 사용불가하다
---------------------------------------------------------------------------------------------------------------



MVC Model View Controller
	: 디자인 패턴 중 하나고 , 세가지 역할로 구문한 개발 방법론이다.
		: 또다른 디자인 패턴으론 싱글톤이 있다

	: Model
		: 내부 비즈니스 로직을 처리하기 위한 역할을 한다. 
			: 비즈니스 로직 << Model 분야의 코드. 그러니까 보이지 않는(보이는 부분은 view 영역에서 처리) 핵심적인 작업을 수행하는 코드

		: Service 클래스
			: Model 기능을 하는 클래스들
			: 내부적으로 DAO , DTO 클래스를 활용
				: DAO , DTO 객체는 Service 클래스가 아니고 Model 기능을 수행하지도 않는다.

	: View
		: 클라이언트에게 response 될 화면(UI User Interface)을 처리하는 코드
		: 필요하다면 View 에서 Model 참조가 가능하다
			: Model에서 받은 데이터는 별도로 저장하지 않는다.
			: Model 은 View 를 불러내지 못한다
		: 예) jsp

	: Controller
		: Client 에게 직접 request 를 받고 response 를 하며 ,  Model과 View 사이를 이어주는 인터페이스 역할을 하는 코드
			: Controller는 request에 따라 Model , View 를 호출한다. 그리고 필요하면 각각으로부터 반환값을 받아 활용한다
			: View 는 포워딩방법으로 불러낸다
		: Controller 부분을 '로직' 처리하는 부분 이라고도 하는 것 같다	
			: 비즈니스 로직은 딱 모델 영역 말하는 거다


	: MVC 모델의 종류
		:MVC 모델 1 
			: Controller 과 View 를 합쳐 JSP로 모두 구현하는 방식
				: Model 은 모델2 와 마찬가지로 java언어 로 서비스 클래스
			: 단점
				: 프론트엔드와 백엔드가 구분되지 않는다


		:MVC 모델 2
			: Controller , View , Model 로 3분할 하여 구현하는 방식
			: Controller 
				: 어플리케이션 통틀어 하나
				: Servlet 클래스 형태

			: View, 
				: jsp 로 필요한 만큼 작성

			: Model
				: service 클래스의 형태로 필요한 만큼 작성



MVC 모델2 실습
	: DTO , DAO 객체 준비하기

	: Controller 구현하기
		0. servlet class 생성
			: 이때 바로 finish 누르지 말고 next 누르고, service( ) 선택해라 (물론 직접 만들어도 되긴 하는데 귀찮잖아)
		1. url 패턴을 servlet 과 매핑 시키기
			@WebServlet("*.do")  

			: 그러니까 의도를 정리하자면 
				>> 일단  .do 확장자를 가지는 URL 의 request 는 모두 이 컨트롤러가 관리하게 한다
				>> 이 컨트롤러로 해당 request 객체가 넘어오게 되면 .do  앞의 * 부분에 따라서 필요한 model , view 들을 호출하게 된다.

			: *.do 
				: .do 확장자
					: jsp 에서 보통 사용하는 주소
					: 굳이 do 로 하는이유는 딱히 특별한건 없고 다른 서블릿과의 URL 충돌을 막기 위해서이다
						: 굳이 확장자를 do 로 고집할 필요는 없다
						: https://okky.kr/articles/262795
				: *.do
					: 앞이 어떻게 됬건 url 의 확장자가 .do 이기만 하면 모두 이 서블릿과 맵핑된다는 의미
					: 까먹으면 안되는건 서블릿과 매핑되는 url 패턴의 꼴은 원래 "/어쩌구저쩌구" 로 앞에 짝대기 하나 있는거지만 *.do 의 경우 * 에 '/' 도 포함되기 때문에 따로 명시하지 않은것



		2. service(HttpServletRequest, HttpServletResponse) 오버라이드 하기
			: protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 이다
			: 기본적으로는 service(request, response) 는 앞서 생성된 request, response 객체를 arg 로 받고, request 객체의 헤더 내용에 따라서 reqest, response 객체를 doPost(req, rers) 혹은 doGet(req, res ) 로 전달하여 로직을 수행한다.
			: 절차
				1. 일단 위에 @Override 어노테이션 명시
				2. request 객체 인코딩 설정
					request.setCharacterEncoding("UTF-8");
					: 말로는 인코딩이라고 하지만 사실 request 로 들어온 데이터를 어떻게 디코딩할지 결정하는 거임

				3. request 객체로 넘어온 요청 URL 에서 URL pattern 추출하기 >> 결과적으론  / *.do 만 남는다
					String uri = request.getRequestURI(); 
					String conPath = request.getContextPath();
					String result = uri.substring(conPath.length()); 

					: 그냥 URL 통쨰로 사용해도 문제 없긴 한데 번거로워서 따로 subString 하는거다
						: 클라이언트에 request 따라서 필요한 로직을 구별하기 위해 필요한건 URL 전체가 아니라 .do 의 바로 앞 부분만 필요하기 때문이다.
							: 어차피 이 controller 로 들어온 이상 contextpath 는 같은거니까 딱히 구별할 필요가 없다

					: request.getRequestURI(); 
						: request 객체에 저장된 URL 중 URI 만 뽑아낸다
							: URI >>앞의  http 이런거 빼고  ContextPath 부분부터 URL끝까지
						: URL 을 대상으로 substring 하는게 아니라 굳이 URI 을 대상으로 substring 하는건 ContextPath( ) 는 딱 Contexetpath 부분만 추출하지, 앞의 http 까지 추출하는게 아니라 그냥 contextPath 사이즈로만으로 subString 하기에는 무리가 있다.

					: request.getContextPath();
						: request 객체에 저장된 URL 중 ContextPath 부분'만' 뽑아낸것
							: 즉 프로젝트 명

					: String 문자열.subString( int index )
						: 해당 인덱스 이상부터 끝까지 의 문자열을 추출한다
						: 문자열 길이의 경우 해당 문자 인덱스 + 1 이기 때문에 , 딱 길이인 conPath.length( ) 를 arg 로 하면 conPath 바로 다음 부분 이상부터 잘 추출된다.
		
	
				4. viewPage 객체 생성
					String viewPage =null; 
					: URL pattern 따라서 if 문으로 반환된 JSP 페이지 URL 을 할당 받게될 변수이다
						: 그러니까 이 변수에 할당된 URL 로 포워딩된다.

				5. Command 인터페이스 생성
					: java 에서 별도로 주어지는게 아니라 우리가 별도로 만드는거다
					: 목적은 코드를 통일하는 것도 있지만 다형성 구현이다
						: Command 타입의 변수 하나로 여러가지 내용을 실행시킬 수 있따
					: excute 추상 메서드를 정의헤놓고, 이 인터페이스를 service 클래스들이 구현하게 하여서 공통적으로 excute 메서드를 가지게 한다.
						public interface Command {
							public String excute(HttpServletRequest request, HttpServletResponse response);// 뷰페이지 반환
						}

						: excute 메서드는 request, response 객체를 arg 로 받아 필요한 작업을 처리한 후 , 이동해야할 페이지를 반환하는 메서드 

 
				6. Command command = null; 
					: Command 인터페이스 타입의 레퍼런스 변수를 일단 생성한다
						: 레퍼런스 변수를 통하여, 어떤 service 클래스 객체를 받던간에 excute( ) 메서드를 실행시킬 수 있다
						: 결과적으로는 한 레퍼런스 변수를 통하여 다양한 내용 실행이 가능해진다.



				7. if 문 으로 URL  pattern 따라 다른 로직을 수행하게 한다 
					: 어떤 블럭이 실행되는 viewPage 가 할당 되게 한다

					if(result.equals("/list.do")) {
						command = new ListCommand();
						viewPage= command.excute(request, response);
					}
					else if(result.equals("/writeForm.do")) {	
						viewPage= "board/writeForm.jsp";
					}
					.
					.

				8.  if -else 문으로 얻은 viewPage 의 값을 arg 로 하여 forward 기능 구형니 가능한 객체인 RequestDispatcher 타입의 객체를 얻는다
					: RequestDispatcher 타입의 객체를 생성하는 getRequestDispatcher(String page) 의 경우 resposne 객체가 아닌 request 객체를 대상으로함을 주의

					RequestDispatcher dispatcher = request.getRequestDispatcher(viewPage);


				9. RequestDispatcher 객체를 대상으로 forward 메서드를 호출
					: forward 의 경우 request , response 객체가 유지되기 때문에 arg 로 request, respone 객체 줘야 함을 잊지 말자
					dispatcher.forward(request, response); //해당 jsp 페이지로 forward




		
		



--------------------------------------------------------------------------------------------
//.do >>jsp 에서 사용하는 가상의 주소
	// 사용자는 파일의 실제 경로룰 알 수 없으므로 보안에 도움이 된다
@WebServlet("*.do")  // *.do >> 어떤 request 이든 .do 로 끝나면 BoardController 가 이를 처리하겠다

	: 어쨌거나 지금은 잘 안쓰는 추세이다.

--------------------------------------------------------------------------------------------






https://youngjinmo.github.io/2020/08/servlet-redirect-forward/


인터페이스
	: 멤버로 할 수 있는 대상 << 생성자 선언 못하는거주의
		1. 상수 필드 << static final 타입의 필드
		2. 추상 메서드 << abstract 타입의 메서드
			: 오버라이딩 당하기 위해 존재하는 메서드로, 선언부 밖에 없고 정의는 구현클래스에서 해야한다


인터페이스 익명 구현 객체
	: 인터페이스명 레퍼런스변수명 = new 인터페이스명( ) {

		@Override

		}; 



String subString(int start, int end)
	: 인덱스 기준으로 문자열에서 문자열을 추출
		: start<= < end 이다 (이상 미만)
	: ex) 
		String str1= "you are a SpongeBob";
		String subStr1= str1.substring(10); // 이상 미만
		String subStr2= str1.substring(10,19); // 이상 미만
		System.out.println(subStr1+", "+subStr2);

비즈니스 로직
	: 정리하지면 model 영역에서의 코딩을 비즈니스 로직이라고 한다
		: 비즈니스 로직은 request 따른 작업을 처리하기 위한 핵심적인 코드를 의미한다
			: it 쪽에선 '비즈니스' 란 용어는 ''소프트웨어가 풀고자하는 현실 세상의 문제' 을 의미한다
			: view 를 위한 코드, Data 접근을 위한 코드는 이에 해당하지 않는다. model 영역에서 주어진 data를 활용하여 작업 처리하는 코드를 비즈니스 로직이라고 한다.
	: https://naraewool.tistory.com/309
	: '도메인 로직'과 거의 동의어로 쓰인다

