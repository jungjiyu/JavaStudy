
양진석 강사
	개인 이메일) b0b0317@naver.com
	수업자료) http://naver.me/FBDAsFgJ
		: 비밀번호 - kg1234


프레임워크
	:  개발을 편하게 해주는 도구. 재사용이 가능하게끔 협업화 된 형태로 클래스들을 제공함.
	: 장점
		: 코드를 일일이 만들지 않아도 되어 효율적
		: 프레임워크의 틀에 맞춰 개발하므로 개발자기리 일관된 코드 작성 가능.
	
라이브러리
	: 자주 사용되는 클래스들을 잘 정리한 클래스(코드) 의 집합. 프레임 워크의 재료.
		: 그러니까 얘는 뼈대고, 라이브러리는 첨가물 느낌임

스프링 프레임워크
	: 자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급(==가벼운) 애플리케이션 프레임워크
		: EJB Enterprise Java Bean 라는 프레임워크를 사용했었는데 쓰기도 어렵고 비용 부담이 넘 컷었다. 이걸 보완한게 스프링이다. 겨울을 지나 봄이 왔다는 뜻.

	: 특징
		1. 경량 컨테이너다
			: 스프링은 자바 객체를 직접 관리(객체 생성, 소멸과 같은 라이프 사이클을 관리)하기 때문에, 우리는 스프링으로부터 필요한 객체를 얻어올 수 있다.

		2. POJO Plain Old Java Object 방식이다
			: POJO >> 단순 자바 Object. 
				: 특정 인터페이스를 구현하거나 상속을 받지 않고 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다. 의존성이 없고, 유지보수가 편리


POJO
	: IoC/DI, AOP , PSA 를 통해서 달성할 수 있다는 것.
	: Plain Old Java Object 란, 순수한 오래된 자바 객체. 즉 , 자바로 생ㅇ성하는 순수한 객체.
		: 그러니까 객체지향적거란거

	: 근데 객체라고 해서 다 POJO 프로그래밍인건 아니고, 다음의 규칙을 지켜야한다
		1. 자바 이외의 다른 기술을 활용한거면 안된다.
		2.



		3. IoC(Inversion of Control) 을 지원한다
			: IoC 는 제어의 역전을 의미한다. 즉, '객체'의 호출 작업을 개발자가 결정하는게 아니라, 프레임워크가 결정한다.
				:  객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복, 유지 보수를 편하게 할 수 있다.
				: 의존성 >> 어떤 객체를 사용하기 위해서 다른 객체까지 필요한 것
					ex) A 객체를 사용하기 위해 B 객체가 필요하다면 A 객체는 B 객체에 의존하는 것 
			: 스프링이 모든 의존성 객체를 스프링이 실행될때 다 만들어주고 필요한 곳에 주입시켜줌으로써 제어의 흐름을 사용자가 컨트롤하는것이 아니라 스프링에게 맞겨 작업을 처리하게 된다.
				: 그러니까 A 객체를 사용하기 위해 직접 B 클래스를 import 하고 객체 만들고서야 사용 가능한게 아니라 그냥 A 객체를 사용하기만 하면 spring 이 내부적으로 B 객체를 제공한다

		4. DI Dependency Injection 을 지원한다
			: 의존성 주입.말 그대로 객체가 서로 의존하는 관계가 되도록 의존성을 주입 한다는 뜻
				: 각각의 계층이나 서비스들 간의 의존성은 프레임워크가 서로 연결되게 해준다.
				: IoC 에서 DI 의 역할은 각 클래스 사이에 필요로 하는 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동 연결해주는거다  

			: DL Dependency Lookup
				: 의존성 검색, 
				: 컨테이너는 객체를 관리하기 위해 별도의 저장소에 빈을 저장한다. 개발자들이 컨테이너에서 제공하는 API 를 이용하여 사용하고자 하는 빈을 검색하는 방밥이다. 

		5. AOP OfProgramming 관점지향 프로그래밍 을 지원한다
			: 여러 모듈에서 공통적으로 사용하는 기능의 경우 분리하여 관리한다.

		6. 확장성이 높다
			: 수많은 라이브러리가 스프링에서 지원된다.

의존성이 뭔데

의존성 주입
	: A 객체서 B 객체를 덩고 싶다 >> 스프링이 주입해준다.


		5. 스프링은 확장성이 높다


--------------------------------------------------------------------------------------------------------------------------------------
STS Spring Tool Suite 
	: 이클립스 기반으로 스프링 어플리케이션을 개발하기 위한 IDE << 그러니까 이클립스에 스프링 기능 추가한거
	: 현재는 STS4 까지 나왔는데 STS4 에서는 레거시 프로젝트를 지원하지 않기 때문에 STS3 를 다운받는다
		: 절차
			1. spring.io/tools 사이트 스크롤 해서 sts3 에서 하이퍼링크(..wiki) 누름 >> 3.9.18 의 window 버전 다운로드
			2. 해당 파일의 압축은 '반디집'으로 푸는게 좋다(그냥 풀면 파일명이 넘 길다고 에러 난다)
				: 주의 >> 나중에 모든 설정 다 끝내면 sts-3.9.18.Release  '빼곤' 다 지워도 되는데 다 설정하기도 전에 지워버림 에러난다.
			3. sts-bundle 폴더 >> ' sts-3.9.18.Release ' 폴더 로 이동하여 STS. ini 파일 수정 >> STS 에서 사용할 JDK와 인코딩 방식을 UTF-8로 수정하자
				(1) vm (Virtual Machine) 을 jdk 로 설정
					: -vmargs 위에다 아래를 적음
						: jdk 파일의 bin 폴더 까지의 경로를 저장 (인터넷 자료들에서는 C:\Program Files\Java\jdk-21\bin\javaw.exe 까지 명시하게 되어있는데 bin 폴더까지의 경로만 설정해줘도 괜찮음)
						-vm
						 C:\Program Files\Java\jdk-21\bin

				(2) 인코딩 방식을 UTF-8 로 설정
					: 맨 끝에 아래를 추가
						-Dfile.Encoding=UTF-8

			4. sts-3.9.18.Release 와 같은 계층에 'tomcat 디렉터리' 와 '워크 스페이스를 담을 껍데기 폴더' 를  만들고, 그 껍데기 폴더의 내부엔 내부에 워크 스페이스를 ㅎ생성한다
			5.  sts-3.9.18.Release  내의 sts.exe 실행해봄
				: 근데 한가지 문제점은 언젠가부터 sts3 에서 레거시 프로젝트를 생성할때 별도로 MVC 템플릿을 제공하지 않는다. 따라서 우리가 추가적으로 API 설치를 해야된다

			6. 공유 자료로 나눠준 https-content.xml 을 다운로드 받는다
			7. 워크 스페이스의 .metadata 디렉터리로 들어가고 , plugins 디렉터리로 들어가고, 거기서 org.springsource.ide.eclipse.commons.content.core 이름의 디렉터리 가서 다운로드 받았던  https-content.xml  를 넣는다
				: 왜그런지 모르겠ㅈ만 내 워크 스페이스엔 org.springsource.ide.eclipse.commons.content.core 폴더가 없어서 내가 걍 직접 그 이름으로 폴더를 만들고 거기에 다운로드 받은 https-content.xml 파일을 집어넣었다 (결과적으론 별 문제 없이 MVC 프로젝트 템플릿 생성가능해짐)


			8. sts.exe 누르고 서버 설정(tomcat 9.0) 한다 && 서버 설정한다
				1. 이때 http port 번호 8282 로 설정한다 (안해도 되긴 하는데 혼잡할 수 있어서)
				2. serverlocation 을 2번째 선택란(use tomcat installation) 을 체크, Server options 를 (기존 체크박스는 그대로 냅두고) publish module contexts to seperate XML files 체크한다
				3. . window-preferences-buffer 에서 버퍼 사이즈를 100만 (1000000)으로 변경한다
					: 안그러면 서버가 안돌아가더라

			9. window-preferences-encoding쳐서 나오는 란에서 일일이(css, jsp 같은 것도) default encoding 을 utf-8로 설정
				:ㅈㄴ 불편한게 spring 은 ms949 가 기본으로 되있어서 우리가 """꼭""" 기본 encoding 설정을 utf-8 로 바꿔줘야됨
				
			10. 끝


	
-------------------------------------------------------------------------------------------------------------------------

웹 프로젝트 MVC 생성하기
	1. SpringMVCproject 으로 생성하기 클릭, 제목 지음
	2. 중간에 requires donwload of 16608 bytes 창 나오는데 정상이니까 겁먹지x. 확인 클릭 
	3. 기본 패키지 작성 >> ' 최상위도메인.회사명.프로젝트명 ' 로 3 그룹으로 , '.' 을 기준으로 구분해 지음
		: 프로젝트 명은 곧 ContextPath 가 됨
		: ex) com.java.test

	4. 다 됬으면 프로젝트의 project facet 설정에서 java 버전을 11  로 맞춰줘야됨
		: ㅈㄴ 멍청한게 인식을 못함 (나의 경우 설정이 디폴트 21 로 되있었음)
-------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




Maven 메이븐 >> 프로젝트의 전체적인 라이프 사이클 관리 도구
	: 프로젝트 객체 모델(Project Object Model: POM) 이라는 개념을 바탕으로 한다
	: 플러그인 >> 다른 리소스를 편리하게 설치 가능하게 해주는, 해당 프로그램을 확장 가능하게 해주는 프로그램
		: Adobe Flash , Window Media Player 같은게 플러그인

	: 빌드>> 작성한ㄴ 소스 코드 , 파일 등을 JVM 이나 WAS 가 인식할 수 있는 구조로 패키징 하는 과정 및 결과물
	: 확장자는 pom.xml 이다
	: 기능
		1. 중앙 저장소를 통한 자동 의존성 관리를 한다.
			: 내가 필요한 라이브러리를 (pom.xml) 에 정의만 해주면 내가 사용할 라이브러리 뿐만 아니라 해당
라이브러리 작동에 필요한 하위 라이브러리까지 알아서 네트워크를 통해서 다운 받아준다.
				: 네트워크를 통한 다운을 받아야되므로 인터넷이 연결되있어야 한다

				: 에 있는 정보를 메이븐 리파지토리 사이트에서 다운받아 jar 파일을 C: > 사용자 > 컴퓨터계정 > .m2 > repository 폴더에 저장을 한다.

		2. 정해진 빌드 방법을 사용하여 협업에서 유리하게 작용한다.
			: 다른 개발자끼리 라이브러리 버전이 달라 생기는 문제 등을 사전에 방지해준다

	: 만드는 법
		1. Maven Project - create a simple project 체크박스 체크 && workspace 지정 
		2. group id, artifact id 지정
			: group id  >> 프로젝트를 식별할 수 있느 고유한 이름
				: 일반적으로는 회사 도메인을 거꾸로 함

			: artifact id  >> 프로젝트의 이름으로 사용된다.
				: artifact 는 소프트웨어의 산출물을 의미
				: 빌드를 완ㄹ

	: 구성
		: html css 등 >> 정적 자료 저장
		: pom.xml >> 라이브러리 다운 위한 핵심적인 파일

	: pom.xml
		: <project>와 </project> 태그 사이에 모든 정보를 기술한다
			:아래를 따로 작성 필요하다. 오타의 위험이 있으므로 걍 복붙하자

<build> <-- 빌드 관련 설정-->
		<plugins> <-- 플러그인 대한 전체적 설정 시작 -->

			<plugin> <-- 플러그인 중 특정 플러그인 설정 -->
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.8.1</version>
				<!-- 
				<configuration> : 플러그인의 실행옵션 설정
				자바컴파일러를 11버전으로 지정한다.
				 -->
				<configuration>
					<source>11</source>
					<target>11</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>  


	: https://mvnrepository.com/ 사이트에서 검색 후에 사용할 라이브러리를 복사 후 
	  <dependencies> 태그 안에 의존 라이브러리를 복붙해 작성한다. 복사 되는 꼴을 보면 각각의 의존 라이브러리 정보는 <dependency> 태그 안에 작성되있음을 볼 수 있다
		: 하나의 dependency 태그 안에 한개의 모듈(라이브러리)  코드가 복붙 된다고 보면된다.


	: 메이븐 >> 플러그인을 구동해주는 프레임 웤크(plugin execution framework). 모든 작업은 플러그인에서 수행한다.  대부분의 빌드 작업 시 플러그인을 활용하며 플러그인을 바인딩 시켜 빌드 작업을 수행한다


Spring Framework 모듈
	: 스프링 프레임워크에서 제공하고있는 모듈을 사용하려면, XML 파일등을 사용해서 모듈에 대한 설정을 해야한다.

spring-core 스프링의 IoC 와 DI 기능을 제공한다.
	:  IoC(Inversion of Control) 을 지원한다
			: IoC 는 제어의 역전을 의미한다. 


spring-aop 관점지향 프로그래밍을 할 수 있도록 지원하는 기능을 제공한다.
	Aspect Oriented Programming 
spring-jdbc 데이터베이스를 쉽게 다룰 수 있는 기능을 제공한다.
spring-tx 스프링에서 제공하는 트랜잭션 기능을 제공한다.
	Transaction 
spring-webmvc 스프링에서 제공하는 스프링 MVC 구현기능을 제공한다


--의존 라이브러리 설치 하는 법
	
spring context - 5.3.23

jstl 인가 ? 그런거 할뗀 file - jar 다운 받았었는데 이번엔 아ㄴ그러고
밑에 maven 탭에 있는 텍스트 copy 하기만 하고,
그 copy 한걸 pom.xml 의 dependencies 태그 내부에 복붙한다
	: 따로 dependency 태그를 적고 그 내부에  copy 하는게 아니다 . 복붙되는 텍스트를 보면 이비 텍스트에 <dependency> 가 있고 그 내부에 내용이 정의도ㅣ있음을 알 수 있따

설치 다 하고 나서는 maven project update 를 해주어야하ㅏ는데 직접 우클릭 - maven - update project 해도 되고 아님 단축키 alt + f5 눌러도 된다
	: 이걸 완료하면 maven dependencies 라는게 생기고 그 내부에 많은 라이브러리들이 설치되있음을 볼 수 있다.
	: jar 파일 옆에 뜬는 경로를 보면 , c: - 사용자-내이름 - .m2  - repository 에 저장되있음을 볼 수 있다
		: 거기가 라이브러리들이 저장되는 곳이다


라이브러리를 다운 받는 도중에 모종의 이유로 다운로드 하다 만 상태면 걍 repository 폴더를 삭제하고 새로 update 하면 된다.
-------0=---------------------------------------------------
Spring DI Dependency Injection
	: 스프링이 제공하는 의존 관계 주입 기능
		: 우리가 객체를 직접 생성하는 게 아니라 스프링이 알아서 생성한 후 주입 시켜주는 방식이다.
		: 그러니까 우리가 예전에 직접 필요한 객체를 new  연산자를 사용하여 생성했었지만 , spring 의 경우 setter 메서드 혹은 생성자를 통하여 객체를 얻은 후 사용하는 방식이다
			 :근데 그럼 new 연산자랑 다를게 뭐가 있는데

	: DI(의존성 주입)를 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다.
		: 씨발 결합도가 뭔데

	: 그렇다고 완전히 객체 생성 과정을 생략하고 대뜸 객체 할당도 안해주고 레퍼런스 변수를 대상으로 활용할 수 있다는ㄱ 아디다


src/main/java 디렉터리에 패키지 생성하고 그 패키지 내부에 클래스 파일 생성



		DI는 의존하는 객체를 직접 생성하지 않고도 의존 객체를 전달 받는 방식이다
		사용 이유는 >> 의존 객체의 변경의 유연함 때문이다
			: 의존갹체가 여러 클래스에서 사용 되었을 시 의존 객체를 전달해주는 코드만 변경하면 된다.


	public ChickenOrder() {
		chicken = new BHCChicken();// 직접 new 연산자를  사용하여 생성을 했다
	}
	
대신
	
	public ChickenOrder( ChickenHouse chicken) {
		this.chicken = chicken;
		}
쓰는게 DI 쓰는거다




Spring 의 DI는 두번째 방식을 택한다. A 객체에서 B, C등의 객체를 사용(의존)할
때 A 객체에서 직접 생성 하는 것이 아니라 외부(== IoC컨테이너)에서 생성된 B, C객체를 주입(조립)시켜 setter or 생성자를 통해 사용하는 방식이다.
	

IoC 컨테이너란? 스프링 프레임워크도 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너가 있는데, 그것이 바로 IoC 컨테이너 이다

	: IoC >> 제어의 역전	:, 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미한다
		: 제어권이 바뀌었다 
			: include 에선는 제어권을 넘겨줬다 받았던거고 , forward 는 아예 제어권을 넘겨준다.

	: 컨테이너란>>  컨테이너는 보통 객체의 생명주기를 관리, 생성된 인스턴스들에게 추가적인 기능을 제공하도록 하는 것을 말한다.

	: spring 은 거의 IoC 컨테이너 그 자체라고 봐도 된다.
	: 치킨 집 과 치킨 본사의 관계에서 Ioc 컨테이너는 치킨 본ㅇ사라고 보면 된다. (닭 주문 요청하기ㅣ.)


객체관리 주체가 Ioc 컨테이너(Container)가 되기 때문에 개발자는 로직에 집중할 수 있는 장점이 있다.
	: IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다. 의존성 주입은 IoC 컨테이너에 빈으로 등록이 되어야 의존성 주입을 할 수 있다.

POJO(== 걍 java 로 생성된 객체라고 봄 됨)의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다. 보통 개발자들이 직접 POJO를 생성할 수 있지만(== 직잡 겍ㅊ[ㄹ,ㄹ생성할 수도 있지만) 컨테이너에게 맡긴다

스프링 컨테이너 종류 << 보통 ApplicationContext 구현 클래스로 컨테이너에 접근한다 (BeanFactory 로 접근하지 않고)
	: BeanFactory 는 스프링 컨테이너의 최상의 인터페이스로 스프링 빈을 관리하고 조회하는 역할을 담당
	: ApplicationContext 는 BeanFactory 를 상속받아 BeanFactoy의 모든 기능과 추가적인 부가기능을 제공한다
		: 스프링은 두가지 타입의 컨테이너를 제공하는데, 그 각각의 컨테이넝에 접근 가능하다.
		: AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서 AppConfig.class 파일을 읽고 BeanDefinition 을 생성한다.
		:  GenericXmlApplicationContext 는 XmlBeanDefinitionReader 를 사용해서 appConfig.xml 설정 정보를 읽고 BeanDefinition 을 생성한다

		: 내가 봤을때  AnnotationConfigApplicationContext ,  GenericXmlApplicationContext 는 ApplicationCOntext 의 구현 클래스ㅡ이다. 



appConfig.xml 는 자바 코드 기반이 아니므로 src/main/resources 에서 만드는게 아니라 src/main/resources 에서 만든다
	: new - xml 파일 한다 || new - spring bean configuration file 한다



 bean 태그 :
	: 스프링 설정 파일에선는 bean 이라는 태그를 사용하여 해당 bean 객체를 생성할 수 있다.
	: jsp 액션 태그와 같다
	: 	<bean id="BBQ"  class="com.spring.di01.BBQChicken" /> 과 같이 한다


<property> 태그를 사용하여 빈 객체
의 속성에 객체 및 데이터를 주입하여
객체의 기능을 사용하도록 한다. 

----------------------------------------------
스프링 에서는 IoC container 를 이용해 의존 객체를 생성하고 서로 연결(== 조립, 주입) 해줄 수 있따
<bean id="myOrder"  class="com.spring.di01.ChickenOrder">
	<!--  조립한다 -->
		<constructor-arg><!--  생성자 -->
			<ref bean ="bbq"/> <!-- 참조한다 -->
		</constructor-arg>	
	</bean>


연결(== 조립, 주입)
--------------------------------------------------------------------------------------------
----------------------------------------------



		// xml 파일에 설정한거는 GenericXmlApplicationContext 를 사영 ㄱ능
		GenericXmlApplicationContext context = new GenericXmlApplicationContext("classpath:applicationConfig01.xml"); // 문자열로 설정파ㅏ일 위치 지정

		// classpath: == src/mmain/resource
		//GenericXmlApplicationContext  는 xml 파일에 정의된 설정 정보를 읽어와서 객체를 생성하고 각각의 객체를 연결한 뒤에 내부적을 ㅗ보관ㄷ한다
		// 스프링 컨테이너는 생성한 빈 객체를 (이름, 객체) 의 형태로 보관하ㅏㄴ다
		// 보관하고 있는 객체를 사용하가 싶은 경우 빈 객체와 연결되있는 이름으로 해당 객체를 얻을 수 있다.



사실 근데 이건 원리를 알기 위해서 ㅎ해본거지 실제론 이렇게 다 일일이 안쓰고 어노테이션 달아준다.
----------------------------------------------
----------------------------------------------
----------------------------------------------
		
, 타입을 통일 시키기 위해 인터페이스 사옹
	// 변수를 인터페이스 타입으로 설ㅈ정함면 객체들의 타입을 통일 시켜 ㅈ어 개발 코드는 인터페이스에 정의된 메서드만 호출하면 된다
	// 그러니까 객체를 구현하는 코드와 객체를 사용하는 코드를 완전히 분리시켜 , 객체를 사용하는 코드를 ㄹ수정할 필요가 없다
		// 그러니까 유지 보수가 쉬워진다
		// 그러니까 다형성 구현이 가능해진다





------------------------------------------------------------------------------------------------------------------------------------------------------

https://raspberrylounge.medium.com/%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-%ED%8C%A8%ED%82%A4%EC%A7%80-package-%EC%99%80-%EB%AA%A8%EB%93%88-module-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-16b2eda177b4


패키지(Package)
	: 자바의 패키지는 하나의 디렉토리로 클래스들의 묶음이다. 보통 비슷한 성격들의 클래스들을 모아 둔다.


모듈(Module)
	: 자바의 모듈은 외부에서 재사용 할 수 있는 패키지들을 묶은 것을 말한다. 어떻게 보면 이클립스에서 개발하는 프로젝트는 하나의 모듈을 개발하는 것. 그리고 서로 다른 프로젝트가 import와 export를 이용하여 패키지(package)를 주고 받는다. 패키지의 상위 개념이라고 할 수 있다.

왜 자바에는 모듈과 패키지로 나누어져 있는 걸까? 그것도 초기부터가 아니고 나중에서야 나눠지게 된 걸까? 기존의 패키지만으로는 부족한 점들을 커버하기 위해서 생긴 것이다. 

첫째로, 패키지의 캡슐화(Encapsulation)가 완벽하지 않다. 객체지향 프로그래밍에서 세부 구현을 숨기는 캡슐화는 필수적인 기법이다. 하지만 자바에서 클래스는 액세스 지정자로 멤버의 공개 여부를 마음대로 지정하는데 비해 패키지의 정보 은폐는 약하다. 클래스를 숨길 수는 있지만 공개 또는 비공개 둘 중 하나만 선택할 수 있어 여러 패키지에서 공용으로 사용할 클래스를 외부에 대해 숨길 수 없다. 공용으로 사용할 클래스를 공개해 버리면 라이브러리 내부 뿐만 아니라 외부에서도 자유롭게 사용할 수 있다. 클래스는 패키지 내부로 숨길 수 있지만 패키지는 숨겨 두고 내부에서만 사용할 방법이 없다. 이럴 때는 문서나 가이드를 통해 내부용 패키지는 사용하지 말라고 부탁 또는 협박하는 수밖에 없는데 모든 개발자가 이런 권장 사항을 다 지키는 것은 아니다. 사용자가 내부 기능을 직접 사용하면 이후 자유롭게 유지, 보수할 수 없다. 그래서 문법적으로 완전히 숨길 수 있는 강한 캡슐화가 필요해졌다.

둘째로, 빌드 단계에서 프로그램 구동에 필요한 모든 클래스가 다 있는지 확인할 수 없다. 자바는 동적 로딩을 통해 필요한 클래스를 실행중에 로드한다. 덕분에 시작이 빠르고 생성할 클래스를 선택할 수 있지만 실행 직후에는 누락 사실을 바로 알 수 없다는 문제가 있다. 클래스 누락을 방지하려면 실행중에 로드되는 클래스가 다 있는지 수작업으로 일일이 확인하는 수밖에 없다.

마지막으로, 런타임이 거대해져 배포가 어려워졌다. 초기의 자바 플랫폼은 라이브러리의 모든 클래스를 rt.jar라는 단 하나의 파일에 통합하여 배포했다. rt는 런타임(Run Time)이라는 뜻이며 자바 프로그램이 실행되기 위한 모든 클래스가 포함되어 있는 자바 플랫폼 그 자체이다. 단일 파일이라 배포하기 쉽고 별 문제가 없었다. 그러나 자바 버전이 올라 가면서 rt.jar는 용량 60M에 2만개의 클래스를 포함하는 초대형 런타임이 되었고 앞으로는 더 늘어날 것이 뻔하다. PC에서는 별 무리가 없지만 임베디드 장비에 설치하기에는 너무 거대하다. 게다가 단일 파일이라 불필요한 것까지 한꺼번에 배포할 수밖에 없다. 꼭 필요한 클래스만 추려 원하는 런타임을 생성하고 런타임과 프로그램을 같이 배포할 수 있어야 할 필요가 생겼다.

이러한 문제들을 해결하기 위해 도입된 것이 모듈화다.


모듈 이란 > 
	> 소프트웨어 묶음을 만들고 , 코드를 네임 스페이스 로서 구분하는  멬케니즘
	: 모듈 - 패키지 - 클래스 



------------------------------------------------------------------------------------------------------------------------------------------------------

https://develop-log-sj.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C


스프링 프레임워크는 큰 규모의 Java 애플리케이션 개발을 위한 포괄적인 인프라 지원을 제공합니다. 또한, IoC 컨테이너이며 약 20개의 모듈로 구성되어 있는 솔루션입니다. 모든 모듈을 다 사용하는 것이 아닌 필요한 모듈만 가져다 쓸수 있어 가벼운 솔루션이라 불립니다. 모듈들을 레고블럭이라 생각하면 쉽습니다.

 
스프링 프레임워크 핵심

POJO ( Plain Old Java Object)

객체지향 프로그래밍 기법과 언어가 주는 장점인 유연한 설계와 재사용성을 활용하여 비즈니스의 복잡성과 변화를 상대함

 

IoC (Inversion of control) 제어의 역전

프로그래머가 작성한 소스코드가 프레임워크의 흐름제어를 받는 디자인 패턴

 

DI (Dependency Injection) 의존성 주입

IoC 구현을 통해 의존관계 해결을 위한 디자인 패턴.

XML 설정 혹은 애노테이션을 통해 의존성 주입을 쉽게 할수 있는 방법

 

AOP ( Aspect Oriented Programing )

모듈성을 높일 목적으로 서로 다른 관심사를 분리(separation of cross-cutting concerns)하는 프로그래밍 패러다임. 

성격이 다른 로직(업무 로직과 업무 로직 외 공통적인 부분)이 함께 있는 경우 이를 분리해서 처리해야 복잡성을 해결할 수 있음.

로깅, 보안, 트랜잭션 등이 있음.

여러 모듈에서 공통적으로 사용하는 기능의 경우 분리하여 관리한다.


 

PSA ( Potable Service Abstraction )

개발환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근하게 해주는 기능

서비스 추상화를 통해서 로우 레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부 기술에 독립적인 접근 인터페이스를 제공하면 기술적인 복잡함을 줄일 수 있음.

 -----------------------------------------------------------------------------------------------------------------

스프링에서는 자바 객체를 빈(Bean)이라 한다.

스프링 컨테이너(Spring Container)
	: https://ittrue.tistory.com/220
	:스프링 컨테이너는 내부에 존재하는 빈의 생명주기를 관리(빈의 생성, 관리, 제거 등)하며, 생성된 빈에게 추가적인 기능을 제공하는 기능이다

스프링 컨테이너는 XML, 어노테이션 기반의 자바 설정 클래스로 만들 수 있다.
스프링 부트(Spring Boot)를 사용하기 이전에는 xml을 통해 직접적으로 설정해 주어야 했지만, 스프링 부트가 등장하면서 대부분 사용하지 않게 되었다.


스프링 컨테이너는 Beanfactory와 , 이를 extends 한 ApplicationContext 두 종류의 인터페이스로 구현되어 있다.
주로 사용되는 스프링 컨테이너는 애플리케이션 컨텍스트이다.

BeanFactory
빈 팩토리(BeanFactory)는 스프링 컨테이너의 최상위 인터페이스이다.
BeanFactory는 빈을 등록, 생성, 조회 등의 빈을 관리하는 역할을 하며, getBean() 메서드를 통해 빈을 인스턴스화 할 수 있다.
@Bean 어노테이션이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용하여 빈 등록을 한다.
 
ApplicationContext
: BeanFactory의 기능을 상속받아 제공한다.
: 따라서, 빈을 관리하고 검색하는 기능을 BeanFactory가 제공하고, 그 외의 부가 기능을 제공한다.

부가 기능

MessageSource : 메시지 다국화를 위한 인터페이스
EnvironmentCapable : 개발, 운영, 환경변수 등으로 나누어 처리하고, 애플리케이션 구동 시 필요한 정보들을 관리하기 위한 인터페이스
ApplicationEventPublisher : 이벤트 관련 기능을 제공하는 인터페이스
ResourceLoader : 파일, 클래스 패스, 외부 등 리소스를 편리하게 조회


IoC 컨테이너 역할

의존성 주입(DI)을 통해 애플리케이션의 컴포넌트를 관리할 수 있게 헤즌다.


------------------------------------------------------------------------------------------------------------------------------------------------------
자동 import >> ctrl + shift + O 이다
자동 완성 >> ctrl + shift 
	: 이를 통해 새로운 클레ㅐ스를 ㅡㅆㄹ땐 자동  import 까지 해쥰다.


 Invalid project description - overlaps the location of another project 나오는 거
	: Maven Project 만들떄 WorkSpace 를 default 로 자동 체크 되어있는걸 풀고 걍 내가 직접 워크 스페이스를 지정하면 에러가 나는데 그건 
		: workspace 가 아닌 곳엣서 import 한 후에 파일ㅇ르 workspace 로 옮겨 import 할 경우 발생한다.


의존성의 예시
	: 컴터 게임할때 키보드 와 마우스가 없으면 겡임을 못한다. 컴터 게임은 마우스와 킵보드에 의존한다.
