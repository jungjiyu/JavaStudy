

	: 람다식에서 지역변수 쓸때 조심해야된다.
		: 수정을하면 에러가 난다
			: 지역변수는 메서드 호출이끝나면 사라지는데 익명 클래스 내부의 경우 지역변수를 내부적으로 상수 처리한다.
				: 출력은 상관 없다

	: java.util.function 패키지 에 있는 자주 쓰이는 함수형 인터펭스 . 리턴 쓰는거 아니다!
		Supplier<T> T get(){ 어떤식 }
			: 매개변수가 없고 값을 반환할때에 사용. 
		Consumer<T> void accept(T t){ 어떤식 }
			: 매개변수를 받아서 소비하고 반환값이 필요 없을때 사용
		Function<T,R> R apply(T t){ 어떤식 }
			: 매개변수타입과 반환 타입을 모두 지정 해야할 때 사용
				
		Predicate<T> boolean test (T t){  조건식 ; }
			: 매개변수받아서 조건검사하여 불값 반환할때 사용

		UnaryOperator<T> T apply (T t){ 어떤식 }
			: 동일한 반환 , 매개변수값 사용함


: Function 의 합성
	: functoin 의 경우 합성을 지원해주는 메서드가 있다
	:   x ->g(x) -> f(g(x))

	1. 첫번째로수행할거.andThen(두번째로 수행할 거);
	2. 두번째로 수행할 거.compose(첫번쨰로수행할거)
		: 다른 함수를 실행한 다음에 현재함수를 실행
	
: Predicate 의 합성
	: 논리 조합을 위한 메서들를 제공. 얘로 결합 구현 가능 << 논리 조합
		1. and 연산 >> 대상1.and(대상2)
		2. or 연산 >> 대상1.or(대상2)
		3. not 연산 >> 대상.negate( );
			: 뒤지븜
	: 데이터의 필터링. 검증할떄 자주 씀'


메서드 참조 : 람다식을 더 간단하게 대체 가능
	:  람다식을 "대체"가능한 것이란 표현에서 알 수 있다 싶이 이를 받는 레퍼런스 변수는 걍 람다식을 쓸때처럼 함수형 인터페이스 타입으로 쓰면 된다.
		: 인터페이스타입의레퍼런스변수.추상메서드명(arg1,...); 로 그 메서드를 활용하는 거다
			: 그러니까 구현 클래스 없이 해당 인터페이스의 익명 구현 객체를 만드는데, 그 객체는 다른 클래스의 메서드의 실행 내용을 똑같이 실행내용으로하는 추상메서드를 가지고 있는거다.

	: 항상 람다식을 대체 가능하단 건 아니고 람다식 내부에서 단순히 다른 클래스의 메서드를 활용하는 경우에 말하는 거임 
		: 람다식에서 다른 클래스의 메서드를 사용하는게 아니라 걍 함수형 인터페이스 내부의 추상 메서드를 구현하는거면 이 방법 못씀
		: 쓸 수 있는 경우 ex)

			@FunctionalInterface
			interface exInterface1{
				int add(int x, int y)
				}

			class exCalss1{

				public static void addmthd(int x, int y) {
						return x+y;
				}
			}			


			public class Main{
			public static void main(String[] args){
			// 람다 로 표현하면
			exInterface1 ei = ( x , y )-> exClass.addmthd( x , y ) ;  // 별도로 추가한 것 없이 순수하게 다른 클래스의 메서드를 이용하여 계산
	
			// 메서드 참조로 표현하면
			exInterface1 ec = exClass1::addmthd ; // ec가 addmthd 를 참조한다
			int result1 = ei.add(10,20);
			int result2 = ec.add(10,20);

			}
			}


	: 종류
		: 정적메서드 참조하는 법 ) 클래스명::정적메서드명
		: 인스턴스메서드 참조하는 법 )  해당메서드를포함하는클래스타입의객체참조변수명::인스턴스메서드명
		: 생성자 참조하는 법 )  클래스명::new
			: 생성자도 걍 인터페이스의 추상 메서드명으로 씀 되는거다




Stream 
	: 걍 스트림이라고만 하면 컬렉션이랑 배열을 처리하는 거지.  입출력 스트림이랑 다른거다	
	: 여러 자료에 대한 기능을 구현해놓은 클래스로 스트림을 활용하면 배열 , 컬렉션등의 자료를 일관성있게 처리가능. 그러니까 데이터를 효율적으로 일관적이게 처리하기 위함.

	: Arrays
		: 요소를 하나씩 출력하는 forEach 사용 가능


	:Stream 연산
		: 종ㄹ ㅠ
			: 중간연산 << 보조 느낌임
				: 자료를 거르거나 변경하여 또다른 자료를 내부적 생성
				: 옵션이다 
				:filter( 조건)
					: 조건을 넣고 조건이 참인 경우만 실행하는 경우에 사용
					ex) 
		String[] ary2 = {"ape","bannana","tomato","fizzi"};
		Arrays.stream(ary2).filter(str->str.length() >=5).forEach(System.out::println);
	
			: 최종연산
				: 내부 자료를 소모해가며 연산을 수행하여 마지막에 한번만 호출
				: 반드시 필요하다

		: 
