 select * from yayTest

UPDATE 테이블명 SET  컬럼1 = 변경할 값, 컬럼2 = 변경할 값 WHERE 조건;
insert into YayTest values ('김김김', 17 , 'naver@naver.com' );
delete from YayTest where ageXX <=20;
-------------------------------------------------------


데이터 수정하고 나서 session 객체의ㅣ 데이터도 수정해야하는거 잊음 안됨
	: session 객체에 저장되있던 dto 객체를 불러와서 그걸 setter 로 수정하는 것보다는 이미 수정된  dao 객체의 getMember( ) 를 통해 dto 를 받고 그걸로 바로 업데이트 하는게 훨 낫다


DTO 는 운반책이지, 실제 데이터 가 아니다
	: null 값 항목 담긴 dto 를 전달했다고 해서 그 행에 실제로 null 값이 저장되게 되는게 아니다.
	: 실제 데이터는 dto 객체에 담겨져온 데이터 덩어리중 활용 원하는 값을 선별하여 쿼리문에 넣어 업데이트 하고 그러는거다

	: 물론 주의해야할 것은 애플리케이션에 저장되는 객체인 session 의 경우엔 arg 로 넣는 dto 객체 그 자체가 저장되는거라 완전한 값을 갖춘 dto 객체를 arg 로 해야된다.



회원탈퇴 과정에서 직접 session.invalidate( ) 하는것보다 logout 페이지로 옮겨서 실행하는게 훨 낫다


코드 개선
	:  중복된느 부분은 아예 메서드로 만들자
	private void close(ResultSet rs , PreparedStatement pstmt, Connection conn ) {
		try{
			if(rs!= null) rs.close();
			 if (pstmt != null) pstmt.close();
			 if (conn != null) conn.close();
		}catch(Exception e){}
	}


자바빈에서 범위를 application 으로 설정했음 application 객체를 통하여 그걸 뽑아와야된다.
	: 다른 페이지에서 그냥 getProperty 속성을 통해서 가져오려고 하는 건 안통한다
	: ex ) 
		<%
			loginInfo ins = (loginInfo)application.getAttribute("bean");
			out.print(ins.getId());
		%>


response.sendRedirect 랑 window.location 섞어씀 오류난다
	: 스크립트 문 내부에 스크립트릿 못쓰고 걍 스크립트 문만 써야된다고 한다

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

커넥션풀 DBCP
	: ( 매번 request 마다 connection 객체를 만드는게 아니라.  어차피 매번 생성해야되는거) Connection 객체을 미리 만들어놓고. 필요할 때마다 빌려서 사용하고 반환해주는 것
		: 웹 서버가 db 에 접속할때 request 가 넘 많을 경우 발생하는 과부하를 방지하는 거다
		: 잊지 않았겠지만 우리가 매번 하던 작업은 아래와 같았었는데 이걸 안해도 된다는거다
			 Class.forName(driver);
    			conn = DriverManager.getConnection(dbURL,dbID,dbPW);

	: 하는 법 
		step1. 
			context.xml 에 아래의 코드를 적는다
    <Resource auth="Container"
    	name="jdbc/oracle"
    	driverClassName="oracle.jdbc.OracleDriver"
    	type="javax.sql.DataSource"
    	url="jdbc:oracle:thin:@localhost:1521:xe"
    	username="C##JAVAUSER"
    	password="java2024"
    	loginTimeout="10"
    	maxActive="50"
    	maxIdle="20"
		maxWait="2000"
		testOnBorrow="true"/> 

		
				: Resource 태그의 속성  
					(1) name
						: 이거 개중요. 자원 태그의 이름 설정해놓은 것
							: 이후 코드에서 해당 커넥션 풀을 JNDI 를 이용하여 구할 때 name 을 기준으로 구하기 때문에 중요




				: 보면 우리가 매번 해야했었던 
					 Class.forName(driver);
    					conn = DriverManager.getConnection(dbURL,dbID,dbPW);
				부분에 들어가는 driver , dbURL , dbID , dbPw 등을 정의하는 것임을 볼 수 있따
					: 따라서 이걸 쓰면 driver,  dbURL  , dbID , dbPW 를 정의한 String 이 따로 필요가 없다

	
		step2.
			자바 소스 코드에서 DataSource 객체를 생성해서 그걸로 Connectionpool 을 관리하는 객체를 담아서 사용한다

			(1)

	private DataSource ds;
		: DataSource 객체는 Connection pool 을 관리하는 객체.
		: 이 객체는 JNDI (Java Naming and Directory Interface ) API 를 통해서 이용된다.
			: JNDI >> 외부 디렉터리 서비스의 데이터를 "이름" 을 가지고  얻기 위한 자바API
				: API  Application Programming Interface 
					: 어플리케이션 을 사용,제어할 수 있도록 운영체제 || 프로그래밍 언어가 제공하는 인터페이스
				: 우리가 application 이나 session 에서 이름을 통해 얻어와었던 것도 이거에 해당
	: db 를 다룰 때 사용한 Connection 객체, Statement 객체 같은 자원들을 효율적으로 사용하기 위한 방법

우리가 연결하고 싶은 데이터베이스의 DB Pool을 미리 Naming 시켜주는 방법 중 하나이다. 우리가 저장해놓은 WAS 의 데이터베이스 정보에 JNDI를 설정해 놓으면 웹 애플리케이션은 JNDI만 호출하면 간단해진다.


			: lookup(== 참고)


	: 할당
	
	private memberDAO() {
		try {
			Context context =new InitialContext();
			ds = (DataSource)context.lookup("java:comp/env/jdbc/oracle"); // 이름으로 해당하는 객체를 얻을 수 있다
			//반환 타입이 obj 임
		}catch(Exception e) {e.printStackTrace();}
	}



	: 활용
    		conn = ds.getConnection();


톰캣 기본 폴더 구조
https://hamdi.tistory.com/23
	Servers/tomcat
		(1) bin >> tomcat 실행에 필요한 바이너리 파일
		(2) common >> 웹 어플리케이션에서 공통적으로 사용하는 클래스 파일
		(3) conf >> 서버 전체 설정 파일
			****1. server.xml
		(4) logs >> 예외 발생 등의 로그 저장
		(5) server >> 서버에서 사용하는 클래스 라이브러리
		(6) temp >>임시 저장용 폴더
		(7) webapps >> 웹 어플리케이션 루트 폴더
			: 이 디렉터리의 하위 디렉터리들( docs, manager ... 등 )은 모두 아래의 디렉터리를 포함한다
				1. WEB-INF : 웹 어플리케이션 설정 및 참조 클래스 파일
					(1) classes  디렉터리 
						:  java class 파일들을 포함
					(2) lib 디렉터리
						:  jar 라이브러리를 포함
					****(3) web.xml 파일

				2.  META-INF 	
					****(1) context.xml 파일

		(8) work >> jsp 파일을 서블릿 형태로 변환한 java 파일과 class 파일 저장

context
	: 톰캣에서 구동되는 하나의 웹 어플리케이션 자체.
	: context 와 관련한 

 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------


EL(Expression Language) 표현식
	: 동적으로 데이터를 출력하거나 변수에 접근하기 위해 사용되는 방법
	: JSP 페이지에서 Java 코드를 작성하지 않고도 데
	: 형식 ) ${ } 
		: 중괄 호 내부에변수, 메서드 호출, 연산 등의 표현식을 사용한다
			: 그냥 단순 print.out 하기 위해서 쓰는거라면 <%= %> 과 다를 게 없긴 함
		: 정수, 실수 ,논리 , 문자열, 널을 표현 가능
			: 문자열의 경우 " 혹은 ' 모두 사용 가능
	 
	: 객체의 프로퍼티 값을 꺼낼때 주로 사용된다
	: JSP 가 실행될 때 즉시 반영됨	

ex)  
정수: ${100}<br>
실수: ${3.14}<br>
논리: ${true}<br>
문자열: ${'문자열'}<br>
논리: ${null}<br>
산술: ${1+2}<br>
비교: ${1>3}<br>
논리: ${1<3 &&3<8}<br>
삼항: ${1==1?100:-100}<br>



JSP 내장 객체
	page
		: 현재 jsp 페이지를 구현한 "자바" 클래스 객체
			: 자바 기반 코드에서 뭐 하고자 할떄 쓴다. 근데 pageConexxt 를 더 많이 쓴다 
		: java.lang.Object 클래스의 객체

	pageContext
		: jsp 페이지에 대해 1:1 로 연결된 객체. 
			: 각 jsp 페이지 당 하나의 pageContext 객체가 생성되있음
		: 특정 jsp 페이지 내의 객첼 공유하거나, 페이지 흐름을 제어할 떄 사용
		: javax.servlet.jsp.PageContext
		:  메서드
			1. 내장 객체 반환  메서드
				: 이 메서드 들은 jsp 페이지가 자동적으로 servlet 으로 변환될때 기본 객체들을 생성하는데 사용되고, 우리가 직접 사용할 수 있다.
				: 주의 )  <%! %> 전역 전언문 안에서는 사용할 수 없는데 그 이유는 서블릿으로 변환될때 기본객체들이 _jspService() 라는 메서드의 지역변수로 생성되기 때문
				(1) ServletRequest getRequest()
				(2) ServletResponse getResponse( ) 
				(3) HttpSession getSession( ) 
				(4) Object getPage( )
				(5) JspWriter getOut()
				(6) ServletContext getServletContext()
					: application 기본 객체를 반환한다
				(6 )ServletConfig getServletConfig( )
					: config 기본 객체를 반환합니다.

				(7) Exception getException()

			2. 흐름제어 메서드
				void forward(String relativeUrlPath)
				void include(String relativeUrlPath)


	application
		: javax.servlet.ServletContext 의 객체






EL 내장 객체
	(1) pageScope >> page 객체를 참조하는 객체
	(2) requestScope >> request 객체를 참조하는 객체
	(3) sessionScope >> session 객체를 참조하는 객체
	(4) applicationScope >> application 객체를 참조하는 객체

${applicationScope.appliNam }<br>
${requestScope.reqNam }<br>
${sessionScope.sessionNam }<br>
${pageScope.pagNam}<br>


${appliNam }<br>
${reqNam }<br>
${sessionNam }<br>
${pagNam}<br>
	: 사실 이름만 써도 실행이 가능하긴 한다. 근데 비추다( 규모가 커지면 서치하는 시간이  넘 길엊지니까)
		: 도트 연삱자로 대상을 정하면 그 범위 내에서만 서치하게 되는 것
	: 맨 처음 application 을 돌고 >> session 돌고 >> requset 돌고 >> page 도는 순으로 찾고 있음 get 한다.



	(5) param >> 요청 파라미터를 참조하는 객체
		: 태그의 name 속성값을 이용하여 접근
		: 방법
			1. 도트연산자사용>> ${param.id }<br>
			2. 대괄호 사용 >> ${param["id"]}<br>	
		
 복습 ) 
.






request 객체에도 setAttribute 를 통하여 이름과 값을 매핑하여 request 객체에 바인딩 할 수 있다

attrivute vs parameter
	attribute : 개발자가 코딩으로 설정하는 값
		: request 뿐 아니라 session , context 등을 대상으로 바인딩 가능
		: String외에 Object, Array 등 다양한 데이터 값 저장 가능

	parameter : 브라우저(사용자)에서 넘어온 값
		:  request 객체를 대상으로만 바인딩 가능
		: 그래서 HttpServletRequest 명세를 보면 setAttribute 는 있지만 setParameter 는 없다.




--------------------------------------------------------------------------------------------------------------

response 객체를 사용하기만 하면 그걸로 연결이 종료된느게 아니라 해당 웹 페이지가 다 끝나야 종료되는 것 같다. 당장 servlet 만해도 
		PrintWriter out = response.getWriter();
		out.print("<!DOCTYPE html>");
		out.print("<html>");		
		out.print("<head>");

보면 알 수 있다싶이 클라이언트를 향하여 여러번 response 를 날렸다고 해서 다음 out.print 문이 실행되지 않는건 아니다 

<%
out.print("hehehehe");
a = 10;
request.setAttribute("num",10);
Cookie cookie = new Cookie("temp","10");
cookie.setMaxAge(60*60);
response.addCookie(cookie);
%>
<jsp:forward page="page2.jsp"/>


session 내장객체
	: javax.servlet.http.HttpSession 인터페이스의 객체이다.

일단 에러가 나는 이유는
	>> invalidate 쓰면 서버 상에선 제대로 없어지겠지. 그런데 여전히 브라우져에 남아있잖아. 그래서 일단 쿠키를 가져온다음에 수정해줘야지.
taglib 지시자 >> jst l 을 사용하기 위해 지정하는 것. 
 


