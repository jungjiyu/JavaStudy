 select * from yayTest

UPDATE 테이블명 SET  컬럼1 = 변경할 값, 컬럼2 = 변경할 값 WHERE 조건;
insert into YayTest values ('김김김', 17 , 'naver@naver.com' );
delete from YayTest where ageXX <=20;
-------------------------------------------------------


데이터 수정하고 나서 session 객체의ㅣ 데이터도 수정해야하는거 잊음 안됨
	: session 객체에 저장되있던 dto 객체를 불러와서 그걸 setter 로 수정하는 것보다는 이미 수정된  dao 객체의 getMember( ) 를 통해 dto 를 받고 그걸로 바로 업데이트 하는게 훨 낫다


DTO 는 운반책이지, 실제 데이터 가 아니다
	: null 값 항목 담긴 dto 를 전달했다고 해서 그 행에 실제로 null 값이 저장되게 되는게 아니다.
	: 실제 데이터는 dto 객체에 담겨져온 데이터 덩어리중 활용 원하는 값을 선별하여 쿼리문에 넣어 업데이트 하고 그러는거다

	: 물론 주의해야할 것은 애플리케이션에 저장되는 객체인 session 의 경우엔 arg 로 넣는 dto 객체 그 자체가 저장되는거라 완전한 값을 갖춘 dto 객체를 arg 로 해야된다.



회원탈퇴 과정에서 직접 session.invalidate( ) 하는것보다 logout 페이지로 옮겨서 실행하는게 훨 낫다


코드 개선
	:  중복된느 부분은 아예 메서드로 만들자
	private void close(ResultSet rs , PreparedStatement pstmt, Connection conn ) {
		try{
			if(rs!= null) rs.close();
			 if (pstmt != null) pstmt.close();
			 if (conn != null) conn.close();
		}catch(Exception e){}
	}


자바빈에서 범위를 application 으로 설정했음 application 객체를 통하여 그걸 뽑아와야된다.
	: 다른 페이지에서 그냥 getProperty 속성을 통해서 가져오려고 하는 건 안통한다
	: ex ) 
		<%
			loginInfo ins = (loginInfo)application.getAttribute("bean");
			out.print(ins.getId());
		%>


response.sendRedirect 랑 window.location 섞어씀 오류난다
	: 스크립트 문 내부에 스크립트릿 못쓰고 걍 스크립트 문만 써야된다고 한다

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

커넥션풀 DBCP
	: ( 매번 request 마다 connection 객체를 만드는게 아니라.  어차피 매번 생성해야되는거) Connection 객체을 미리 만들어놓고. 필요할 때마다 빌려서 사용하고 반환해주는 것
		: 웹 서버가 db 에 접속할때 request 가 넘 많을 경우 발생하는 과부하를 방지하는 거다
		: 잊지 않았겠지만 우리가 매번 하던 작업은 아래와 같았었는데 이걸 안해도 된다는거다
			 Class.forName(driver);
    			conn = DriverManager.getConnection(dbURL,dbID,dbPW);

	: 하는 법 
		step1. 
			context.xml 에 아래의 코드를 적는다
    <Resource auth="Container"
    	name="jdbc/oracle"
    	driverClassName="oracle.jdbc.OracleDriver"
    	type="javax.sql.DataSource"
    	url="jdbc:oracle:thin:@localhost:1521:xe"
    	username="C##JAVAUSER"
    	password="java2024"
    	loginTimeout="10"
    	maxActive="50"
    	maxIdle="20"
		maxWait="2000"
		testOnBorrow="true"/> 

		
				: Resource 태그의  name 속성	
					: 이거 개중요. 자원 태그의 이름 설정해놓은 것
						: 이후 코드에서 해당 커넥션 풀을 JNDI 를 이용하여 구할 때 name 을 기준으로 구하기 때문에 중요




				: 보면 우리가 매번 해야했었던 
					 Class.forName(driver);
    					conn = DriverManager.getConnection(dbURL,dbID,dbPW);
				부분에 들어가는 driver , dbURL , dbID , dbPw 등을 정의하는 것임을 볼 수 있따
					: 따라서 이걸 쓰면 driver,  dbURL  , dbID , dbPW 를 정의한 String 이 따로 필요가 없다

	
		step2.
			자바 소스 코드에서 DataSource 객체를 생성해서 그걸로 Connectionpool 을 관리하는 객체를 담아서 사용한다

			(1)
	private DataSource ds;
		: DataSource 객체는 Connection pool 을 관리하는 객체.
		: 이 객체는 JNDI (Java Naming && Directory Interface ) API 를 통해서 이용된다.
			: JNDI >> "이름" 을 가지고 데이터 베이스 정보(겍체) 를 얻을 수 있는 API
				: 우리가 application 이나 session 에서 이름을 통해 얻어와었던 것도 이거에 해당
	: db 를 다룰 때 사용한 Connection 객체, Statement 객체 같은 자원들을 효율적으로 사용하기 위한 방법



	: 할당
	
	private memberDAO() {
		try {
			Context context =new InitialContext();
			ds = (DataSource)context.lookup("java:comp/env/jdbc/oracle"); // 이름으로 해당하는 객체를 얻을 수 있다
			//반환 타입이 obj 임
		}catch(Exception e) {e.printStackTrace();}
	}



	: 활용
    		conn = ds.getConnection();


톰캣 기본 폴더 구조
https://hamdi.tistory.com/23
	Servers/tomcat
		(1) bin >> tomcat 실행에 필요한 바이너리 파일
		(2) common >> 웹 어플리케이션에서 공통적으로 사용하는 클래스 파일
		(3) conf >> 서버 전체 설정 파일
			****1. server.xml
		(4) logs >> 예외 발생 등의 로그 저장
		(5) server >> 서버에서 사용하는 클래스 라이브러리
		(6) temp >>임시 저장용 폴더
		(7) webapps >> 웹 어플리케이션 루트 폴더
			: 이 디렉터리의 하위 디렉터리들( docs, manager ... 등 )은 모두 아래의 디렉터리를 포함한다
				1. WEB-INF : 웹 어플리케이션 설정 및 참조 클래스 파일
					(1) classes  디렉터리 
						:  java class 파일들을 포함
					(2) lib 디렉터리
						:  jar 라이브러리를 포함
					****(3) web.xml 파일

				2.  META-INF 	
					****(1) context.xml 파일

		(8) work >> jsp 파일을 서블릿 형태로 변환한 java 파일과 class 파일 저장

context
	: 톰캣에서 구동되는 하나의 웹 어플리케이션 자체.
	: context 와 관련한 

 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------


EL(Expression Language) 표현식
	: 동적으로 데이터를 출력하거나 변수에 접근하기 위해 사용되는 방법
	: JSP 페이지에서 Java 코드를 작성하지 않고도 데
	: 형식 ) ${ } 
		: 중괄 호 내부에변수, 메서드 호출, 연산 등의 표현식을 사용한다
		: 정수, 실수 ,논리 , 문자열, 널을 표현 가능
			: 문자열의 경우 " 를 사용하나 ' 를 사용하나 별 차이 없음
	: 객체의 프로퍼티 값을 꺼낼때 주로 사용된다
	: JSP 가 실행될 때 즉시 반영됨	

ex)  
정수: ${100}<br>
실수: ${3.14}<br>
논리: ${true}<br>
문자열: ${'문자열'}<br>
논리: ${null}<br>
산술: ${1+2}<br>
비교: ${1>3}<br>
논리: ${1<3 &&3<8}<br>
삼항: ${1==1?100:-100}<br>


EL 내장 객체
	(1) pageScope >> page 객체를 참조하는 객체
	(2) requestScope >> request 객체를 참조하는 객체
	(3) sessionScope >> session 객체를 참조하는 객체
	(4) applicationScope >> application 객체를 참조하는 객체

${applicationScope.appliNam }<br>
${requestScope.reqNam }<br>
${sessionScope.sessionNam }<br>
${pageScope.pagNam}<br>


${appliNam }<br>
${reqNam }<br>
${sessionNam }<br>
${pagNam}<br>
	: 사실 이름만 써도 실행이 가능하긴 한다. 근데 비추다( 규모가 커지면 서치하는 시간이  넘 길엊지니까)
		: 도트 연삱자로 대상을 정하면 그 범위 내에서만 서치하게 되는 것
	: 맨 처음 application 을 돌고 >> session 돌고 >> requset 돌고 >> page 도는 순으로 찾고 있음 get 한다.



	(5) param >> 요청 파라미터를 참조하는 객체
		: 태그의 name 속성값을 이용하여 접근
		: 방법
			1. 도트연산자사용>> ${param.id }<br>
			2. 대괄호 사용 >> ${param["id"]}<br>	
		



request 객체에도 setAttribute 를 통하여 이름과 값을 매핑하여 request 객체에 바인딩 할 수 있다

attrivute vs parameter
	애트리뷰트
		: request 뿐 아니라 session , context 등을 대상으로 바인딩 가능
		: String외에 Object, Array 등 다양한 데이터 값 저장 가능

	파라미터
		:  request 객체를 대상으로만 바인딩 가능



애트리뷰트가 좀더 유연함



파라미터는 HTML의 form 데이터 전송시 key/value 쌍으로 사용된다.



parameter : 브라우저(사용자)에서 넘어온 값

attribute : 개발자가 코딩으로 설정하는 값

그래서 HttpServletRequest 명세를 보면 setAttribute 는 있지만 setParameter 는 없다.




--------------------------------------------------------------------------------------------------------------

taglib 지시자 >> jst l 을 사용하기 위해 지정하는 것. 
 


