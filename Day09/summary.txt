자바에선 어떤 기능을 구현하든 클래스에서만 구현 가능한 특징을 가짐

함수 >> 구현과 호출만으로 뭐 할 수 있다


람다를 통해서 함수형 프로그래밍을 할 수 있다

람다 == 메서드를 하나의 식으로 간략하면서도 명확하게 표현한것
	: 기본문법 )
		(매개변수1, 매개변수2 ...선언 ) ->{실행문}
	: 이름이 없는 익명 함수 (익명 메서드)를 만드는 것
	: 추가적으로 가능한 문법)
		1. 추론할 수 있는 타입인 경우 매개변수의 타입을 생략가능
			ex) (int a, int b) -> {return a+b ;} ==  심지어 (a,b) -> {return a+b; }

		2. 매개변수가 하나인데 매개변수 타입 명시되있지 않으면 괄호 생략 ㄱ가능
			ex) a-> { a*a; } 

		3. 실행 내용이 한 문장밖에 안될 경우 
			3.1 "리턴 값"이 없으면 중괄호 생략 가능
				ex) a -> a*a
			3.2 걍 세미콜론 생략가능
				ex ) (a,b) -> {return a>b?a:b }


		4. 중괄홍 없이 쓰고 싶음 표현식으로 바꿔쓰자
			ex) (a,b)-> a>b  ? a:b

	: 클래스 외부서도 쓸 수 있다
	: 람다식 타입 == 함수형 인터페이스
	: 람다식 만들고 활용하기
		step1. 함수형 인터페이슷생성
				: 함수형 인터페이스) 내부에 추상메서드 하나밖에 없는 인터페이스
					: 안그럼 헷갈려서 람다식을 어케 할당하냐
		stpe2. 인터페이스에 람다식으로 구현할 메서드 선언 후 인터페이스 타입의 레퍼런스 변수에 할당
			: 그런데 일반적인 인터페이스와 다른것은 구현 클래스를 만들지 않고, 바로 인터페이스 타입의 변수를 선언학고 람다식을 할당하여 레퍼런스변수명.추상메서드명 으로 쓴다
				: 매개변수로도 전달 할 수도 있고 반환도 가능하다(변수에 할당 가능하니까)
		
			
			interface Number{
				public int getMax(int num1, int num2);
			}

			public class Ex1 {
				public static void main(String[] args) {
					// 두 수중 큰 수를 반환하는 람다식
					Number max = (x,y) -> (x >= y) ? x : y ; 
					System.out.println(max.getMax(10, 20));
				}
			}			


	: 람다식은 익명객체이다
	: 원래는 참조변수 없이(객체 생성 없이) 메소드를 호출할수 없는데 객체 ㅅ생성없이 메서드 호출할 수 있게 해준다!!

	: 어노테이션
		함수형 인터페이스를 정의할때 @FunctionalInterface 어노테이션과 함께 선언하면 자바 컴파일러가 함수형 인텨페이스 정의를 검증해줌

			@FunctionalInterface	
			interface 인터페이스명{
				추상메서드하나
			}



	
	: 람다식이 어떻게 구현될까
		익명 클래스 
			: 이름이 없는 클래스
			: 객체 사용 시에 클래스의 선언과 객체 생성이 동시에 이뤄지며 , 일회성으로 딱 하나의 객체만 필요한 경우 사용
			: 형식)
				부모클래스명 변수명 = new 부모클래스명(매개변수 ){ 내용구현};
				인터페이스명 변수명 = new  인터페이스명(매개변수){내용구현};

				: 익명객체 생성할때에 부모의 생성자에 매개변수도 넣을 수 있다

	:자바 == 객체 지항 언어 >> 객체를 만들어야쓸 수 있다
		: 컴터 내부에서 익명 클래스가 생성되어 익명 객체가 생성되는거다

	 : 아까전에 람다식도 익명 객체라고ㅗ 했었던 것처럼 사실 내부적으론 아래와 같은 꼴인거다
		: 그러니까 익명 구현 객체인거다

package chap04;

interface Catable{
	public String catString(String s1, String s2);
}
public class Activate {
	public static void main(String[] args) {
		String s1 ="hello";
		String s2 ="hello";
		
		//2. 클래스 사용
		Catable connection = new Catable() {
			@Override
			public String catString(String s1, String s2) {
				return s1+s2;
			}
		};
		
		String str = connection.catString(s1, s2);
		System.out.println(str);
	}

}

	: 람다식 구현할때 객체 생성 없이 메서드 호출이 가능한 이유는 람다식을 생성 하는 순간 내부적으로 익명 구현 객체를 만들기 때문에 그런거다

	: 람다식에서 지역변수 쓸때 조심해야된다.
		: 수정을하면 에러가 난다
			: 지역변수는 메서드 호출이끝나면 사라지는데 익명 클래스 내부의 경우 지역변수를 내부적으로 상수 처리한다.
				: 출력은 상관 없다

	: java.util.function 패키지 에 있는 자주 쓰이는 함수형 인터펭스 . 리턴 쓰는거 아니다!
		Supplier<T> T get(){ 어떤식 }
			: 매개변수가 없고 값을 반환할때에 사용. 
		Consumer<T> void accept(T t){ 어떤식 }
			: 매개변수를 받아서 소비하고 반환값이 필요 없을때 사용
		Function<T,R> R apply(T t){ 어떤식 }
			: 매개변수타입과 반환 타입을 모두 지정 해야할 때 사용
				
		Predicate<T> boolean test (T t){  조건식 ; }
			: 매개변수받아서 조건검사하여 불값 반환할때 사용

		UnaryOperator<T> T apply (T t){ 어떤식 }
			: 동일한 반환 , 매개변수값 사용함


: Function 의 합성
	: functoin 의 경우 합성을 지원해주는 메서드가 있다
	:   x ->g(x) -> f(g(x))

	: 첫번째로수행할거.andThen(두번째로 수행할 거);
		




