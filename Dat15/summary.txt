 파일 끝까지 읽는 tip	
		: count 를 사용하여 평소엔 읽어온 값ㅇ의 개수 저장하다 eof 에서 -1 입력 받음 종료함

			int count = 0 ;
			while(  (count = 스트림객체.read( 어쩌구) ) != -1 ) {

			
			}


		: close( )를 제외한 입력 스트림의 메서드는 모두( 바이트 스트림이건 문자 스트림이건) 
			: 메서드 종류 
				: ( close( ) 제외하고 )  죄다 read( 어쩌구 ) 꼴
					: flush( ) 가 없다 

			: 반환
				: 반환 타입 ) int 형이다
				: 반환값
					1. eof 에 도달하면 -1 을 반환한다
					2. eof 가 아니면 
						(1) arg 가 없는 read ( ) 를 제외하곤 읽는데 성공한 값의 개수를 반환한다 << 주로 conunt 변수로 이를 저장해둔다
						(2) arg 가 없는 read( ) 의 경우 읽은 값을 반환한다 (int 형으로)

		: 출력 스트림의 메서드  <<반환 타입이 죄다 void 이다
			: 메서드의 종류
				1. write ( 어쩌구 ) 꼴
					: 어쩌구 << 스트림따라 char타입값 혹은 byte타입값
				2. close ( )
				3. flush( )

 
			: 
			
-----------------------------------------------------------------------------
				b= new byte[1000];
				try(InputStream fis = new FileInputStream("C:/SelfStudyJava/chap14/binarytest.db")){ // try 문 종료시 자동으로 .close() 실행됨 
				
					int n ; // 몇개 읽었는지 저장하는 변수
					
					while((n= fis.read(b)) != -1) { // 배열크기단위로 읽어온다 && 파일의 끝을 만나면 종료한다
						System.out.println("한번에 읽어온 데이터 수: "+(n));
						for(int j =0 ;j < n ; j++) { // 읽어온 데이터 개수 만큼 반복문 반복하며 값 뽑는다
							System.out.print((char)b[j]);
						}
					}
					
					
				}catch(IOException e){
					e.printStackTrace();
				}
-----------------------------------------------------------------------------

public class Activate {
	public static void main(String[] args) {
		long startTime = System.currentTimeMillis();
		try(Reader fr = new FileReader("c:/DailyJava2/song.txt");BufferedReader br= new BufferedReader(fr) ){
			String line; 
			while(( line= br.readLine()) != null) {
				System.out.print(line);
			}
		}catch(IOException e) {}
		
	}
}

-----------------------------------------------------------------------------

ex) OutputStream fos = new  FileOutputStream(경로); Writer osw = new OutputStreamWriter( fos ); 

-----------------------------------------------------------------------------

(1) 기반 스트림
	1. 바이트 기반 스트림
		]: 바이너리 데이터를 읽고 출력할 때 사용 << 데이터 형태 그대로 저장
		: 세부 종류
			(1) (바이트)입력스트림
				: 최상위 클래스 ) InputStream
					: 추상클래스다
						: 메서드종류
							int read( )
								: 1 바이트를 읽고, 읽은 값의 int 타입버전값 혹은 -1을 리턴
									: -1 == EOF 나타내는 값
									: 이거 이용해서 파일 끝까지 읽을 수 있다


							int read(byte[ ] b)
								: 읽은 값은 "매개값으로 주어진 배열"에 저장하고, 읽은 바이트 수를 "반환"한다
											
					: 하위 클래스
						: InputStream 의 구현 클래스들
							FileInputStream
							BufferedInputStream
							DataInputStream

									
									


			(2) (바이트)출력스트림	
				: 최상위 클래스 ) OutputStream
					: 추상 클래스
					: 메서드
						1. abstract void write( int b )
						2. void write( byte[ ] b)
							: 매개값으로 주어진 배열 b 의 "전체"를 "한번에" 출력한다
								: 배열이 끝까지 채워져있던 말건간에(null 값이던 아니던) 배열 전체 사이즈를 출력하는거 주의  

						3.  void write( byte[ ] b , int off , int len)
								: 매개값으로 주어진 배열 b에서 b[off] 부터 len 개의 내용을 출력한다(배열의 일부를 출력한다)

						4. void flush( )
							: 출력 버퍼가 다 차지 않아도 잔류하는 모든 바이트를 출력한다


						5. close ( )
							: 출력 스트림을 닫는다 + flush 기능 수행한다
											
				: 하위 클래스
					FileOutputStream
					PrintStream
										

		2. 문자 기반 스트림
			: 텍스트 데이터를 주고 받을 때 사용

			: 세부 종류
				(1) (텍스트)입력스트림
					: 최상위클래스 ) Reader
						: 추상클래스
						: 메서드)
							: 문자 배열 단위로 불러올 순 있어도 문자열 단위론 못불러옴 << 문장 단위로 받아오고 싶다묜 보조스트림 사용
							int read( ) 
								: 1개의 문자를 읽고 이를 int 타입으로 리턴
								: 반환값이 읽은값임에도 불구하고 char 타입이 아니라 int 타입인거 주의. 읽은 값을 문자로 사용하고 싶음 강제형변환 해줘야됨

												
							int read(char[ ] cbuf)
								: 매개변수로 주어진 문자배열의 사이즈 갯수만큼 문자를 입력받아 저장하고, 입력성공한 개수 혹은 -1  (eof) 을 반환함
										
					: 하위 클래스)
						FileReader
						BufferedReader
						InputStreamReader


				(2) (텍스트)출력스트림
					: 최상위클래스 ) Writer
						: 추상 클래스
						: 주요 메서드
							: param으로 String 타입도 가능
								void write( int c )
										
								void write( char[ ] cbuf )
									
								void write(String str)
									: 매개값으로 주어진 문자열을 한번에 보냄

								void write( char[ ] cbuf, int off , int len )
									: 매개값으로 주어진 문자배열에서 시작 인덱스와 보낼 값의 개수를 지정하여 출력함
										

								void flush( )
									: 버퍼에 잔류하는 모든 문자를 출력

								void close( )
									: 출력 스트림을 닫음  

					: 하위클래스
						FileWrite
						BufferedWriter
						PrintWriter
						OutputStreamWriter




	(2)보조스트림
		: 기본 스트림 없이 혼자선 못씀 
		: 기본 스트림만 존재한다면 한번에 여러개의 보조 스트림을 사용 가능

		: 보조 기능
			1. 데이터 타입 변환해서 입출력
				: 보조스트림명 == 원래스트림의최상위클래스명+바꾸자하는스트림의최상위클래스명
					: 최상위클래스의 하위 클래스중 어떤 하위 클래슨지는 param 으로 대입되는 객체로 자동으로 추론해서 하위 클래스명은 생략하게 한 것 같다
						ex) OutputStream fos = new  FileOutputStream(경로); Writer osw = new OutputStreamWriter( fos ); 

								
			2. 입출력 성능을 향상 (버퍼 관련)
				1. 바이트 기반 스트림
					(1) BufferedInputStream
					(2) BufferedOutputStream


				2. 문자 기반 스트림
					](1) BufferedReader
							: 생성자
								BufferedReader(Reader rd)
									: 주의해야될것은 BufferedReader 는 (InputStream 을 Reader 로 바꾸고자 쓰는게 아니라) BufferedReader 만의 메서드인 readLine( ) 을 쓰기 위해 사용하는 보조 스트림이기 때문에 BufferedReader 로 생성한 객체는 BufferedReader 타입의 변수로 받아야된다(아니면 굳이 쓴 이유가 없다)

							: String readLine( ) 메서드 제공 
									: 라인 단위(엔터단위)로 문자열을 읽음 << 문장 읽어야되는 상황이면 개유용(기본 스트림의 read( )차원에선 문자 배열 혹은 문자 단위로 밖에 못가져옴)
										: 엔터를 포함하여 버퍼에서 가져오되 엔터는 버림 (엔터 이전 까지의 내용만 실제로 저장함)
											: 엔터 버리고 저장하는거 진짜 주의
											: 라인 단위 == 줄바꿈 == 엔터 == '\r'+'\n'
									: 더이상 읽어올 문자열이 없으면 null 을 리턴

-----------------------------------------------------------------------------
\-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------


drop table board;
create table board(
BOARD_ID NUMBER(4,0) primary key,
WRITER NVARCHAR2(50),
TITLE NVARCHAR2(500),
CONTENT	NVARCHAR2(500),
BOARD_DATE TIMESTAMP(6),
HIT	NUMBER(4,0)
);

select board_seq.nextVal from dual; 

-- 오라클에서 반복문을 사용하여 더미데이터 넣기
BEGIN
    FOR i IN 1..100 LOOP -- i 는 1부터 시작해서 100까지 반복
    INSERT INTO BOARD(BOARD_ID , WRITER , TITLE , CONTENT ) VALUES (BOARD_SEQ.NEXTVAL, '이순신'||i,'이순신입니다'||i,'나는 이순신입니다'||i);
    END LOOP;
END;

commit;
COMMIT;
rollback;

select * from BOARD order by board_id desc;

-- 10개의 데이터를 가져오고 싶다
select * from board where board_id between 1 and 10; -- 글이 삭제가 되면 board id 도 일부 삭제되므로 이렇게 해서 10 개 가 나온다는 보장이 없다

-- 1페이지당 10개씩 글의 목록을 출력하는 sol
    -- 오라클에서 행의 범위를 정해주는 ronum 사용 << 레코드의 순번
select ROWNUM, BOARD.* FROM BOARD;


--- 서브 쿼리 << 쿼리문 안의 쿼리
select * from
    (
select ROWNUM num, B.* from  -- B의 ROWNUM 의 집합을 num 이라고 붙였다
    (
    select * from BOARD order by board_id desc
    )B -- 결과 집합의 별칭이 B이다
    )
where NUM between 1 and 10; -- 1 이 아니라 2가 되도 잘 나온다


-----------------------------------------------------------------------------
더미 데이터: ?
ROWNUM 키워드
	: https://myblog1128.tistory.com/111
	: 레코드의 순번을 알려줌
	: 그러니까 액셀의 행 번호랑 같은 말

	SELECT ROWNUM, 테이블명.* FROM 테이블명;
		: SELECT ROWNUM, * FROM MEMBER; 이렇게 사용 못한다
	
	1부터 시작하는 ROWNUM이 아니라면 서브쿼리를 사용하자.
		: 왜 << 1 부터 select 안하면 인식을 못한다
			: SELECT * FROM MEMBER WHERE ROWNUM BETWEEN 1 AND 5;
				: 이거 하면 레코드가 1부터 5까지는 잘 나온다
			: SELECT * FROM MEMBER WHERE ROWNUM BETWEEN 6 AND 10;
				: 근데 아무리 레코드가 6 ~10 다 존재해도 이건 안나온다


		: 서브 쿼리 사용 방법
			: 괄호 안에다 쿼리문을 또 쓴다
			SELECT * FROM (SELECT ROWNUM NUM,MEMBER.* FROM MEMBER WHERE NUM BETWEEN 6 AND 10;


public 으로 선언되있는것은 굳이 getter setter 만들필요는 없다
next이름은 특이하게 setNext( ) 가 아니라 isNext()  가 된다.
