상속 느낌 : 자식이 부모가 물려준걸 쓴다

상위클래스 == 부모클래스 

하위클래스 == 자식클래스 == 파생클래스

상속 왜씀? 
	: 클래스간 중복되는 코드를 줄여줌 
	: 부모클래스에서 고치면 자식클래스에서도 자동적으로 고쳐지는 효과를 나타내므로 유지보수 시간이 단축됨(한쪽에서만 수정하면 되니까)


클래스 상속:
	: 사람과 똑같진 않은것이 자식이 부모를 택하여 상속받음( 뭐 현실에서는 부모가 자식을 택해서 상속해주잖아). 
	: 상속 받는 형식
		class 자식클래스명 extends 부모클래스{  
		.
		.	
		.
		 어쩌구	
		}
	
			: 해석을 하자면 자식클래스는 부모클래스의 확장판이란 소리임

	: 접근 제한자 때문에 제한을 받지 않는 이상 자식클래스는 부모 클래스의 모든 자원을 가져다 쓸 수 있고, 생성자 또한 가져다 쓸 수 있다.
	: 주의해야할 것은 static 멤버는 상속되는 것이 아니다(겉으론 일반적인 멤버의 상속과 다를게없어보이지만)
	: super( arg1 ,... );
		: 자식 클래스에서 부모의 생성자를 호출하는 코드
		: 자식클래스의 생성자 오버로딩 상황에서 쓸 수 있는 this( ) 와 비슷한 역할 한다. this( ) 에서 this 가 자식 클래스명을 나타내는 것처럼 super( ) 에서 super 는 부모 클래스명을 나타내는거라 생각함 된다.
		: 자식클래스의 생성자 맨 첫줄에서만 사용 가능하다 
		: 상속 관계에서 객체 생성
			: 외부적으로는 자식 클래스 객체만 생기는 것처럼 보여도 실제론 부모 클래스의 객체가 생성된 후 자식 클래스의 객체가 이 객체를 상속 받아 만들어지는거다
				: 객체가 생성되긴 위해선 생성자가 실행되어야하므로 자식클래스의 객체 만들떄 부모 클래스의 생성자도 실행되어야한다	
					: 자식 클래스의 생성자 블럭에서 직접 부모의 생성자를 호출하지 않았으면 컴파일러가 자식 클래스의 생성자 블럭 맨 윗줄에 자동적으로 기본 부모 생성자인 super( ); 을 추가하여 부모 클래스의 객체를 먼저 생성시킨다.
						: 주의할것은 컴파일러에 의해선 기본 부모 생성자인 super() ; 밖에 추가하지 못하므로 부모의 생성자가 arg 를 요구하는 상황서는 무조건 직접 super(ar1, arg2..); 를 써야된다.

	: 오버라이딩( 메소드 재정의 )
		: 자식클래스에서 부모클래스의 메서드를 재정의하는 것으로, 상속 관계에서 나타나는 현상.
		: 생성자 , 메서드 오버"로딩"이랑 다른거임
			: 오버로딩은 한 클래스 내부서 일어나는거고 오버라이딩은 상속관계에서 일어나는거임
		
		: 주의
			1. 오버라이딩 대상 메서드끼리 시그니처( 메서드명 , param 부분. 리턴타입은 미포함 )와 리턴타입이 동일해야 오버라이딩 가능
			2. 접근 제한을 달리 할 수 있으나 강화할 순 없음
				ex ) 부모 클래스에서 protected 인데 자식 클래스에서 private 로 재정의 못하지만 public 으론 재정의 가능
			3. 필드에서는 오버라이딩이란 개념이 없음. 부모 필드와 같은 이름의 필드를 자식에서 재선언하는 경우 '필드하이딩'이라고 하는거임
			4. static 멤버는 오버라이딩 불가하다. 오버라이딩은 인스턴스 메서드를 대상으로 일어나는거다

		: 하는 법 ) 
			:부모 클래스의 메서드와 동일한 시그니처로 자식 클래스에서 선언하되 블럭의 내용은 다르게 함. 
			: 부모 클래스의 필드명과 동일한 타입, 이름으로 자식 클래스에서 선언함 << 필드도 오버라이딩이 가능??

		: @Override
			: 꼭 쓸 필욘 없는데 쓰면 좋다
			: 선언한 메서드가 오버라이드 대상임을 컴파일러에게 명시하는 어노테이션으로 , 상위 클래스에 해당 메서드가 ㅈ존재하지 않는다면 컴파일 에러를 발생시킨다
				: 메서드가 아닌 필드를 대상으로는 안되는 것 같다
				: 어노테이션 Annotation
					: 주석이라는 의미로 (그렇다고 일반적인 주석이란게 아니다) , 앞에 @ 기호를 붙여서 대상의 윗라인에 적는다(문장이 아니므로 끝에 세미콜론 적지 않는다)
						ex) 
							@Override
							void 재정의메서드명(arg1, arg2 ... ){ 어쩌구저쩌구 , .... }
	
					: 용도
						1. 컴파일러가 더 정확히 검사하게 도와준다
							ex) @Override 명시했는데 메서드명이 다르면(부모는 Hehee( ) 메서든데 자식에서 Hehe( ) 로 썼으면) 걍 자식 클래스만의 메서드로 간주하는게 아니라(Hehee( ) 와 Hehe( ) 를 다른 메서드로 간주하는게 아니라) Override 대상의 메서드명이 다르므로 잘못됬다고 에러낸다

						2. 컴파일 타임 시점에서 추가적인 처리를 해주기 위한 용도
							ex ) 뭐 아직 안배움
	
						3. 런타임 시점에서 추가적인 처리를 해주기 위한 용도
							ex ) 뭐 아직 안배움

		: 오버라이딩하면 부모 클래스에서 오버라이딩 당한 메서드, 필드는 숨겨져서, 해당 메서드 혹은 필드를 호출하면 자식클래스의 메서드, 필드만 주구장창 나온다.

		: 오버라이딩 당한 부모의 메서드 , 필드 사용하는 법
			: super 를 객체로 하여 사용한다	
				: super 는 부모클래스 객체를 참조하는 변수다
				: super, this 는 각각 부모클래스, 자식클래스의 인스턴스를 참조하는 변수이기에 인스턴스 멤버를 대상으로만 사용 가능하다.

	: 클래스와 메서드에서의 final 키워드	
		: 필드에서와 마찬가지로 불변하는 고정의 것이란 의미인데 필드와 달리 상속에서 의미를 가짐
			: 클래스에서의 final >> 최종적인클래스라서 부모클래스가 되지 못하는 클래스 ( = 자식클래스를 가질 수 없는 클래스)
			: 메서드에서의 final >> 최종적인 메서드라서 자식 클래스에 의해 오버라이딩 되지 못하는 클래스
			: 주의해야할 것은 메서드에 final 붙인것과 다르게 부모클래스의 필드에 final 붙여서 선언했을때 자식 클래서 재정의 해도 별 문제 안생김 

	: 주의점
		: 자바에서는 여러개의 부모클래스를 상속할수없고 하나 이하로 가능
		: 자식 클래스만 import 했을때 부모 클래스까지 딸려오는게 아니다. 그러니까 자식클래스를 import 한 파일에서 부모 클래스를 대상으로 부모클래스의 멤버를 사용하지 못하고 부모클래스의 객체를 만들지 못한댜. 이렇게 하려면 걍 부모 클래스까지 import 하던가 자식클래스를 매개로 하여 해야된다.
		: 자식클래스가 부모클래스를 상속받았다 해도 무조건 그들의 멤버를 사용할 수 있는게 아니다. 부모클래스의 필드, 메서드의 접근 제한자 때문에 사용 못할 수도 있음
			: private 이면 꿈도 못꾸는거고 default 이면 같은 패키지 내에서는 가능한거고, public 혹은 protected 인 경우에는 사용 가능
		: 부모 클래스로부터 상속받은 필드도 매개변수와의 구분을 위해 this 를 사용할 수 있다

	: 헷갈리지 말아야할게
		부모 클래스의 생성자가 proteceted 으로 된 상태고 파일 구조가 이럴때
			프로그램
				▼패키지1
					▼부모클래스
					▼자식클래스
				▼패키지2
					▼실행클래스

		 자식클래스의 생성자가 public이라면 실행파일이 부모클래스와 같은 패키지에 위치하지 않을지라도 자식 클래스의 객체를 별 문제 없이 생성할 수 있다 
		(물론 실행 클래스에서 직접적으로 부모 클래스를 만들진 못하겠지만) 
		왜냐하면 부모클래스를 호출하는 위치가 실행클래스가 아니라 부모클래스와 같은 패키지에 위치한 자식 클래스이기 때문이다.




; 다형성
	: 하나의 참조변수로 " 다양한 " 객체를 참조하여 "다양한" 실행결과가 나오게 하는 성질
		ex) 같은 자동차라도타이어를 움직이는 법은 똑같지만(=사용법동일) 어떤 타이어(=객체) 쓰느냐 따라 주행속도(=실행결과)가 다름

	: 클래스의 타입변환
		: 상속관계의 클래스 사이에서 발생
		: 종류
			1. 자동타입변환
				: 부모타입에 자식타입이 할당될때
					: 자식객체가 (부모클래스에서도 존재하는 멤버만 남기고) 커팅되고, 부모타입의 참조변수를 이용해 남은 멤버에 접근이 가능하며, 오버라이딩된 메서드가 있는 경우(=부모와 자식에 동일한 이름의 메서드가 있으면) 자식의 메서드를 활용한다(부모의 메서드는 숨겨진다)
					: 클래스 자동형변환의 목적은 한 부모타입의 참조변수로 여러 자식타입의 객체를 가리킬 수 있게 하고, 자식타입의 업그레이드된(오버라이딩된) 메서드를 활용하는게 목적이다.
						: 그러니까 클래스 자동형변환의 목적은 다형성 구현이다.
						: 변수들의 자동타입변환과는 결이 다르다.
							: 변수의 자동타입변환은 데이터 손실 방지가 목적이라, 더 큰 쪽에 더 작은쪽ㅇ이 대입될때 더 작은 쪽이 확장되는 방향으로 일어나지만, 클래스 형변환은 다양한 오버라이딩된 메서드를 쓰는게 목적이라 부모에 존재하지 않는 멤버들은 커팅되는 쪽으로 일어난다.(그리고 이게 당연한게 부모타입에서 자식타입에게 어떠한 멤버가 존재하는지 알길이 없다. 자신에게 존재하는 멤버만 알 뿐이다.)
					; 주의할 것은 new 연산자를 통해 생성된건 자식클래스의 객체이므로 가리키기는 자식 클래스의 객체를 가리키고 있는거고 부모클래승에 존재하는 멤버에 한하여 자식클래스객체의 멤버를 쓸 수 있는거다
					: 헷갈리지 말아야할것은 다른 패키지의 실행 클래스에서 이런 자동형변환을 활용할 경우 자식 클래스뿐 아니라 부모클래스도 import 해야된다.(부모클래스 타입으로 직접적으로 참조변수를 선언해야되니까.)  자식 클래스에 녹아있는 부모클래스의 멤버를 쓰는것과 부모클래스 자체를 쓰는 것은 분명히 다르다

				

			2. 강제 타입 변환
				: 자동타입변환 되어 부모타입참조변수에 할당된 객체를 다시 자식타입으로 변환하는 것. 
					: 복원 느낌이다
					: 자동타입변환 과정에서 커팅되어 쓰지 못했던 기능을 강제타입 변환을 이용하여 자식클래스에만 있던 멤버도 사용 가능하다.
					: 물론 강제타입변환한 대상은 자식타입참조변수에 할당하여 사용해야한다
						: 또 부모타입변수에 할당해버리면 또 지동타입형변환일어난다
				: 목적 )
					부모타입참조변수가 가리키고 있던 자식클래스객체 정보를 유지하면서(아예 new 연산자로 새로운 객체를 만드는게 아니라) 풀 기능을 쓸 수 있게 한다. 
				

				: instanceof 연산자: 
					: 형식) 객체참조변수 instanceof 클래스명 
					: 객체참조변수가 instanceof 뒤에 쓴 클래스에 의해 생성된게 맞으면(찐 타입이 맞으면) true, 틀리면 false 로 불값 반환
					: 특정클래스로 강제 타입 변환하기 이전 확실히 해당 변수가 원래 특정클래스 타입의 객체였는지 확실히 확인하기 위해 검사하기 위해 쓰인ㄷ나.

				
: 팁) 자바에서 전반적으로 찐 타입으로 밀고가는건 new 연산자 뒤에 쓰인 생성자가 속한 클래스이다. 그래서 강제타입변환할때 원래로 돌아간다고 표현한거고, instanceof 연산자 뒤에 찐 타입이라고 하는게 new 뒤에 쓰인 클래스를 가리키는 것이다.

	: 다형성 구현의 원리
		1. 자식클래스에서 부모의 멤버를 자기것처럼 사용가능
		2. 자식클래스에서 부모의 메서드를 오버라이딩 가능
		3. 자식타입을 부모타입으로 (자동)형변환 가능

	: 다형성 현상은 직접 대입될 때뿐아니라 매개변수로 arg 받는 과정에서도 일어나기 때문에 매개변수는 되도록 최상위계층으로 받는게 좋다

	:목적) 
		1. 부모클래스의 수정없이 오버라이딩된 자식클래스의 메서드를 사용하여 부모클래스타입의 객체의 성능을 업그레이드 시킨다.
			: 일단 부모 클래스로 선언된 객체를 기본적으로 사용하는데, 좀 다른 버전의 멤버를 사용하고 싶을때 부모클래스의 멤버를 직접 수정하지 않고 자식클래스의 객체를 기존 부모클래스의 객체 대신 사용하여 자식클래스의 오버라이딩된 멤버를 활용한다. 

		2.  하나의 변수로 다양한 클래스 타입의 객체를 받을 수  있다는 거에 있다. 
			: 어떤 타입의 객체를 arg 로 할 지 예상할 수 없을 때 arg 로 받을 대상들의 공통적인 부모클래스 타입의 param 으로 대신 받으면 다 받을 수 있다(물론 개별적인 멤버들은 잘리겠지만)
			: 이 기능으로 쓰렴 가능한 최상위 계층의 클래스ㄹ로 선언하는게 좋다(그래야 더 많은 자식클래스 객체를 할당받을 수 있음)
	
	: 주의해야할 점은 다형성은 부모에게 기존애ㅔ 있던 메서드를 업그레이드 시키는데 사용되는것까지만 가능한거지 , 부모에 없던 메서드까지 추가시켜 업그레이드 하는 수준까진 안됨. 기존에 클래스 내부의 객체 선언에서 사용되었던 부모 클래스에는 해당 메서드가 없을 것이므로 자동형변환과정서 걍 짤림

 	: 교재의 tire 쓰는 예제를 봤을땐 부품으로 사용하겠다고 상속받아서 그 기능을 가지는게 아니라 그냥 그 클래스 타입 자체로 내부에서 선언시켜 객체를 만들어 부품으로 가지고 , 만든 객체를 여러 버전으로 사용하기 위해 해당 타입의 여러 자식 클래스를 만들고 그걸로 업뎃 시키는 듯



: 추상(abstract) 클래스 
	: 구체적이지 않은 . 추상적인 클래스로 ,  실체클래스 여러군데의 공통된 내용을 추출하여 정리해둔 클래스
		: 객체를 직접 생성할 수 있는 클래스  = 실체 클래스
		: 추상클래스와 실체 클래스의 관계 = 상속관계
			: 실체 클래스는 추상 클래스를 상속받는다.

	: 추상메서드랑 추상 클래스랑 다른거임 주의
		: 추상메서드 ) 선언부만 있고 실행부(중괄호)가 없는 메서드
			: 형식) 접근제한자 abstract 리턴타입 추상메서드명( 매개변수선언 ) ;
				: 접근제한자는 public 혹은 protected 만 가능하다
			: 자식클래스에서 "오버라이딩" 되어야하는 강제성을 띈다(-찐으로 실행내용이 적힌 메서드로)
				: 일반적인 메서드 오버라이딩과 마찬가지로 위에 @Overriding 써도 된다
			: 추상클래스 혹은 인터페이스 내부에서만 선언 가능하다(일반적인 클래스 내부에선 사용 불가)

	: 주요한 목적)
		 실체클래스 여러군데 비슷한 내용이 들어가는 경우 "상속"으로
			1. 시간 절약
			2. (필드, 메서드의)이름 통일
				: 사람마다 다른 필드명, 메서드명 쓰면 쓰기 난감하니까

	: 추상클래스 선언 방법)
		: 형식)
			: public abstract class 추상클래스명{   어쩌구저쩌구 }

				: 생성자, 필드, 메서드 모두 쓸 수 있다
					: 메서드로는 추상메서드와 일반적인 메서드 모두 사용이 가능하다
						: 자식클래스별로 실행 내용이 동일 >> 그냥 일반적인 메서드 사용
						: 자식마다 다른 실행내용이 필요한 경우  >>추상메서드를 사용	

				: 클래스 선언부에 abstract 끼워넣은 꼴(class 바로 앞 부분에)
	
	: 추상클래스 사용 방법) 실체클래스로부터 extends 키워드로 상속당한다
		: 일반적인 클래스 상속받는 방식과 같다

	: 추상클래스 자체적으로는 객체를 만드는게 목적이 아니기 때문에 new 연산자를 통한 추상클래스객체 생성은 불가하다.
		: 존나 주의)
			: 자식클래스에서 super(arg1 , arg2 ...) 의 호출을 통한 추상클래스의 객체 생성은 일어난다
			: 추상클래스 타입의 참조변수 선언은 얼마든지 가능하다



