연산자: 
	: 자바의 경우 씨발 굳이 산술연산자가 아닐지라도 int 형이하의 정수타입의 연산이면 결과는 죄다 int 형임 (결과 저장할 변수가 int 타입이여야됨)
	1) 단항연산자
		1. 부호연산자 : + , - 로 양 , 음 표기
		2. 증감연산자 : ++ , -- . 변수 앞 뒤 위치 모두 가능	
		3. 논리 부정 연산자 : ! 으로, toggle 역할
			: 논리연산자 중 하나임
	2) 이항연산자
		1. 산술연산자
			:+ - * / %
			: 숫자값 산출
			: *이랑 / 이랑 % 이랑 우선순위 같음
		2. 문자열결합연산자
			: +
			: 피연산자중 하나라도 문자열타입인데 + 쓰였으면 문자열끼리 잇는 꼴됨
		3. 비교연산자
			: > < >= <= != ==
			: 피연산자가 숫자 혹은 참조 변수이고 산출값은 불값
				:  != ==의 피연산자가 참조 변수인 경우 동일한 객체를 참조하는지의 여부를 판단
				
		4. 논리연산자
			: 산출값이 불값이고 피연산자는 붉값만 가능
			1)  && ( 논리곱 and )
			2) || (논리합 or) 
			3) ^ (배타적 논리합 xor)
				: !는 단항연산자이긴 하지만 논리연산자이긴해서 여기도 넣음 
			3) ! (부정 not)	
				: 배타적 논리합은 피연산자값이 달라야 true , 같으면 false 임
			
		5. 비트연산자
			1) & 
			2) |
				: 산출값이 불값이고 피연산자는 불값 뿐 아니라 정수형 숫자도 가능
				: 자바에서 사실 (피연산자가 불값인 경우) && 와 & , || 와 | 는 동일한 결과를 산출하지만 산출과정에 차이가 있다
					:  && 와 | 는 산출값 확정되면 거기서 연산을 그만두지만 ( 왼 -> 오 방향으로 검사하는데 &&의 경우 왼쪽 피연산자가 false 면 오른쪽 피연산자는 검사안하는거고 |는 왼쪽 피연산자가 true면 오른쪽 피연산자는 검사 안하는거)  & 와 | 는 산출값 확정되도 연산을 전부 한다
					:  https://blog.naver.com/lookking1159/223164878568
					: ex)
					int x=1,y=2;
					if(x==2 && ++y == 3) { //왼쪽 조건이 거짓인 상황서 && 사용 >> faㅣse 확정이니 오른쪽은 연산도 안하고 넘어감
					System.out.println("어쩌구저쩌구");
					}	
					System.out.println("reuslt1: x="+x+" y="+y);  
		
			
					x=1;
					y=2;
					if(++y == 3 && x==2) {  //왼쪽 조건이 참인 상황서 && 사용 >> faㅣse 미확정이므로 오른쪽까지 연산함 
					System.out.println("어쩌구저쩌구");
					}
					System.out.println("reuslt2: x="+x+" y="+y);

		
					x=1;
					y=2;
					if(x==2 & ++y == 3) {  //왼쪽 조건이 거짓인 상황서 & 사용 >> faㅣse 확정이지만 오른쪽까지 연산함 
					System.out.println("어쩌구저쩌구3");
					}
					System.out.println("reuslt3: x="+x+" y="+y);

					x=1;
					y=2;
					if(x==2 || ++y == 3) { //왼쪽 조건이 거짓인 상황서 || 사용 >> true 미확정이니 오른쪽까지 연산
					System.out.println("어쩌구저쩌구4");
					}
					System.out.println("reuslt4: x="+x+" y="+y);  
		
		
					x=1;
					y=2;
					if(++y == 3 || x==2) {  //왼쪽 조건이 참인 상황서 || 사용 >> true 확정이니 오른쪽은 연산 안하고 바로 넘어감
					System.out.println("어쩌구저쩌구5");
					}
					System.out.println("reuslt5: x="+x+" y="+y);

		
					x=1;
					y=2;
					if(x==2 | ++y == 3) {  //왼쪽 조건이 거짓인 상황서 | 사용 >> true 미확정이니 오른쪽까지 연산
					System.out.println("어쩌구저쩌구6");
					}
					System.out.println("reuslt6: x="+x+" y="+y);
			
			3) >>
				: 오른쪽 시프트 연산자
				: a>>b 는 a / (2**b)

			4) <<
				: 왼쪽 시프트 연산자
				: a<<b 는 a * (2**b)

		6. 대입연산자
			1) 걍 대입연산자 =
			2) 복합대입연산자 += , -= , *=, %= ...
				
	3) 삼항연산자 (조건식) ? 참일때값 : 거짓일때값;
		: 메서드는 못오는데 식은 가능
			: System.in.print 같은거 못온다는 말 (c언어에선 가능)
			: 리터럴끼리의 연산식 뿐 아니라 삼항연산자 그 잡채도 된단 거임 (이거 c언어에서도 되는거임)
				ex)
					int a=11,b=22;
					String r;
					r=(a>b) ? (a>10) ? "a가 b보다 더 크고 10 넘음" : "a가 b보다 더 크지만 10보다 작음":  (b>10) ? "b가 a보다 더 크고 10 넘음" : "b가 a보다 더 크지만 10보다 작음"
	:우선순위 tip
		1. n항 연산자에서 n이 낮을수록 우선순위 높음
	
		2. 우선순위가 같은 연산자의 경우 대부분 연산방향 앞에서부터 뒤쪽(왼쪽에서 오른쪽방향)
			: 예외) 
				1. 대입연산자 (뒤에서부터 적용됨.)
				2. 단항연산자 (뒤에서부터 적용됨)
		3. 덩어리가 클수록 우선순위 뒤로 밀려나는 느낌 (논리보단 비교가 우선순위 높음)
