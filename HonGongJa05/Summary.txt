

메모리 영역(Runtime Data Area)
	1.  메소드 영역 Method Area
		: JVM 이 시작시 생성, 모든 스레드가 공유하는 영역
		: 클래스 저장: 객체와 인스턴스 필드는 객체에 저장되어 힙 영역에 포함됨을 주의
			1. 클래스 내부 정적필드 
			2. 인스턴스 , 정적 메서드 
			3. 생성자 
	
	2. 힙 영역 Heap Area 
		: 객체와 배열이 생성돰 (이때 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에 의해 참조, 즉 가리킴 당함)
			: 자바에선 배열을 객체 취급함
			: 생성된 객체와 배열이 아무런 변수 혹은 필드에 의해 가리킴 당하고 있지 않다면 JVM이 이것을 쓰레기로 간주하여 가비지 콜렉터를 자동 실행시켜 삭제함
				: 개발자 차원에서 직접 가비지 콜렉터를 실행시키진 못함.
				: 헷갈리지 말아야할것은 참조타입변수가 아무것도 가리키지 않는다고 자동 삭제당하는게 아니라 객체가 아무런 참조타입변수에 의해 가리킴 당하고 있지 않을때 그 객체가 삭제당한다는것
		: 인스턴스 필드도 객체와 함께 저장되는데, 인스턴스 메서드의 경우 객체와 함꼐 저장되는게 아니라 메서드 영역에 저장됨을 주의
	
	3. JVM 스택 영역
  		: 메서드 호출할 떄마다 프레임을 push, 즉 추가하고 메서드가 종료되면 해당 프레임을  pop, 즉 제거시킴.
		: 프레임 frame
			: 로컬변수 스택 포함
				: 로컬 변수(일반 타입 변수든 참조 타입 변수 든)의 초기화 시점에서 생성되고 (참조타입변수가 객체를 가리키게 하든가 null 값을 가지게라도 해야 생성되는것), 선언된 블럭을 벗언나는 시점에서 제거됨
					: 일반 타입 변수의 경우 스택영역에 직접 값을 저장하고, 참조타입변수의 경우 "힙 영역에 생성되있는 객체"의 주소값을 저장함



	
자바 : 객체 지향 언어
객체 object
	:  객체 생성 방법
		1. 클래스 객체 생성 :new 연산자 사용
			: [클래스명] [변수명] = new [클래스명]( [ 내 용 ] );
				생성된 객체를 변수명으로 가리켜 사용하게 됨
		2. 배열 생성
			: 자바에선 배열도 객체
				: 배열선언부분의 " 타입[ ] " 부분이 클래스명과 결이 비슷함
필드 field
상수 constant
생성자 constructor
프레임 frame
참조한다 == 가리킨다

자바 타입:
	1. 기본 타입 primitive type : ( 스택 영역에 ) 직접 값을 저장
		: 정수 , 실수 ,논리 타입
	2. 참조 타입 reference type  : 직접적 값이 아닌 ( 힙 영역의 객체의 ) 주소를 저장
		: 주소를 통해 참조한다고 해서 참조 타입인거임
		: 헷갈리지 말아야할것이 객체 생성과 변수 생성은 별개임
			: 헷갈릴만한 이유는 보통 참조 타입 변수 생성과 객체 생성이 같이 일어나기 때문 (객체가 존재해야 그 주소를 가져올거니까)
		: 배열, 열거, 클래스, 인터페이스
		: null 을 값으로 가질 수 있음
			: null ) 아무것도 가리키고 있지 않은 상태
				: NullPointerException : 참조타입변수를 잘못사용하는 경우 발생하는 오류	
					: 예외 exception : 프로그램 실행 도중 발생하는 오류
			: 참조를 해제하고 싶거나 아직 참조할 대상이 정해지지 않은 상태일때 null 할당
참조타입변수
			: 객체 생성 없이 null값으로 초기화만  해줘도 일단 참조 타입 변수는 생성된거임

	1. 클래스 타입

		1) String 타입	
			: 객체 선언 방법)  String 변수명 ;
			: 객체 생성 방법)
				sol1 : String 타입 변수에 문자열 자체를 할당할떄 그 문자열은 String 객체로 (힙 영역에)  자동으로 생성되고 String 타입 변수는 그 객체 주소값을 저장하게 된다.
				 	: 동일한 내용의 문자열을 여러번 할당하면 객체가 여러개 생기지 않고 걍 그 객체를 여러개의 변수가 참조하게된다.
					: 선언 시점이 아니더라도 문자열 얼마든지 새로 할당 가능
				sol2 :  직접 new 연산자를 사용하여 객체를 생성하고 이를 String 타입 변수에 할당할때 변수는 해당 객체의 주소값을 저장하게 된다.
					:  new 연산자를 사용하면 이미 존재하는 내용일지라도 새로운 객체를 생성한다
			:  == , != 비교 연산자는 문자열 내용자체가 아닌 객체의 동일성 여부를 판단한다
				: sol1을 통해 생성된 String 타입 변수는 내용이 같으면 == 썼을때 true 로 나온다
				: sol2를 통해 생성된 String 타입 변수는 내용이 같아도 == 썼을때 false 로 나온다
			: 객체의 동일성 여부가 아닌 문자열 내용의 동일성 여부를 판단하고 싶으면 equals 매서드를 사용한다
				: 형식 ) 대상문자열. equals(비교문자열);
					
				

	2. 배열 타입 array
		: 같은 타입의 데이터를 연속된 공간에 나열하고 인덱스를 부여한것
		: 같은 타입 변수 여러개 필요할때 쉽게 생성, 관리하기 위해 사용
		: 인덱스는 0부터 시작
		: 선언 이후 사이즈 수정 불가
		: 자바에선 배열도 객체 취급당함
		: 자바에서는 비정방형 배열도 가능
			: 비정방형 배열:  열의 사이즈가 일정하지 않은 배열 (물론 2차 이상일때 말하는 거임)
		: 기본타입배열 뿐 아니라 참조타입배열까지 만들 수 있음	
			String 타입의 배열일 경우 new String("어쩌구저쩌구") 을 이용해 문자열 내용을 할당하지 않는 이상 ( new String [ ] { "어쩌구1", "어쩌구2"...} 혹은 new String[n] 이랑 다른거임!  << 이건 직접적으로 "어쩌구저쩌구"가 new String( )의 arg 로 들어가지 않았으니까 ) 똑같은 내용이면 겹치는 객체 생성 안하고 하나의 객체만 가리킨다.
			String[] StrAry1 = {"ahahahaha","chase","dumb"};
			String[] StrAry2 = new String[]{"ahahahaha","chase","dumb"};
			System.out.println("StrAry1[0] == StrAry2[0]: "+(StrAry1[0] == StrAry2[0]));
			String[] StrAry3 = new String[3];
			StrAry3[0] = "ahahahaha";
			StrAry3[1] = new String("chase");
			StrAry3[2]="dumb";
			System.out.println("StrAry1[0] == StrAry3[0]: "+(StrAry1[0] == StrAry3[0]));	
			System.out.println("StrAry1[1] == StrAry3[1]: "+(StrAry1[1] == StrAry3[1]));	
			System.out.println("StrAry1[1].equals( StrAry3[1]): "+ StrAry1[1].equals(StrAry3[1]) );	

		: n차원 배열 선언 방법 : 선언부 대괄호 안에 사이즈 안쓰는거 주의
			sol1 : 타입 [  ][  ][  ] 배열명;
			sol2 : 타입 배열명[ ][ ][ ];

		: 배열 변수 생성 즉 초기화 방법
			: 선언 시점 이후에도 할당 가능한건 대체로 new 써서 생성되는 케이스인듯(그러니까 sol1 제외)
			
			sol1 : 단순 {값1 , 값2 ,값3.... }만 할당
				: 선언시점에서만 할당 가능
				: 사이즈를 아예 명시하지 않음
				: 참고로 헷갈릴까봐 말해줌 String 클래스 변수에선 선언 시점 이후에도 썡 문자열 걍 할당 가능함
				: n차원 이면 중괄호를 그만큼 쓰면됨
			sol2 :  new 타입[ ][ ][ ]{값1 , 값2 , 값3....}  할당
				: 선언시점 이후에도 사용가능
					: param 타입이 배열타입인 메서드의 arg 로 값 한번에 주기 가능
						ex) int result = function(new char[]{ 'f', 'u','c','k' });
				: 이건 사이즈를 걍 필수적으로 안쓰는 거임
				: new 안빼먹게 주의 

			sol3: new 타입[ 사이즈1][사이즈2][사이즈3]
				: 선언시점 이후에도 할당 가능
				: 사이즈1 부분(타입과 가장 가까운 대괄호 칸)은 필수적으로 표기해야됨
					: 그 이후 부분은 몇개가 됬던 생략 가능
					: 생략을 했다면 그 이후에 별도로 sol2 혹은 sol2로 필수적으로 초기화 해줘야됨
						ex)

						int [ ][ ][ ]ThreeDemensionAry = new int [2][ ][ ]; //최소한 가장 가까운 사이즌 정해줘야됨
						ThreeDemensionAry[0] = new int [2][ ]; //ThreeDemensionAry[0][ ][ ] 에다 할당하는거 아니다 (지금은 초기화 이후 인덱스적 접근을 통해 할당하는 과정)
						ThreeDemensionAry[0][0] = new int [2]; 		
						ThreeDemensionAry[0][1] = new int [4]; 		
						ThreeDemensionAry[1] = new int [2][3];
		
						for(int i = 0 ; i < ThreeDemensionAry.length;i++) {
							for(int j = 0 ; j <ThreeDemensionAry[i].length;j++) {
								for(int k = 0 ; k <ThreeDemensionAry[i][j].length;k++) {
									System.out.printf("ary[%d][%d][%d] = %d\n",i,j,k,ThreeDemensionAry[i][j][k]);
									}
							}	
						}

				: 당장 값을 할당하진 않고 일단 사이즈만 확보해두는것
					: 값은 타입따라 상식적인 값(0 비스무리한 값)으로 ㅏ자동초기화됨
						char :  '\u0000'
						byte,short,int  : 0
						long : 0L
						float :   0.0f
						double: 0.0
						boolean: false
						클래스명 : null
						인터페이스명: null

			:  모르겠는건 null 값을 부여할 수 있긴 함 (p.181) 근데 이때도 배열 변수 생성된거임? (객체 안만들긴했지만 초기화는 한거니까 궁금~~)
		: 배열 변수 생성 이후 인덱스 접근을 통한 수정 가능
		: 배열 길이 측정
			: how )  배열명.legth 이용
				: c언어의 sizeof변수와 다르게 바이트수가 아닌 정말 논리적인 요소 개수를 반환한다
					ex) 
						int[ ][ ] ary = new int [3][2];
						System.out.println(ary.length) ; // ary 의 요소개수인 3을 반환한다 (물리적인 요소개수인 6도 아니고 진짜 직관적이다)
						System.out.println(ary[0].length) ; // ary[0] 의 요소개수인 2를 반환한다.

			: 다른 메서드에서까지 배열길이 측정이 되기 때문에 사이즈 받을 param을 만들지 않아도 됨 
		: 배열 복사 
			: 그냥 단순히 배열명에 다른 배열명을 할당한다해서 복사되진 않는다
			: 복사만 받을 배열이라해도 초기화 시키고 복사시켜야된다.
				: 배열이 생성되야 복사받을 수 있으니까(+사이즈는 정해야되니까)
			:복사 방법
				sol1 : for문 이용 요소 단위로 직접 복사
					:복사받고 남은 공간은 기존값 유지됨
				sol2 : System.arraycopy( 복사시키는배열명, 복사시키는 배열의 복사 시작 인덱스 ,복사받는 배열명, 복사받는 배열의 복사 시작 인덱스 ,  복사시키는 배열명의 복사 원소 개수  )
					: 복사 받고 남는 공간은 기존값 유지됨
						: 배열간의 사이즈가 일치하지 않아도 함수를 사용하요 복사시킬 수 있음
					: 만약 전체를 복사시키고 싶으면 "복사시키는배열명의복사원소개수" 를 복사시키는배열명.length 로 둠 됨.

				


	3. 열거 타입 enum 어쩌구: 씨이이이이발 좆같네 클래스 단원 끝나고 다시한번 보기(이해 존나 안감)
		:  enum이 열거 타입이 아니라 "어쩌구" 가 열거 타입이다(열거 타입을 enum 어쩌구 라고 선언했다했을때 )
			: 어쩌구는 관례적으로 첫글자만 대문자로 쓴다
		: 열거상수 : 열거 타입 정의에 쓰인 값들
			: 열거상수는 관례적으로 통대문자로 쓴다
			: 열거 상수도 자바에선 객체이다
			: 정확히 말하자면 어쩌구의 ( "enum 어쩌구" 로 열거타입이 선언됬다 했을때) 객체이다
			: 그래서 열거타입변수가 참조타입변수인거다
		: 메소드 영역엔 열거타입이 , 힙 영역엔 열거타입객체가 , 스택 부분엔 열거타입변수 가 저장된다.
		: 열거타입변수 자체가 열거 상수값을 가지는게 아니라 참조하는것임을 주의
		  ex)
			Week when = Week.SUNDAY;
			System.out.print(When); // 이런거 불가 : When 이 SUNDAY값을 가지는게 아님

		
		: 사용법
			1. (현재 작업중인 소스파일에서가 아니라)별도로 어쩌구.java 의 소스파일을 생성해야한다
				: 만들때 class 버튼 클릭하는게 아니라 enum 버튼 클릭한다

			2. (새로 생성한 소스파일에서 enum 어쩌구라는) 열거타입(열거타입변수가 아님) 선언을 한다 (= 열거 타입을 만든다)

				: 형식)
					public enum 어쩌구{
						열거상수1,
						열거상수2,
						.	
						.
						.
					} 
						: 	public class 어쩌구 
							public static void main(String[] args)  이런거 없이 쓰는거다  << 왜??
							( 소속된 패키지는 표기한다)
						: 세미콜론 없음 주의
				:ex)
				package Sec03.Enum;

				public enum Week {
					MONDAY,
					TUESDAY,
					WEDNESDAY,
					THURSDAY,
					FRIDAY,
					SATURDAY,
					SUNDAY
				}

			3. ( 작업중이었던 소스파일에서) 열거 타입 변수를 선언한다
				: 형식)
					어쩌구 변수명;

						: enum 안쓰는거 주의

			4. 열거타입변수에 값을 초기화 , 할당하여 쓴다
				:물론 열거타입변수 선언과 동시에 진행해도 된다
			 	: 형식) 
					열거타입변수명 = 어쩌구.열거상수값;
	
						: 단순히 열거상수값이 아닌 어쩌구.열거상수값을 할당해야된다.
							: 열거타입변수명.열거상수값을 할당하는것도 아님을 주의

				: 물론 참조타입변수인만큼 null을 할당할 수 있다


	4. 인터페이스 타입
	
향상된 for 문 : 배열이나 컬렉션의 쉬운 처리를 위한 for문
	:배열, 컬렉션의 요소를 0번째부터 끝까지 자동으로 꺼내주고 요소가 동날때까지 반복한다
	:형식)
		for( 요소타입의 변수 : 배열명 또는 컬렉션명){
		}
	: ex )

main 메서드에 arg 로 String[] args 주는 의미
	: 명령 프롬프트(명령 라인)에서 입력 받을 수 있게 함
		: 입력하면 띄어쓰기를 기준으로 입력된 내용을 문자열 타입으로 args 배열에 저장함
	: 사용법은 c언어랑 비슷함
	: 별로 안중요해보이나 궁금하면 p.186 참고

 
