프로그램은 데이터를 다양한 곳으로부터 출력, 입력 가능
	: 키보드, 모니터, 파일, 네트워크

스트림 Stream
	: 단방향의 연속적인 흐름
	: tip ) 
		: 최상위 클래스의 경우 바이너리가 일반적으로 많이 접했던 스트림이고, 문자 기반 스트림은 뭔가 진짜 책(?)적인 느낌이다(독자 Reader, 작가 Writer). 근데 주의해야될것은 바이트 스트림 ,문자 스트림 모두 의 하위 클래스에 write( 어쩌구 ) 를 사용해 출력하고 , read ( 어쩌구 ) 를 사용해 입력받는다 

		: 해당 클래스의 접미사는 최상위 클래스를 나타낸다	
			: ex)   XXXInputStream >> InputStream이 최상위클래스
			: 해당 클래스의 최상위 클래스를 알게되면 어떤 종류의 stream 인지 파악 가능하다 (출력용인지 입력용인지 파악 가능해진다)

		: 해당 클래스의 접두사는 어떤 걸 대상으로 작동하는지 나타낸다
			: ex) FileXXXX >> 파일을 대상으로 입력 or 출력한다


		: 입출력 스트림에서 byte, char 씩 입출력 한다고 할때 숫자 범위로써 byte char 이러는게 아니라 크기로써 byte char 이러는 거라 byte 의 범위는 0~255 간주, 바이트 스트림의 경우 0~255 크기의 값을 입출력하는것.


		: 바이트. 텍스트 기반 스트림의 최상위 클래스는 모두 추상 클래스로, 그 자체로 쓰이지 않고 일정한 규격의 하위 클래스를 생성하기 위한 용도로 존재하는거다

		: javaj.io 패키지를 사용하면 코드가 맞았던 틀리건간에 에러가 나는데 해결 방법
			1. try ... catch 구문 사용
				: java.io.IOException 을 catch 내부에서 사용하기 때문에 별도로 import 필요
				: 장점은 try 문 괄호 부분에 스트림 객체 쓰면 try 구문의 종료시 자동으로 close( ) 해줌
				: 형식	
					try( 스트림 객체 생성 ){
					... 수행할 내용
					}catch( IOException e ){
						e.printStackTrace( );
					}

			2. main 메서드 선언 부에 throws Exception 추가
				: 에러 처리 위해 별도로 import 할	건 없는게 장점 		
				: 자동으로 close( ) 안해줘서 별도로 해줘야됨
				: 형식)
					public static void main(String[ ] args) throws Exception{
						수행할 내용
					} 
	
		: java.io 패키지의  하위클래스를 사용하는 경우 아래 3가지를 기본적으로 import 해준다
			1.  java.io.해당클래스의최상위클래스 ;
				: 보통 다형성 구현을 위하여 하위 클래스의 객체를 참조하는 변수를 부모타입으로 선언하기 때문에 직접적으로 각 스트림읭 최상위 클래스의 객체를 생성하지 않더라도(생성 안하는게 아니라 못하는 거긴 하지만 - 추상 클래스니까) 같이 import 해주는 편이다.
					ex ) InputStream fis = new FileInputStream("C:/SelfStudyJava/chap14/binarytest.db");

			2.  java.io.해당클래스;
			3.  java.io.IOException;
				: java.io 패키지의 클래스 사용하면 필수적으로 에러나는 걸 해결할때  try ...catch 구문을 사용하는 경우 import 필요 (만약에 걍 throws Exception 할꺼면 굳이 import 안해줘도 됨)
				


		: flush 는 왜 사용하는가?
			: 데이터를 입력, 출력하는 메서드를 쓰면 이터가 바로 입출력되는게 아니고 	버퍼라는 임시 저장 공간에 저장되어있다가 그 공간이 다 차면 버퍼를 비워 비로소 데이터를 실제로 입출력한다.  버퍼를 다 채우지 못한 상황에서도 버퍼를 비우기 위해 flush 를 사용ㅇ하는거다

			: 사실 close 썼음 flush 를 쓸 필요없다
				: close 기능 =  flush 기능 +  스트림 폐쇄


		: 리소스를 닫아야하는 이유
			: 예를 들어 파일이 열려있음 다른곳에서 사용을 못하고 닫혀 있어야만 열 수 있다

		: IoException
			:FIleNotFoundException 의 최상위 클래스다.
				: 그래서 catch 괄호내부에 FIleNotFoundException e 를 써도 되긴하지만 범용성을 위해 IOException e 쓰는거다 

		: 바이트 파일의 경우 문자열의 형태가 아니기 때문에 메모장으로 확인을 못한다. 
			: 내용 확인/유추 방법
				sol 1. 파일의 속성 탭을 누르면 몇 바이튼지 크기 나오는걸로 통해 유추가 가능하다
				sol 2. 바이트 인풋 스트림을 이용해 get 

		: 바이트 스트림의 경우 바이트란 이름에 걸맞게 1바이트씩 거래한다
		: 스트림은 그림에서도 추론 할 수 있듯이 FIFO로 작동한다
			: 먼저 입력된 내용부터 쓰여지기 시작한다
		: close( )를 제외한 입력 스트림의 메서드는 모두( 바이트 스트림이건 문자 스트림이건) 
			: 메서드 종류 
				: ( close( ) 제외하고 )  죄다 read( 어쩌구 ) 꼴
					: flush( ) 가 없다 

			: 반환
				: 반환 타입 ) int 형이다
				: 반환값
					1. eof 에 도달하면 -1 을 반환한다
					2. eof 가 아니면 
						(1) arg 가 없는 read ( ) 를 제외하곤 읽는데 성공한 값의 개수를 반환한다 << 주로 conunt 변수로 이를 저장해둔다
						(2) arg 가 없는 read( ) 의 경우 읽은 값을 반환한다 (int 형으로)
	
		: 출력 스트림의 메서드는
			: 메서드의 종류
				1. write ( 어쩌구 ) 꼴
					: write( ) 로 값 딱 하나만 읽어오는 경우 param 타입이 int 긴 한데 int 란 사실은 잊어버리고 그냥 바이트 스트림이면 바이트값, 문자 스트림이면 문자값을 arg 로해라. 
						: param 으로 int 값 받아도 에러는 안나는데 실제로 출력되는건 끝의 1바이트, 2바이트씩만 실제로 출력된다고 한다  (param 값이 곧 출력값은 아니다)
				2. close ( )
				3. flush( )

 
			: 반환 타입이 죄다 void 이다
			

		: 출력 스트림의 생성자는
			:  append 여부를 결정하는 param 도 있다
				: 암것도 안쓰면( 디폴트 ) false 고 , append 안하겠단 뜻 된다
					: true 를 쓰면 append 하겠단 뜻 된다
					


			

		: 파일 끝까지 읽는 tip	
			: count 를 사용하여 평소엔 읽어온 값ㅇ의 개수 저장하다 eof 에서 -1 입력 받음 종료함
			int count = 0 ;
			while(  (count = 스트림객체.read( 어쩌구) ) != -1 ) {

			
			}

		: 입력받은 내용을 저장한 배열을 출력하는 tip
			: tip 이란게 있어야되는게 (걍 암 생각 없이 배열 활용하면 안되는게) 항상 배열의 크기만큼 데이터가 가져와지는게 아니라 마지막 차례에서 배열을 꽉 채우지 못하고 입력을 받을 수 있기 때문
			: 공통
				파일 읽는데 쓰이는 whille 문 내부서 ary 객체를 생성한다( 한 턴 돌때마다 새로운 객체 생성 )
					: 그래야 지속적으로 모든 인덱스가 0 으로 초기화 되서 입력 안된 부분을 null 값을 통해 구별 가능하다
					: 만약에 처음에 생성했던 객체를 계속 쓴다면 이전에 받았던 내용을 덮어쓰기 하는 방식으로 진행되는데 마지막 턴에서 새롭게 입력받지 않은 인덱스에도 이전턴에 입력받은 값이 남아있어 혼란을 야기할 수 있다(+ null 값으로 구별이 불가하다)

			1. count 변수를 적극활용 : 자동적으로 실제로 입력받은 부분까지만 출력한다 << 강추
				for(int i  = 0 ; i  < count ; i++){
					ary[i] 값 활용
				}
					
	
			2. null 값을 통해 실제로 입력 받은 부분을 파악 :
				(1) 걍 for 문

					for(int i  = 0 ; i  < count ; i++){
						if ( ary[ i ] != 0) ary[i] 값 활용
					}

				(2) 향상된 for문
					for( byte b : ary) {
						if ( b != 0) b 값 활용
					}

	: 패키지
		java.io
			: 여러가지 스트림 클래스를 제공
	
				(1) 기반 스트림
					1. 바이트 기반 스트림
						: 바이너리 데이터를 읽고 출력할 때 사용
							: 바이너리 데이터 ) 데이터 형태 그대로 저장
								: 이미지 등등
						: 세부 종류
							(1) (바이트)입력스트림
								: 최상위 클래스 ) InputStream
									: 추상클래스다
									: 메서드종류
										int read( )
											: 1 바이트를 읽고, 읽은 값의 int 타입버전값 혹은 -1을 리턴
												: -1 == EOF 나타내는 값
													: 이거 이용해서 파일 끝까지 읽을 수 있다
												: 읽기는 바이트로 읽고 실제로 가져오는기는  int 타입임을 주의													: 끝부분만 진또배기고 앞 3바이트는 죄다 00000000 00000000 00000000 이다


										int read(byte[ ] b)
											: 읽은 값은 "매개값으로 주어진 배열"에 저장하고, 읽은 바이트 수를 "반환"한다
												: 그냥 read( ) 와는 다르게 반환값이 읽은 값이 아님에 주의
												: 똑똑하게 실제로 읽은 바이트 수를 반환함을 주의 
													: 항상 배열 사이즈를 반환하는게 아니다(배열을 꽉 채워 받지 못하는 경우도 있을 수 있으니까)
	
										int read(byte[ ] b, int off ,int len)
											: 

										void close( )

								: 하위 클래스
									: InputStream 의 구현 클래스들
										FileInputStream
										BufferedInputStream
										DataInputStream

									
									


							(2) (바이트)출력스트림	
								: 최상위 클래스 ) OutputStream
									: 추상 클래스
										: 메서드
											:  return 값이 출력값이 아님을 주의( 반환형이 다 void 이다)
												: return 은 프로그램내에서 반환되는 값이지 외부로 반환되는 값이 아니니까 출력 메서드의 반환값이 void 형인건 어찌봄 당연한 일
											1. abstract void write( int b )
												: 존나 웃긴게 받기는 int 값 받았으면서 정작 출력은 1바이트만 출력한다
													: 그러니까 int 값을 이루는 4 바이트 중 젤 오른쪽의 1 바이트만 들어가는거다 (-128~127의 숫자만 가능)

											2. void write( byte[ ] b)
												: 매개값으로 주어진 배열 b 의 "전체"를 "한번에" 출력한다
													: 배열이 끝까지 채워져있던 말건간에(null 값이던 아니던) 배열 전체 사이즈를 출력하는거 주의  

											3.  void write( byte[ ] b , int off , int len)
												: 매개값으로 주어진 배열 b에서 b[off] 부터 len 개의 내용을 출력한다(배열의 일부를 출력한다)
													: 가장 마지막 매개변수 값이 종료 인덱스가 아니라 출력 갯수임을 주의

											4. void flush( )
												: 출력 버퍼가 다 차지 않아도 잔류하는 모든 바이트를 출력한다
													: 프로그램 중간중간에 데이터 저장하고 싶음 사용한다

											5. close ( )
												: 출력 스트림을 닫는다 + flush 기능 수행한다
												: 안전하게 close 하는 법
													1. AutoCloseable 활용
														: try 구문에 괄호 치고 그 내부에서 스트림 객체 참조변수를 넣으면 try 구문의 종료시 자동으로 close ( ) 실행된다. (자동리소스닫기)
															: 여러 객체를 한번에 넣을 수 있다. 이때 각 객체는 ; 로 구분해놓는다
														: 주의 ) 모든 스트림 객체에 사용 가능한건 아니고 AutoCloseable 이란 인터페이스를 구현한 스트림 클래스에 대하여 가능 ( 근데 대부분 AutoClosealbe 을 구현하긴 한다)
															
														: try( 스트림 객체참조변수 ){
														}
														catch( ){  }
														
													2. 예외구문에 finally 추가
														: finally 는 예외가 발생했건 안했건 꼭 실행되는거 이용하는것 이용
														: 근데 이거 쓰면 이상한 에러 나는데 나중에 확인

														try{

														리소스 오픈& 활용 코드

														} catch{
														예외발생시 발생시킬 오류 문구
														} finally{
															리소스객체.close
														}
	
												: 불안전한 close
													: try 블럭 내부에서 리소스 객체를 close 하는 것
														: try블럭의 경우 블럭 실행하다가 예외 발생함 뒤에 코드는 실행을 안하기 때문에 close 가 실행이 안될  수 있다.

								: 하위 클래스
									: 최상위 클래스의 실체 클래스들
									: 종류
										FileOutputStream
											: 파일로 출력하는 스트림
											: 생성자
												FileOutputStream( String name, boolean append)
													: 첫 param 으로 파일명을 받음
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


												FileOutputStream(Filen f, boolean append)
													: 첫 param 으로 파일 경로를 받음 
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


										PrintStream
										BufferedOutputStream
										DataOutputStream


					2. 문자 기반 스트림
						: 텍스트 데이터를 주고 받을 때 사용
							: 텍스트 데이터 ) 문자로 읽기 가능한 형태로 저장

						: 세부 종류
							: (write( )로) 문자열 타입을 출력할 수 있지만 (read( )로 )문자열 타입으로 입력은 못받는거 주의
							(1) (텍스트)입력스트림
								: 최상위클래스 ) Reader
									: 추상클래스
									: 메서드)
										: 문자 배열 단위로 불러올 순 있어도 문자열 단위론 못불러옴 << 문장 단위로 받아오고 싶다묜 보조스트림 사용
										int read( ) 
											: 1개의 문자를 읽고 이를 int 타입으로 리턴
												: 문자 == 2바이트 이므로 한글까지 입력받을 수 있다
												: 반환값이 읽은값임에도 불구하고 char 타입이 아니라 int 타입인거 주의. 읽은 값을 문자로 사용하고 싶음 강제형변환 해줘야됨
													: 왜 굳이 int 형으로 만들었을까
														: char 타입의 경우 음수를 표현못해서 일단 int 타입으로 확장 시켜 반환한듯?
												
										int read(char[ ] cbuf)
											: 매개변수로 주어진 문자배열의 사이즈 갯수만큼 문자를 입력받아 저장하고, 입력성공한 개수 혹은 -1  (eof) 을 반환함
										int read(char [ ] cbuf , int off , int len)
										void close( ) 
	
								: 하위 클래스)
									: Reader 클래스를 상속 받아서 만들어짐
									: 종류
										FileReader
										BufferedReader
										InputStreamReader


							(2) (텍스트)출력스트림
								: 최상위클래스 ) Writer
									: 추상 클래스
									: 주요 메서드
										: param으로 String 타입도 가능
										void write( int c )
											: 신기하게도 또( 바이트 스트림에서도 한개 단위로 출력할때 출력하는 값의 타입이 int 도 아니면서 매개변수 타입 int 였음) 출력하는 값은 char 형 이면서 매개변수 타입은 int 형임
												: 어쨌뜬 걍 char 형 값을 arg 로 함 된다
												: char 범위 넘어서는 int 값은 안됨을주의? 맞니?

										void write( char[ ] cbuf )
											: 매개값으로 주어진 문자 배열의 값을 한번에 출력함
											:
										void write(String str)
											: 매개값으로 주어진 문자열을 한번에 보냄

										void write( char[ ] cbuf, int off , int len )
											: 매개값으로 주어진 문자배열에서 시작 인덱스와 보낼 값의 개수를 지정하여 출력함
										
										void write( String str , int off , int len)
											: 매개값으로 주어진 문자열에서 시작 문자와 보낼 문자의 개수를 지정하여 출력함

										void flush( )
											: 버퍼에 잔류하는 모든 문자를 출력

										void close( )
											: 출력 스트림을 닫음  

								: 하위클래스
									: Writer 클래스의 구현 클래스들
									: 종류
										FileWriter

											: 생성자
												FileWriter( String name, boolean append)
													: 첫 param 으로 파일명을 받음
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


												FileWriter(Filen f, boolean append)
													: 첫 param 으로 파일 경로를 받음 
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨

										BufferedWriter
										PrintWriter
										OutputStreamWriter

				(2)보조스트림
					: 기본 스트림을 보조하는 스트림
						: 기본 스트림 없이 혼자선 못씀 
						: 기본 스트림만 존재한다면 한번에 여러개의 보조 스트림을 사용 가능

					: 삽입 위치
						: 기본 입력 스트림 >>보조입력스트림1>>보조입력스트림2 ... >> 프로그램>>보조출력스트림1 >> 보조 출력스트림2 ...>>기본 출력 스트림
							: 기본 스트림과 프로그램 사이에 샌드위치 됨

			
					: import 해야하는 것들
						1. java.io.IOException 
							: 물론 thorws Exception 하면 따로 불러올 필요는 없음
						2.  java.io.보조스트림클래스
						3.  java.io.기본스트림클래스
							: 레퍼런스변수 타입으로 쓰이거ㅓ나, 생성자 쓰이는 기본 스트림 클래스 모두


					: 보조 기능
						1. 데이터 타입 변환해서 입출력
							: 바이트 기반ㄴ 스트림의 경우 문자 기반 스트림으로 만들어야하는 상황이 꽤 있는데( 바이트 단위로는 유니코드 못 읽으니까) 이때 필요함
							: 문자 변환 보조 스트림) 
								: 보조스트림명 == 원래스트림의최상위클래스명+바꾸자하는스트림의최상위클래스명
									: 최상위클래스의 하위 클래스중 어떤 하위 클래슨지는 param 으로 대입되는 객체로 자동으로 추론해서 하위 클래스명은 생략하게 한 것 같다
									ex) OutputStream fos = new  FileOutputStream(경로); Writer osw = new OutputStreamWriter( fos ); // osw == Writer 클래스의 하위 클래스중 FileWriter 클래스의 객체로 인식됨

								:보조스트림 객체 생성 형식
									 new 보조스트림타입( 기반스트림 객체) ;
										: 기반 스트림 객체로는 직접  괄호 내부서 객체 생성해도 되고 밖에서 미리 객체 만들고 이를 가리키는 레퍼런스 변수를 대입해도 됨

								: 보조스트림 객체 참조 변수
									(1) 변환한 스트림 타입의 참조 변수 (보통 변환한 스트림 타입의 최상위 클래스)
										ex) Writer osw = new OutputStreamWriter( 파일경로 );

									(2) 보조스크림 타입의 참조변수
										ex) OutputStreamWriter ows = new  OutputStreamWriter( 파일경로 );

								: 종류	
									1. OutputStreamWriter
										: 생성자) OutputStreamWriter( OutputStream os) 
					
									2. InputStreamReader
										: 생성자) InputStreamWriter(InputStream is) 
											
								
						2. 입출력 성능을 향상 (버퍼 관련)
							: 기본적으로 존재하는 작은 버퍼와 별개로 추가적인 버퍼를 제공받기 위해 보조 스트림을 사용			
								: 버퍼 ) 데이터 쌓이기를 기다렸다가 꽉 차게 되면 그제서야 데이터를 장치로 보냄으로써 출력 횟수를 줄여 결국 프로그램 실행 속도를 향상시키는 역할을 함 
									: 프로그램과 버퍼 간에는 고속 전송이 된다
									

								: 기본적으로 입출력스트림은 내부에 "작은" 버퍼를 가지긴 함.
									: 그래서 입출력 성능 향상 보조 스트림을 사용하지 않아도 출력스트림 다 썼음 flush ( ) 해줘야 되는것 (물론 close( ) 에 내장돼있어서 직접 flush (  ) 라고 쓰진 않지만)
									: 주의해야할 것은 입력 스트림에도 버퍼가 존재한다( flush( ) 가 있진 않지만)			
								: 버퍼를 비운다 ==  " 버퍼 ----> 목적지 " 로 실제로 데이터 전송한다
									: 버퍼 비우는 기준
										: 출력 스트림의 버퍼 == 버퍼가 꽉 차면
										: 입력 스트림의 버퍼 == 얘는 기준이 뭔지 모르겠음
					
			
							: 성능향상 보조스트림)
								: 보조스트림명 == Buffered기반스트림의최상위스트림
									: 마찬가지로 어떤 하위 스트림을 쓸껀지 직접적으로 명시하진 않고, 객체 생성 당시 param 으로 들어오는 객체의 타임을 자동 인식한다

								: 보조스트림객체 참조변수 선언
									(1) 최상위 클래스 타입으로 선언
										 보조스트림도 InputStream , OutputStream, Reader , Writer 의 최상위 클래스의 하위 클래스 들이라 가능 
									(2) 딱 보조스트림객체의 타입에 맞춰 선언
 
								: 종류)
									1. 바이트 기반 스트림
										(1) BufferedInputStream
											: 
											: 생성자
												BufferedInputStream(InputStream os)
										(2) BufferedOutputStream
											: 버퍼가 다 차야지 데이터를 실제로 목적지로 출력한다
											; 생성자
												BufferedOutputStream(OutputStream os)

									2. 문자 기반 스트림
										(1) BufferedReader
											: String readLine( ) 메서드 제공 
												: 라인 단위(엔터단위)로 문자열을 읽음 << 문장 읽어야되는 상황이면 개유용(기본 스트림의 read( )차원에선 문자 배열 혹은 문자 단위로 밖에 못가져옴)
													: 엔터를 포함하여 버퍼에서 가져오되 엔터는 버림 (엔터 이전 까지의 내용만 실제로 저장함)
													: 라인 단위 == 줄바꿈 == 엔터 == '\r'+'\n'
												: 더이상 읽어올 문자열이 없으면 null 을 리턴
						
							ㅇㄷ



(2) BufferedWriter
					

					: 종류
						문자 변환보조스트림




자바 입출력 스트림의 인코딩 방식	
	: 기본적으로 플랫폼의 기본 인코딩 방식을 따르기 때문에 파일의 인코딩 방식이 ANSI 일 경우, ANSI 로 인코딩 되고, 파일의 인코딩 방식이 UTF-8일 경우 UTF-8 로 인코딩됨
		: 파일 인코딩 방식 == 파일에 저장된 정보의 형태를 부호화 하는 방식

			ASCII : 최초의 문자열 인코딩
				: American Standard Code ... 어쩌구 >> 영어를 위한 문자 코드
				: 한 문자 == 7 비트

			ANSI : 
				: American National Standard 어쩌구 >> ASCII 의 확장판
				: ASCII 에서 1 비트를 더 써서(8비트) 다른 언어의 문자까지 표현
				: 1 비트를 CodePage 로 사용
					: CodePage 없는 것보단 낫겠지만 그래도 여전히 호환성 떨어진다
				: 한 문자 == 8비트

			Unicode
				: 전 세계서 사용하는 문자를 표현한 코드

			UTF-8
				: Unicode 기반으로 저장하는 거

	: append 를 위하여든 write를 위하여든 파일과 연결되는 출력 스트림이 바이트 스트림일 경우 파일의 인코딩 방식이 무조건 바뀐다 ( 바이트 스트림은 바이트 값 기준이니까 기존의 인코딩 방식이 뭐였건 ANSI 로 무조건 되는거) . 만약에 기존 파일의 인코딩 방식을 유지하고 싶으면 코드의 첨부터 끝까지 문자 스트림을 사용하여 파일을 열어야한다		
		: 그러니까 바이트 스트림으로 출력 스트림 열었던 이력이 있으면 ( 아무리 해당 출력 스트림을 close( ) 했더라도 ) 후에 문자 스트림을 이용해서 유니코드를 append 하거나 아예 새로 write 하더라도 여전히 ANSI 인코딩 방식이기에 파일이 존나 깨진다
		: 근데 바이트 스트림을 문자 스트림화 시키는 보조 스트림을 생성하는 과정에서 바이트 스트림으로 파일을 처음에 열었더라도 보조스트림을 통하여선 UTF-8 로 제대로 입력되는데 이런 예외도 있는 것 같아

	: 왜 ANSI 로 인코딩된 파일을 바이트 스트림, 문자 스트림으로 읽어왔을때 읽은 값의 개수 차이는 2배인데 UTF-8 로 인코딩된 파일을 바이트 스트림 , 문자 스트림으로 읽어올땐 읽은 값의 개수 차가 2배가 아닌것일까
		: UTF-8 인코딩 방식은 가변길이문자 인코딩 방식이라 값의 타입에 따라서 부여하는 크기가 다르다. (들쭉날쭉하다) 
			: ASCII 해당 문자는 1바이트 가지고. 대부분 문자는 3바이트 크기를 가진다.




	
다형성을 활용하여 코드를 짠다.
	: 최상위클래스타입으로 참조변수 만들고 하위 클래스의 객체를 참조한다
		ex ) 
			OuputStream os = new FileOutputStream( "파일 경로" ) ;

	
			

	: 종류
		1. 입력스트림
			: 프로그램이 외부로부터 데이터를 받는 경우

		2. 출력스트림
			: 프로그램이 외부로 데이터를 전달하는 경우
