프로그램은 데이터를 다양한 곳으로부터 출력, 입력 가능
	: 키보드, 모니터, 파일, 네트워크

IOException
	: 자바는 입출력 관련해서 ㅈㄴ 깐깐하다
	: 문제가 발생할 수 있는 경우 예외 문구를 띄워서 문제를 조기 차단하는데 , 입출력의 경우 아예 사용하기만 하면 예외를 발생시킨다
		: print 메서드와 scanner 클래스를 쓸때 예외가 발생하지 않은건 자체적으로 예외처리를 해놔서 그렇다(api 사전보면 thorws IOException 처리가 되있음을 알 수 있음)
			: 주의할 것은 scanner 의 모든 생성자에 throws IOException 처리가 되있는게 아니란 거다 (InputStream 을 매개변수로 하는 생성자는 throws 로 처리되있지만 파일객체를 매개변수로 하는 생성자는 처리 안되있다)

스트림 Stream
	: 단방향의 연속적인 흐름
	: tip ) 
		: 최상위 클래스의 경우 바이너리가 일반적으로 많이 접했던 스트림이고, 문자 기반 스트림은 뭔가 진짜 책(?)적인 느낌이다(독자 Reader, 작가 Writer). 근데 주의해야될것은 바이트 스트림 ,문자 스트림 모두 의 하위 클래스에 write( 어쩌구 ) 를 사용해 출력하고 , read ( 어쩌구 ) 를 사용해 입력받는다 

		: 해당 클래스의 접미사는 최상위 클래스를 나타낸다	
			: ex)   XXXInputStream >> InputStream이 최상위클래스
			: 해당 클래스의 최상위 클래스를 알게되면 어떤 종류의 stream 인지 파악 가능하다 (출력용인지 입력용인지 파악 가능해진다)

		: 해당 클래스의 접두사는 어떤 걸 대상으로 작동하는지 나타낸다
			: ex) FileXXXX >> 파일을 대상으로 입력 or 출력한다


		: 입출력 스트림에서 byte, char 씩 입출력 한다고 할때 숫자 범위로써 byte char 이러는게 아니라 크기로써 byte char 이러는 거라 byte 의 범위는 0~255 간주, 바이트 스트림의 경우 0~255 크기의 값을 입출력하는것.


		: 바이트. 텍스트 기반 스트림의 최상위 클래스는 모두 추상 클래스로, 그 자체로 쓰이지 않고 일정한 규격의 하위 클래스를 생성하기 위한 용도로 존재하는거다

		: javaj.io 패키지를 사용하면 코드가 맞았던 틀리건간에 에러가 나는데 해결 방법
			1. try ... catch 구문 사용
				: java.io.IOException 을 catch 내부에서 사용하기 때문에 별도로 import 필요
				: 장점은 try 문 괄호 부분에 스트림 객체 쓰면 try 구문의 종료시 자동으로 close( ) 해줌
				: 형식	
					try( 스트림 객체 생성 ){
					... 수행할 내용
					}catch( IOException e ){
						e.printStackTrace( );
					}

			2. main 메서드 선언 부에 throws Exception 추가
				: 에러 처리 위해 별도로 import 할	건 없는게 장점 		
				: 자동으로 close( ) 안해줘서 별도로 해줘야됨
				: 형식)
					public static void main(String[ ] args) throws Exception{
						수행할 내용
					} 
	
		: java.io 패키지의  하위클래스를 사용하는 경우 아래 3가지를 기본적으로 import 해준다
			1.  java.io.해당클래스의최상위클래스 ;
				: 보통 다형성 구현을 위하여 하위 클래스의 객체를 참조하는 변수를 부모타입으로 선언하기 때문에 직접적으로 각 스트림읭 최상위 클래스의 객체를 생성하지 않더라도(생성 안하는게 아니라 못하는 거긴 하지만 - 추상 클래스니까) 같이 import 해주는 편이다.
					ex ) InputStream fis = new FileInputStream("C:/SelfStudyJava/chap14/binarytest.db");

			2.  java.io.해당클래스;
			3.  java.io.IOException;
				: java.io 패키지의 클래스 사용하면 필수적으로 에러나는 걸 해결할때  try ...catch 구문을 사용하는 경우 import 필요 (만약에 걍 throws Exception 할꺼면 굳이 import 안해줘도 됨)
				


		: flush 는 왜 사용하는가?
			: 데이터를 입력, 출력하는 메서드를 쓰면 이터가 바로 입출력되는게 아니고 	버퍼라는 임시 저장 공간에 저장되어있다가 그 공간이 다 차면 버퍼를 비워 비로소 데이터를 실제로 입출력한다.  버퍼를 다 채우지 못한 상황에서도 버퍼를 비우기 위해 flush 를 사용ㅇ하는거다

			: 사실 close 썼음 flush 를 쓸 필요없다
				: close 기능 =  flush 기능 +  스트림 폐쇄


		: 리소스를 닫아야하는 이유
			: 예를 들어 파일이 열려있음 다른곳에서 사용을 못하고 닫혀 있어야만 열 수 있다

		: IoException
			:FIleNotFoundException 의 최상위 클래스다.
				: 그래서 catch 괄호내부에 FIleNotFoundException e 를 써도 되긴하지만 범용성을 위해 IOException e 쓰는거다 

		: 바이트 파일의 경우 문자열의 형태가 아니기 때문에 메모장으로 확인을 못한다. 
			: 내용 확인/유추 방법
				sol 1. 파일의 속성 탭을 누르면 몇 바이튼지 크기 나오는걸로 통해 유추가 가능하다
				sol 2. 바이트 인풋 스트림을 이용해 get 

		: 바이트 스트림의 경우 바이트란 이름에 걸맞게 1바이트씩 거래한다
		: 스트림은 그림에서도 추론 할 수 있듯이 FIFO로 작동한다
			: 먼저 입력된 내용부터 쓰여지기 시작한다
		: close( )를 제외한 입력 스트림의 메서드는 모두( 바이트 스트림이건 문자 스트림이건) 
			: 메서드 종류 
				: ( close( ) 제외하고 )  죄다 read( 어쩌구 ) 꼴
					: flush( ) 가 없다 

			: 반환
				: 반환 타입 ) int 형이다
				: 반환값
					1. eof 에 도달하면 -1 을 반환한다
					2. eof 가 아니면 
						(1) arg 가 없는 read ( ) 를 제외하곤 읽는데 성공한 값의 개수를 반환한다 << 주로 conunt 변수로 이를 저장해둔다
						(2) arg 가 없는 read( ) 의 경우 읽은 값을 반환한다 (int 형으로)
	
		: 출력 스트림의 메서드는
			: 메서드의 종류
				1. write ( 어쩌구 ) 꼴
					: write( ) 로 값 딱 하나만 읽어오는 경우 param 타입이 int 긴 한데 int 란 사실은 잊어버리고 그냥 바이트 스트림이면 바이트값, 문자 스트림이면 문자값을 arg 로해라. 
						: param 으로 int 값 받아도 에러는 안나는데 실제로 출력되는건 끝의 1바이트, 2바이트씩만 실제로 출력된다고 한다  (param 값이 곧 출력값은 아니다)
				2. close ( )
				3. flush( )

 
			: 반환 타입이 죄다 void 이다
			

		: 출력 스트림의 생성자는
			:  append 여부를 결정하는 param 도 있다
				: 암것도 안쓰면( 디폴트 ) false 고 , append 안하겠단 뜻 된다
					: true 를 쓰면 append 하겠단 뜻 된다
					


			

		: 파일 끝까지 읽는 tip	
			: count 를 사용하여 평소엔 읽어온 값ㅇ의 개수 저장하다 eof 에서 -1 입력 받음 종료함
			int count = 0 ;
			while(  (count = 스트림객체.read( 어쩌구) ) != -1 ) {

			
			}

		: 입력받은 내용을 저장한 배열을 출력하는 tip
			: tip 이란게 있어야되는게 (걍 암 생각 없이 배열 활용하면 안되는게) 항상 배열의 크기만큼 데이터가 가져와지는게 아니라 마지막 차례에서 배열을 꽉 채우지 못하고 입력을 받을 수 있기 때문
			: 공통
				파일 읽는데 쓰이는 whille 문 내부서 ary 객체를 생성한다( 한 턴 돌때마다 새로운 객체 생성 )
					: 그래야 지속적으로 모든 인덱스가 0 으로 초기화 되서 입력 안된 부분을 null 값을 통해 구별 가능하다
					: 만약에 처음에 생성했던 객체를 계속 쓴다면 이전에 받았던 내용을 덮어쓰기 하는 방식으로 진행되는데 마지막 턴에서 새롭게 입력받지 않은 인덱스에도 이전턴에 입력받은 값이 남아있어 혼란을 야기할 수 있다(+ null 값으로 구별이 불가하다)

			1. count 변수를 적극활용 : 자동적으로 실제로 입력받은 부분까지만 출력한다 << 강추
				for(int i  = 0 ; i  < count ; i++){
					ary[i] 값 활용
				}
					
	
			2. null 값을 통해 실제로 입력 받은 부분을 파악 :
				(1) 걍 for 문

					for(int i  = 0 ; i  < count ; i++){
						if ( ary[ i ] != 0) ary[i] 값 활용
					}

				(2) 향상된 for문
					for( byte b : ary) {
						if ( b != 0) b 값 활용
					}

	: 패키지
		java.io
			: 여러가지 스트림 클래스를 제공
	
				(1) 기반 스트림
					1. 바이트 기반 스트림
						: 바이너리 데이터를 읽고 출력할 때 사용
							: 바이너리 데이터 ) 데이터 형태 그대로 저장
								: 이미지 등등
						: 세부 종류
							(1) (바이트)입력스트림
								: 최상위 클래스 ) InputStream
									: 추상클래스다
									: 메서드종류
										int read( )
											: 1 바이트를 읽고, 읽은 값의 int 타입버전값 혹은 -1을 리턴
												: -1 == EOF 나타내는 값
													: 이거 이용해서 파일 끝까지 읽을 수 있다
												: 읽기는 바이트로 읽고 실제로 가져오는기는  int 타입임을 주의													: 끝부분만 진또배기고 앞 3바이트는 죄다 00000000 00000000 00000000 이다


										int read(byte[ ] b)
											: 읽은 값은 "매개값으로 주어진 배열"에 저장하고, 읽은 바이트 수를 "반환"한다
												: 그냥 read( ) 와는 다르게 반환값이 읽은 값이 아님에 주의
												: 똑똑하게 실제로 읽은 바이트 수를 반환함을 주의 
													: 항상 배열 사이즈를 반환하는게 아니다(배열을 꽉 채워 받지 못하는 경우도 있을 수 있으니까)
	
										int read(byte[ ] b, int off ,int len)
											: 

										void close( )

								: 하위 클래스
									: InputStream 의 구현 클래스들
										FileInputStream
										BufferedInputStream
										DataInputStream

									
									


							(2) (바이트)출력스트림	
								: 최상위 클래스 ) OutputStream
									: 추상 클래스
										: 메서드
											:  return 값이 출력값이 아님을 주의( 반환형이 다 void 이다)
												: return 은 프로그램내에서 반환되는 값이지 외부로 반환되는 값이 아니니까 출력 메서드의 반환값이 void 형인건 어찌봄 당연한 일
											1. abstract void write( int b )
												: 존나 웃긴게 받기는 int 값 받았으면서 정작 출력은 1바이트만 출력한다
													: 그러니까 int 값을 이루는 4 바이트 중 젤 오른쪽의 1 바이트만 들어가는거다 (-128~127의 숫자만 가능)

											2. void write( byte[ ] b)
												: 매개값으로 주어진 배열 b 의 "전체"를 "한번에" 출력한다
													: 배열이 끝까지 채워져있던 말건간에(null 값이던 아니던) 배열 전체 사이즈를 출력하는거 주의  

											3.  void write( byte[ ] b , int off , int len)
												: 매개값으로 주어진 배열 b에서 b[off] 부터 len 개의 내용을 출력한다(배열의 일부를 출력한다)
													: 가장 마지막 매개변수 값이 종료 인덱스가 아니라 출력 갯수임을 주의

											4. void flush( )
												: 출력 버퍼가 다 차지 않아도 잔류하는 모든 바이트를 출력한다
													: 프로그램 중간중간에 데이터 저장하고 싶음 사용한다

											5. close ( )
												: 출력 스트림을 닫는다 + flush 기능 수행한다
												: 안전하게 close 하는 법
													1. AutoCloseable 활용
														: try 구문에 괄호 치고 그 내부에서 스트림 객체 참조변수를 넣으면 try 구문의 종료시 자동으로 close ( ) 실행된다. (자동리소스닫기)
															: 여러 객체를 한번에 넣을 수 있다. 이때 각 객체는 ; 로 구분해놓는다
														: 주의 ) 모든 스트림 객체에 사용 가능한건 아니고 AutoCloseable 이란 인터페이스를 구현한 스트림 클래스에 대하여 가능 ( 근데 대부분 AutoClosealbe 을 구현하긴 한다)
															
														: try( 스트림 객체참조변수 ){
														}
														catch( ){  }
														
													2. 예외구문에 finally 추가
														: finally 는 예외가 발생했건 안했건 꼭 실행되는거 이용하는것 이용
														: 근데 이거 쓰면 이상한 에러 나는데 나중에 확인

														try{

														리소스 오픈& 활용 코드

														} catch{
														예외발생시 발생시킬 오류 문구
														} finally{
															리소스객체.close
														}
	
												: 불안전한 close
													: try 블럭 내부에서 리소스 객체를 close 하는 것
														: try블럭의 경우 블럭 실행하다가 예외 발생함 뒤에 코드는 실행을 안하기 때문에 close 가 실행이 안될  수 있다.

								: 하위 클래스
									: 최상위 클래스의 실체 클래스들
									: 종류
										FileOutputStream
											: 파일로 출력하는 스트림
											: 생성자
												FileOutputStream( String name, boolean append)
													: 첫 param 으로 파일명을 받음
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


												FileOutputStream(Filen f, boolean append)
													: 첫 param 으로 파일 경로를 받음 
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


										PrintStream
										BufferedOutputStream
										DataOutputStream


					2. 문자 기반 스트림
						: 텍스트 데이터를 주고 받을 때 사용
							: 텍스트 데이터 ) 문자로 읽기 가능한 형태로 저장

						: 세부 종류
							: (write( )로) 문자열 타입을 출력할 수 있지만 (read( )로 )문자열 타입으로 입력은 못받는거 주의
							(1) (텍스트)입력스트림
								: 최상위클래스 ) Reader
									: 추상클래스
									: 메서드)
										: 문자 배열 단위로 불러올 순 있어도 문자열 단위론 못불러옴 << 문장 단위로 받아오고 싶다묜 보조스트림 사용
										int read( ) 
											: 1개의 문자를 읽고 이를 int 타입으로 리턴
												: 문자 == 2바이트 이므로 한글까지 입력받을 수 있다
												: 반환값이 읽은값임에도 불구하고 char 타입이 아니라 int 타입인거 주의. 읽은 값을 문자로 사용하고 싶음 강제형변환 해줘야됨
													: 왜 굳이 int 형으로 만들었을까
														: char 타입의 경우 음수를 표현못해서 일단 int 타입으로 확장 시켜 반환한듯?
												
										int read(char[ ] cbuf)
											: 매개변수로 주어진 문자배열의 사이즈 갯수만큼 문자를 입력받아 저장하고, 입력성공한 개수 혹은 -1  (eof) 을 반환함
										int read(char [ ] cbuf , int off , int len)
										void close( ) 
	
								: 하위 클래스)
									: Reader 클래스를 상속 받아서 만들어짐
									: 종류
										FileReader
										BufferedReader
										InputStreamReader


							(2) (텍스트)출력스트림
								: 최상위클래스 ) Writer
									: 추상 클래스
									: 주요 메서드
										: param으로 String 타입도 가능
										void write( int c )
											: 신기하게도 또( 바이트 스트림에서도 한개 단위로 출력할때 출력하는 값의 타입이 int 도 아니면서 매개변수 타입 int 였음) 출력하는 값은 char 형 이면서 매개변수 타입은 int 형임
												: 어쨌뜬 걍 char 형 값을 arg 로 함 된다
												: char 범위 넘어서는 int 값은 안됨을주의? 맞니?

										void write( char[ ] cbuf )
											: 매개값으로 주어진 문자 배열의 값을 한번에 출력함
											:
										void write(String str)
											: 매개값으로 주어진 문자열을 한번에 보냄

										void write( char[ ] cbuf, int off , int len )
											: 매개값으로 주어진 문자배열에서 시작 인덱스와 보낼 값의 개수를 지정하여 출력함
										
										void write( String str , int off , int len)
											: 매개값으로 주어진 문자열에서 시작 문자와 보낼 문자의 개수를 지정하여 출력함

										void flush( )
											: 버퍼에 잔류하는 모든 문자를 출력

										void close( )
											: 출력 스트림을 닫음  

								: 하위클래스
									: Writer 클래스의 구현 클래스들
									: 종류
										FileWriter

											: 생성자
												FileWriter( String name, boolean append)
													: 첫 param 으로 파일명을 받음
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


												FileWriter(Filen f, boolean append)
													: 첫 param 으로 파일 경로를 받음 
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨

										BufferedWriter
										PrintWriter
										OutputStreamWriter

				(2)보조스트림
					: 기본 스트림을 보조하는 스트림
						: 기본 스트림 없이 혼자선 못씀 
						: 기본 스트림만 존재한다면 한번에 여러개의 보조 스트림을 사용 가능

					: 삽입 위치
						: 기본 입력 스트림 >>보조입력스트림1>>보조입력스트림2 ... >> 프로그램>>보조출력스트림1 >> 보조 출력스트림2 ...>>기본 출력 스트림
							: 기본 스트림과 프로그램 사이에 샌드위치 됨

			
					: import 해야하는 것들
						1. java.io.IOException 
							: 물론 thorws Exception 하면 따로 불러올 필요는 없음
						2.  java.io.보조스트림클래스
						3.  java.io.기본스트림클래스
							: 레퍼런스변수 타입으로 쓰이거ㅓ나, 생성자 쓰이는 기본 스트림 클래스 모두


					: 보조 기능
						1. 데이터 타입 변환해서 입출력
							: 바이트 기반ㄴ 스트림의 경우 문자 기반 스트림으로 만들어야하는 상황이 꽤 있는데( 바이트 단위로는 유니코드 못 읽으니까) 이때 필요함
							: 문자 변환 보조 스트림) 
								: 보조스트림명 == 원래스트림의최상위클래스명+바꾸자하는스트림의최상위클래스명
									: 최상위클래스의 하위 클래스중 어떤 하위 클래슨지는 param 으로 대입되는 객체로 자동으로 추론해서 하위 클래스명은 생략하게 한 것 같다
									ex) OutputStream fos = new  FileOutputStream(경로); Writer osw = new OutputStreamWriter( fos ); // osw == Writer 클래스의 하위 클래스중 FileWriter 클래스의 객체로 인식됨

								:보조스트림 객체 생성 형식
									 new 보조스트림타입( 기반스트림 객체) ;
										: 기반 스트림 객체로는 직접  괄호 내부서 객체 생성해도 되고 밖에서 미리 객체 만들고 이를 가리키는 레퍼런스 변수를 대입해도 됨

								: 보조스트림 객체 참조 변수
									(1) 변환한 스트림 타입의 참조 변수 (보통 변환한 스트림 타입의 최상위 클래스)
										ex) Writer osw = new OutputStreamWriter( 파일경로 );

									(2) 보조스크림 타입의 참조변수
										ex) OutputStreamWriter ows = new  OutputStreamWriter( 파일경로 );

								: 종류	
									1. OutputStreamWriter
										: 생성자) OutputStreamWriter( OutputStream os) 
					
									2. InputStreamReader
										: 생성자) InputStreamWriter(InputStream is) 
											
								
						2. 입출력 성능을 향상 (버퍼 관련)
							: 기본적으로 존재하는 작은 버퍼와 별개로 추가적인 버퍼를 제공받기 위해 보조 스트림을 사용			
								: 버퍼 ) 데이터 쌓이기를 기다렸다가 꽉 차게 되면 그제서야 데이터를 장치로 보냄으로써 출력 횟수를 줄여 결국 프로그램 실행 속도를 향상시키는 역할을 함 
									: 프로그램과 버퍼 간에는 고속 전송이 된다
									

								: 기본적으로 입출력스트림은 내부에 "작은" 버퍼를 가지긴 함.
									: 그래서 입출력 성능 향상 보조 스트림을 사용하지 않아도 출력스트림 다 썼음 flush ( ) 해줘야 되는것 (물론 close( ) 에 내장돼있어서 직접 flush (  ) 라고 쓰진 않지만)
									: 주의해야할 것은 입력 스트림에도 버퍼가 존재한다( flush( ) 가 있진 않지만)			
								: 버퍼를 비운다 ==  " 버퍼 ----> 목적지 " 로 실제로 데이터 전송한다
									: 버퍼 비우는 기준
										: 출력 스트림의 버퍼 == 버퍼가 꽉 차면
										: 입력 스트림의 버퍼 == 얘는 기준이 뭔지 모르겠음
					
			
							: 성능향상 보조스트림)
								: 보조스트림명 == Buffered기반스트림의최상위스트림
									: 마찬가지로 어떤 하위 스트림을 쓸껀지 직접적으로 명시하진 않고, 객체 생성 당시 param 으로 들어오는 객체의 타임을 자동 인식한다

								: 보조스트림객체 참조변수 선언
									(1) 최상위 클래스 타입으로 선언
										 보조스트림도 InputStream , OutputStream, Reader , Writer 의 최상위 클래스의 하위 클래스 들이라 가능 
									(2) 딱 보조스트림객체의 타입에 맞춰 선언
 
								: 종류)
									1. 바이트 기반 스트림
										(1) BufferedInputStream
											: 생성자
												BufferedInputStream(InputStream is)
										(2) BufferedOutputStream
											: 버퍼가 다 차야지 데이터를 실제로 목적지로 출력한다
											; 생성자
												BufferedOutputStream(OutputStream os)

									2. 문자 기반 스트림
										(1) BufferedReader
											: 생성자
												BufferedReader(Reader rd)
													: 주의해야될것은 BufferedReader 는 (InputStream 을 Reader 로 바꾸고자 쓰는게 아니라) BufferedReader 만의 메서드인 readLine( ) 을 쓰기 위해 사용하는 보조 스트림이기 때문에 BufferedReader 로 생성한 객체는 BufferedReader 타입의 변수로 받아야된다(아니면 굳이 쓴 이유가 없다)
											: String readLine( ) 메서드 제공 
												: 라인 단위(엔터단위)로 문자열을 읽음 << 문장 읽어야되는 상황이면 개유용(기본 스트림의 read( )차원에선 문자 배열 혹은 문자 단위로 밖에 못가져옴)
													: 엔터를 포함하여 버퍼에서 가져오되 엔터는 버림 (엔터 이전 까지의 내용만 실제로 저장함)
														: 엔터 버리고 저장하는거 진짜 주의
													: 라인 단위 == 줄바꿈 == 엔터 == '\r'+'\n'
												: 더이상 읽어올 문자열이 없으면 null 을 리턴
						
							3. 기본타입입출력보조시스템
								: 기본 타입( boolean, char, short , int ..) + 자주쓰는 클래스인 String 타입을 입출력할 수 있음
									: Interger, Character 말하는게 아니라 찐으로 기본타입들을 말하는 거다
								: 주의해야할 것은 기반 스트림으로  바이트 스트림만 사용 가능
								: 종류
									(1) DataInputStream
										: 생성자
											DataInputStream(InputStream is)
												: 마찬가지로 일반적인 InputStream 에는 없는 메서드를 사용하기 위함이므로 생성한 객체는 InputStream 으로 받음 안되고 딱 DataInputStream 으로 받아야된다
										: 메서드 >> read기본타입( ) 꼴 (String 은 예외적으로 UTF)
											1. boolean readBoolean()
											2. byte readByte()
											3. short readShort()
											4. char readChar()
											5. int readInt()
											6. long readLong()
											7. float readFloat()
											8. double readDouble()
											9. String readUTF()
												: 내가 봤을땐 UTF-8 말하는 듯?




									(2) DataOutputStream
										: 메서드 >> write헤딩타입( 매개변수  ) 꼴
											: 매개변수 타입 tip >> 싱수 대입할때의 상수 타입과 비슷(int 이하 정수 >> int , long 정수는 long ,boolean 은 boolean , float 는 float , double 은 double)
											1. void readBoolean(boolean v)
											2. void readByte(int v)
											3. void readShort(int v)
											4. void readChar(int v)
											5. void readInt(int v)
											6. void readLong(long v)
											7. void readFloat(float v)
											8. void readDouble(double v)
											9. void readUTF(String v)

							4. 프린터 보조 스크린
								: 출력하는 메서드를 가지는 보조 스트림
								: System.out 도 출력보조스트림 이라서 println() , print( ) 같은거 쓸 수 있었던거임
									: System.out >> PrintStream 타입
								: 종류
									(1) PrintStream
										: 특이하게 짝꿍은 PrintWirter 이지만 PrintOutputStream 가 아니라 PrintStream 임을 주의
					 					: 생성자
											PrintStream(OuputStream os)

									(2) PrintWriter
										: 생성자
											PrintWriter(Writer w)
								: 메서드 
									: PrintStream 과 PrintWriter 가 똑같은 메서드 사용험
									: print, println 이 오버라이딩 되있는 구조임
									:종류
										void print(여러가지 자료형타입의 매개변수)
										void println(여러가지 자료형타입의 매개변수)
											: 끝에 '\n' 자동 추가해 출력
												: 그러니까 파일과 연결된 스트림에서 println 쓰면 자동으로 줄바꿈 되서 파일로 출력되는거다
													: println 과 readLine( ) 의 궁합이 좋다
											: print() 메서드와 다르게 괄호 안에 암것도 안넣은 버전도 오버라이딩 되있어서 괄호 안에 아무런 arg 없이도 사용 가능											

							5. 객체 입출력 보조 스트림
								: 메모리에 생성된 객체를 파일 or 네트워크로 출력함
								: 기반 스트림은 바이트 스트림만 가능
									(1)ObjectInputStream
										: 객체를 역직렬화함
											: 역직렬화 ) 직렬화 된걸 복원하는 것
												: 바이트 배열을 객체로 복원하는 것
										: 생성자
											ObjectInputStream(InputStream is)
										: 메서드
											object readObject()
												: 리턴 타입이 object 타입이기 때문에 강제형변환해서 사용해야됨
												: 왜그런지 몰라도 예외 발생시키기 때문에 throws Exception 처리하고 써야된다
									(2)ObjectOutputStream
										: 객체를 직렬화 함
											: 직렬화 ) 객체를 바이트 배열로 만드는 것	
												: 모든 객체가 직렬화 가능한 건 아니고 Serialable 인터페이스의 구현 객체일때만 가능하다
										: 생성자
											void writeObject(Serialable sa)
												: 객체를 직렬화 해서 출력함
																								


: 입출력 관련 API
	: API == application programming interface
		: 응용프로그램에서 사용할 수 있게 만든 (어떤 기능을 가진) 인터페이스

	: 입출력관련 API 는 기반 스트림과 보조 스트림을 사용하여 다양한 기능들을 제공한다

	: 콘솔 console
		: 시스템을 사용하기 위해 키보드로 입력받고 모니터로 출력하는 솦웨어
		: 종류
			: 유닉스 , 리눅스 운영체제 >> 터미널
			:  윈도우 운영체제 >> 명령 프롬프트

	: 이클립스의 콘솔 
		: 키보드로 입력받고 내영ㅇ,ㄹ 출력
		: how 입력받을까
			System.in 
				: System == 클래스
				: in
					: 콘솔에서 키보드로 입력된 데이터를 읽기 위해 사용하는 필드
					: System 클래스의 정적 필드로, InputStream 타입이다.
						: public static final InputStream in ;
						: InputStream 타입의 변수 처럼 활용 가능하다
							: 그래서 사실 read( )  같은 것도 쓸 수 있다
							: ex)
								InputStream si = System.in;
								int keyCode = si.read( ); // 한 바이트 읽어온다

								Reader reader = new InputStreamReader(si); // InputStream 타입의 스트림을 기반스트림으로 하여 보조스트림을 활용하여 Reader 타입으로 변환

								BufferedReader br = new BufferedReader( reader );
								String str = br.readLine( ); // BufferedReader 타입의 스트림을 활용하여 문장을 읽어온다


			System.out 
				: System == 클래스
				: out
					: 콘솔에서 모니터로 데이터를 출력하기 위해쓰는 필드
					: System 클래스의 정적 필드로 , PrintStream 타입이다
						: public static final PrintStream out
						: PrintStream 타입의 변수처럼 사용이 가능하다
							: 그래서 print( ) , println( ) , printf( ) 같은 걸 쓸 수 있는거다

			

			System.err >> 노코멘트

			Scanner 클래스
				: 입출력 스트림도 아니고 보조 스트림도 아님
					: 그래도 스캐너 썼음 close( ) ;해야된다
				: 문자 파일이나 바이트 기반 입력스트림에서 모두 사용 가능한 클래스
					: 객체를 만들어 사용한다
					: 근데 특이한건 생성자 매개변수로 InputStream 는 있는데 Reader 타입 매개변수인건 없음
				: java.util.Scanner
					: 유명한 생성자 (생성자 여러가지 오버라이딩 되있긴한데 뭐 지금까지 써본적이 없음)
						1. Scanner( InputStream is )
							: 그래서 Scanner 객체 만들때 System.in 을 arg 로 넣어서 만들었던거

						2. Scanner(File source)
							: 파일 객체를 매변으로 함
						3.  Scanner(String source)
							: 경로 ? 뭐 그런것같다
				: 제공 메서드
					( 1 ) 닫기
						1. void close( ) 
							: 스캐너 객체도 닫는다
					(2) 문자열 읽기
						1. String next( )
							: 단어단위로 읽음(화이트스페이스를 단위로 구분하여 문자열을 읽음)
								: 단순 띄어쓰기나 탭으로도 구분 가능
						2.  String nextLine( )
							: 문장단위로 읽음(띄어쓰기가 아닌 엔터를 기준으로 구분하여 문자열을 읽음.)
								: 엔터까지 버퍼에서 꺼내오는거 맞는데 가져오는 과정에서 엔터 버림(엔터까지 읽어오진 않음)

					(3) 기본타입 읽기 << next기본타입( ) 꼴
						: 주의!!! char 타입은 이렇게까지 쉽게는 못읽어옴
						1. byte nextByte( )
						2. short nextShort( )
						3. int nextInt( )
						4. long nextLong( )
						5. float nextFloat( )
						6. double nextDouble( )
						7. boolean nextBoolean( )

					(4) 더 읽어올것이 있는지조사 
						1. boolean hasNext( )
							: 더 읽어올 토큰이 있으면 true, 아님 false 를 반환
								: 토큰은 int 든 boolean 이든 상관없는거다 (next기본타입으로 불러오기 전까진 어차피 다 문자열이다)
						2. boolean hasNext( String pattern )
							: 다음 토큰이 매변으로 넣은 문자열과 일치하면 true 를 반환함 (아니면 당연히 false)
						3. boolean hasNext기본타입( )
							: 특정 타입의 토큰이 바로 뒤에 있는지 검사한다
								(1) boolean hasNextByte( )
								(2) boolean hasNextShort() 
								(3) boolean hasNextInt( )
								(4) boolean hasNextLong( )
								(5) boolean hasNextFloat( )
								(6) boolean hasNextDouble( )

					(5) 값의 구분기준 커스터마이징
						Scanner useDelimiter( String pattern)
							: delimilter 뜻이 구분자란 뜻임



				: char 타입으로 입력받는법
					: String charAt(int index)
						: scanner 클래스의 메서드가 아니라 String 클래스의 메서드임
							: 직접적으로 scanner 객체에 사용ㅇ할 수 있는 메서드는 없고 scanner 로 일단 문자열을 반환받은다음 String 객체를 대상으로 사용해야됨
						: index 는 0 ~ 문자열길이-1 까지 가능ㄴ
						: 사용 ex)
							Scanner scanner = new Scanner(System.in);
							char c =scanner.next( ).charAt(0); // 가장 앞문자를 불러옴

							
			File 클래스
				: 파일 , 디렉토리 정보를 제공하는 클래스
				: java.io.File		
					: 유명한 생성자
						File( String pathname )
							: 파일의 경로를 매변으로ㅏ여 파일 객체 만든다
								윈도우형식 ) c:/SelfStudyJava/test.txt 
								리눅스형식 ) c:\\SelfStudyJava\\test.txt 
									: \\ 처럼 2번 써야되는건 \자체는 이스케이프 문자이기 때문이다
 							: 실제로 해당 경로에 파일이 존재하지 않더라도 예외가 발생하지 않는다
								: FileNotFoundException 은 존재하지 않는 파일경로로 파일 스트림 객체를  생성할떄 발생하는거다
									: 참고로 파일 경로 뿐 아니라 파일 객체로도 파일 스트림 객체 만들 수 있게 되있다 (ex : FileInputStream(File file ) , FileReader(File file))
								: 해당 경로에 파일,폴더가 존재하지 않는다고 해서 새로 만들어주는 것도 아니다
									: 새로 만들려면 별도의 메서드를 사용한다
						File( URI uri )
							: 인터넷 경로같은걸로 파일 객체 만든다

					: 유명한 메서드
						: 뭔가 리눅스 느낌 난다
			
						(1) 파일 경로 유효 여부 검사
							 boolean exists( )
								: 파일객체 생성할때 생성자 부분에 들어갔던 경로가 유효한 경로인지(실제로 존재하는 경로인지) 검사한다

						(2) 파일 경로가 유효하지 않을때 쓰는 유용한 메서드
							: exists( )로 검사했을떄 false 나왔음 햊줄 수 있는 조치이다
							1. boolean createNewFile ( )
								: 새로운 파일을 생성한다 
							2. boolean mkdir( )
								: 새로운 폴더를 생성한다

						(3) 파일 경로가 유효할때 쓰는 유용한 메서드													: exists( ) 검사했을때 true ㅏ나왔을 떄 할 수 있는 조치
							
							1. 삭제
								(1) boolean delete( )
									: 파일 | 폴더 삭제

							2. 권한 검사
								(1) boolean canRead( )
									: 읽기 권한ㄴ 있는 파일인지 여부 화긴

								(2) boolean canWrite( )
									: 쓰기 권한있는 파일인지 여부 확임
	
								(3) boolean canExcute( )
									: 실행권한 있는 파링인지 여부 확인

							3. 파일인지 폴더인지 종류 검사
								(1) boolean isFile( )
								(2) boolean isDirectory( )

							4. 숨김 여부 검사
								(1) boolean isHidden( )		
				
							5. 경로 관련 정보
								(1) String getName( )
									: 파일의 이름을 리턴
								(2) String getPath( )
									: 전체 경로를 리턴
								
							6. 부모 관련 정보
								: 부모로 파일은 불가하므로 이건 폴더를 대상으로만 쓰는거임
									(1) String getParent( )
										: 부모 디렉터리 경로 리턴
									(2) File getParentFile( )
										: 부모 디렉터리를 FIle 객체로 생성한 후 리턴

							7. 자식 관련 정보
								: 파일이 자식을 가질 순 없으므로 이것도 폴더를 대상으로만 씀
									(1) String[ ]  list( )
										:  해당 폴더의 하위 폴더, 파일 목록을 "String 배열" 형태로 리턴
									(2) String[ ] list(FilenemeFileter filter)
										: 해당 폴더의 하위폴더, 파일 중에 filter 를 충족시키는 것만 String 배열 형태로 리턴

									(3) File[ ] listFiles( )
										: 해당 폴더의 하위 폴더, 파일 들을 "File 배열" 형태로 반환
										: 뒤에 s 붙어있는거 주의

									(4) File[ ] listFiles( FilenameFilter filter)
										: 해당 폴더의 하위 폴더,파일  증에 filter 를 충족시키는 것만 File 배열  형태로 리턴

										

							8. 세부정보
								(1) long  lastModified( )
									: 언제 마지막으로 수정됬는지 리턴
										: 날짜와 시간
								(2) long length( )
									: 파일의 크기를 리턴
										: 단위:


String getName( )
								: 파일 이름 리턴
							6. String get Parent( )
								: 부모 폴더 리턴
							7. File getParentFile( )
								: 부모폴더를 파일 객체로 생성하고 리턴
									: 주의할게 FIle 객체라고 해서 그 객체가 파일만 가리키느게 아니라 폴더까지 가리키는걸 잊지 말아야한다



자바 입출력 스트림의 인코딩 방식	
	: 기본적으로 플랫폼의 기본 인코딩 방식을 따르기 때문에 파일의 인코딩 방식이 ANSI 일 경우, ANSI 로 인코딩 되고, 파일의 인코딩 방식이 UTF-8일 경우 UTF-8 로 인코딩됨
		: 파일 인코딩 방식 == 파일에 저장된 정보의 형태를 부호화 하는 방식

			ASCII : 최초의 문자열 인코딩
				: American Standard Code ... 어쩌구 >> 영어를 위한 문자 코드
				: 한 문자 == 7 비트

			ANSI : 
				: American National Standard 어쩌구 >> ASCII 의 확장판
				: ASCII 에서 1 비트를 더 써서(8비트) 다른 언어의 문자까지 표현
				: 1 비트를 CodePage 로 사용
					: CodePage 없는 것보단 낫겠지만 그래도 여전히 호환성 떨어진다
				: 한 문자 == 8비트

			Unicode
				: 전 세계서 사용하는 문자를 표현한 코드

			UTF-8
				: Unicode 기반으로 저장하는 거

	: append 를 위하여든 write를 위하여든 파일과 연결되는 출력 스트림이 바이트 스트림일 경우 파일의 인코딩 방식이 무조건 바뀐다 ( 바이트 스트림은 바이트 값 기준이니까 기존의 인코딩 방식이 뭐였건 ANSI 로 무조건 되는거) . 만약에 기존 파일의 인코딩 방식을 유지하고 싶으면 코드의 첨부터 끝까지 문자 스트림을 사용하여 파일을 열어야한다		
		: 그러니까 바이트 스트림으로 출력 스트림 열었던 이력이 있으면 ( 아무리 해당 출력 스트림을 close( ) 했더라도 ) 후에 문자 스트림을 이용해서 유니코드를 append 하거나 아예 새로 write 하더라도 여전히 ANSI 인코딩 방식이기에 파일이 존나 깨진다
		: 근데 바이트 스트림을 문자 스트림화 시키는 보조 스트림을 생성하는 과정에서 바이트 스트림으로 파일을 처음에 열었더라도 보조스트림을 통하여선 UTF-8 로 제대로 입력되는데 이런 예외도 있는 것 같아

	: 왜 ANSI 로 인코딩된 파일을 바이트 스트림, 문자 스트림으로 읽어왔을때 읽은 값의 개수 차이는 2배인데 UTF-8 로 인코딩된 파일을 바이트 스트림 , 문자 스트림으로 읽어올땐 읽은 값의 개수 차가 2배가 아닌것일까
		: UTF-8 인코딩 방식은 가변길이문자 인코딩 방식이라 값의 타입에 따라서 부여하는 크기가 다르다. (들쭉날쭉하다) 
			: ASCII 해당 문자는 1바이트 가지고. 대부분 문자는 3바이트 크기를 가진다.




	
다형성을 활용하여 코드를 짠다.
	: 최상위클래스타입으로 참조변수 만들고 하위 클래스의 객체를 참조한다
		ex ) 
			OuputStream os = new FileOutputStream( "파일 경로" ) ;

	
			

	: 종류
		1. 입력스트림
			: 프로그램이 외부로부터 데이터를 받는 경우

		2. 출력스트림
			: 프로그램이 외부로 데이터를 전달하는 경우
