프로그램은 데이터를 다양한 곳으로부터 출력, 입력 가능
	: 키보드, 모니터, 파일, 네트워크

IOException
	: 자바는 입출력 관련해서 ㅈㄴ 깐깐하다
	: 문제가 발생할 수 있는 경우 예외 문구를 띄워서 문제를 조기 차단하는데 , 파일 입출력의 경우 아예 사용하기만 하면 예외를 발생시킨다
		: 자바 api 사전에서 throws IOException 과 함꼐 선언된 생성자, 메서드 >> IOException 을 떠넘긴다 == IOException을 해당 멤버가 호출된 지점에서 발생시킨다
		: print 메서드와 scanner 클래스를 쓸때 예외가 발생하지 않은건 자체적으로 예외처리를 해놔서 그렇다
			: 주의할 것은 scanner 의 모든 생성자가 throws IOException 하는건 아니란 거다 (InputStream 을 매개변수로 하는 생성자는 throws IOException 안하지만 파일객체를 매개변수로 하는 생성자는 throws IOException 되있다)

스트림 Stream
	: 단방향의 연속적인 흐름
	: tip ) 
		: 최상위 클래스의 경우 바이너리가 일반적으로 많이 접했던 스트림이고, 문자 기반 스트림은 뭔가 진짜 책(?)적인 느낌이다(독자 Reader, 작가 Writer). 근데 주의해야될것은 바이트 스트림 ,문자 스트림 모두 의 하위 클래스에 write( 어쩌구 ) 를 사용해 출력하고 , read ( 어쩌구 ) 를 사용해 입력받는다 

		: 해당 클래스의 접미사는 최상위 클래스를 나타낸다	
			: ex)   XXXInputStream >> InputStream이 최상위클래스
			: 해당 클래스의 최상위 클래스를 알게되면 어떤 종류의 stream 인지 파악 가능하다 (출력용인지 입력용인지 파악 가능해진다)

		: 해당 클래스의 접두사는 어떤 걸 대상으로 작동하는지 나타낸다
			: ex) FileXXXX >> 파일을 대상으로 입력 or 출력한다


		: 입출력 스트림에서 byte, char 씩 입출력 한다고 할때 숫자 범위로써 byte char 이러는게 아니라 크기로써 byte char 이러는 거라 byte 의 범위는 0~255 간주, 바이트 스트림의 경우 0~255 크기의 값을 입출력하는것.


		: 바이트. 텍스트 기반 스트림의 최상위 클래스는 모두 추상 클래스로, 그 자체로 쓰이지 않고 일정한 규격의 하위 클래스를 생성하기 위한 용도로 존재하는거다

		: javaj.io 패키지를 사용하면 코드가 맞았던 틀리건간에 에러가 나는데 해결 방법
			1. try ... catch 구문 사용
				: java.io.IOException 을 catch 내부에서 사용하기 때문에 별도로 import 필요
				: 장점은 try 문 괄호 부분에 스트림 객체 쓰면 try 구문의 종료시 자동으로 close( ) 해줌
				: 형식	
					try( 스트림 객체 생성 ){
					... 수행할 내용
					}catch( IOException e ){
						e.printStackTrace( );
					}

			2. main 메서드 선언 부에 throws Exception 추가
				: 에러 처리 위해 별도로 import 할	건 없는게 장점 		
				: 자동으로 close( ) 안해줘서 별도로 해줘야됨
				: 형식)
					public static void main(String[ ] args) throws Exception{
						수행할 내용
					} 
	
		: java.io 패키지의  하위클래스를 사용하는 경우 아래 3가지를 기본적으로 import 해준다
			1.  java.io.해당클래스의최상위클래스 ;
				: 보통 다형성 구현을 위하여 하위 클래스의 객체를 참조하는 변수를 부모타입으로 선언하기 때문에 직접적으로 각 스트림읭 최상위 클래스의 객체를 생성하지 않더라도(생성 안하는게 아니라 못하는 거긴 하지만 - 추상 클래스니까) 같이 import 해주는 편이다.
					ex ) InputStream fis = new FileInputStream("C:/SelfStudyJava/chap14/binarytest.db");

			2.  java.io.해당클래스;
			3.  java.io.IOException;
				: java.io 패키지의 클래스 사용하면 필수적으로 에러나는 걸 해결할때  try ...catch 구문을 사용하는 경우 import 필요 (만약에 걍 throws Exception 할꺼면 굳이 import 안해줘도 됨)
				


		: flush 는 왜 사용하는가?
			: 데이터를 입력, 출력하는 메서드를 쓰면 이터가 바로 입출력되는게 아니고 	버퍼라는 임시 저장 공간에 저장되어있다가 그 공간이 다 차면 버퍼를 비워 비로소 데이터를 실제로 입출력한다.  버퍼를 다 채우지 못한 상황에서도 버퍼를 비우기 위해 flush 를 사용ㅇ하는거다

			: 사실 close 썼음 flush 를 쓸 필요없다
				: close 기능 =  flush 기능 +  스트림 폐쇄


		: 리소스를 닫아야하는 이유
			: 예를 들어 파일이 열려있음 다른곳에서 사용을 못하고 닫혀 있어야만 열 수 있다

		: IoException
			:FIleNotFoundException 의 최상위 클래스다.
				: 그래서 catch 괄호내부에 FIleNotFoundException e 를 써도 되긴하지만 범용성을 위해 IOException e 쓰는거다 

		: 바이트 파일의 경우 문자열의 형태가 아니기 때문에 메모장으로 확인을 못한다. 
			: 내용 확인/유추 방법
				sol 1. 파일의 속성 탭을 누르면 몇 바이튼지 크기 나오는걸로 통해 유추가 가능하다
				sol 2. 바이트 인풋 스트림을 이용해 get 

		: 바이트 스트림의 경우 바이트란 이름에 걸맞게 1바이트씩 거래한다
		: 스트림은 그림에서도 추론 할 수 있듯이 FIFO로 작동한다
			: 먼저 입력된 내용부터 쓰여지기 시작한다
		: close( )를 제외한 입력 스트림의 메서드는 모두( 바이트 스트림이건 문자 스트림이건) 
			: 메서드 종류 
				: ( close( ) 제외하고 )  죄다 read( 어쩌구 ) 꼴
					: flush( ) 가 없다 

			: 반환
				: 반환 타입 ) int 형이다
				: 반환값
					1. eof 에 도달하면 -1 을 반환한다
					2. eof 가 아니면 
						(1) arg 가 없는 read ( ) 를 제외하곤 읽는데 성공한 값의 개수를 반환한다 << 주로 conunt 변수로 이를 저장해둔다
						(2) arg 가 없는 read( ) 의 경우 읽은 값을 반환한다 (int 형으로)
	
		: 출력 스트림의 메서드는
			: 메서드의 종류
				1. write ( 어쩌구 ) 꼴
					: write( ) 로 값 딱 하나만 읽어오는 경우 param 타입이 int 긴 한데 int 란 사실은 잊어버리고 그냥 바이트 스트림이면 바이트값, 문자 스트림이면 문자값을 arg 로해라. 
						: param 으로 int 값 받아도 에러는 안나는데 실제로 출력되는건 끝의 1바이트, 2바이트씩만 실제로 출력된다고 한다  (param 값이 곧 출력값은 아니다)
				2. close ( )
				3. flush( )

 
			: 반환 타입이 죄다 void 이다
			

		: 출력 스트림의 생성자는
			:  append 여부를 결정하는 param 도 있다
				: 암것도 안쓰면( 디폴트 ) false 고 , append 안하겠단 뜻 된다
					: true 를 쓰면 append 하겠단 뜻 된다
					


			

		: 파일 끝까지 읽는 tip	
			: count 를 사용하여 평소엔 읽어온 값ㅇ의 개수 저장하다 eof 에서 -1 입력 받음 종료함
			int count = 0 ;
			while(  (count = 스트림객체.read( 어쩌구) ) != -1 ) {

			
			}

		: 입력받은 내용을 저장한 배열을 출력하는 tip
			: tip 이란게 있어야되는게 (걍 암 생각 없이 배열 활용하면 안되는게) 항상 배열의 크기만큼 데이터가 가져와지는게 아니라 마지막 차례에서 배열을 꽉 채우지 못하고 입력을 받을 수 있기 때문
			: 공통
				파일 읽는데 쓰이는 whille 문 내부서 ary 객체를 생성한다( 한 턴 돌때마다 새로운 객체 생성 )
					: 그래야 지속적으로 모든 인덱스가 0 으로 초기화 되서 입력 안된 부분을 null 값을 통해 구별 가능하다
					: 만약에 처음에 생성했던 객체를 계속 쓴다면 이전에 받았던 내용을 덮어쓰기 하는 방식으로 진행되는데 마지막 턴에서 새롭게 입력받지 않은 인덱스에도 이전턴에 입력받은 값이 남아있어 혼란을 야기할 수 있다(+ null 값으로 구별이 불가하다)

			1. count 변수를 적극활용 : 자동적으로 실제로 입력받은 부분까지만 출력한다 << 강추
				for(int i  = 0 ; i  < count ; i++){
					ary[i] 값 활용
				}
					
	
			2. null 값을 통해 실제로 입력 받은 부분을 파악 :
				(1) 걍 for 문

					for(int i  = 0 ; i  < count ; i++){
						if ( ary[ i ] != 0) ary[i] 값 활용
					}

				(2) 향상된 for문
					for( byte b : ary) {
						if ( b != 0) b 값 활용
					}

	: 패키지
		java.io
			: 여러가지 스트림 클래스를 제공
	
				(1) 기반 스트림
					1. 바이트 기반 스트림
						: 바이너리 데이터를 읽고 출력할 때 사용
							: 바이너리 데이터 ) 데이터 형태 그대로 저장
								: 이미지 등등
						: 세부 종류
							(1) (바이트)입력스트림
								: 최상위 클래스 ) InputStream
									: 추상클래스다
									: 메서드종류
										int read( )
											: 1 바이트를 읽고, 읽은 값의 int 타입버전값 혹은 -1을 리턴
												: -1 == EOF 나타내는 값
													: 이거 이용해서 파일 끝까지 읽을 수 있다
												: 읽기는 바이트로 읽고 실제로 가져오는기는  int 타입임을 주의													: 끝부분만 진또배기고 앞 3바이트는 죄다 00000000 00000000 00000000 이다


										int read(byte[ ] b)
											: 읽은 값은 "매개값으로 주어진 배열"에 저장하고, 읽은 바이트 수를 "반환"한다
												: 그냥 read( ) 와는 다르게 반환값이 읽은 값이 아님에 주의
												: 똑똑하게 실제로 읽은 바이트 수를 반환함을 주의 
													: 항상 배열 사이즈를 반환하는게 아니다(배열을 꽉 채워 받지 못하는 경우도 있을 수 있으니까)
	
										int read(byte[ ] b, int off ,int len)
											: 

										void close( )

								: 하위 클래스
									: InputStream 의 구현 클래스들
										FileInputStream
										BufferedInputStream
										DataInputStream

									
									


							(2) (바이트)출력스트림	
								: 최상위 클래스 ) OutputStream
									: 추상 클래스
										: 메서드
											:  return 값이 출력값이 아님을 주의( 반환형이 다 void 이다)
												: return 은 프로그램내에서 반환되는 값이지 외부로 반환되는 값이 아니니까 출력 메서드의 반환값이 void 형인건 어찌봄 당연한 일
											1. abstract void write( int b )
												: 존나 웃긴게 받기는 int 값 받았으면서 정작 출력은 1바이트만 출력한다
													: 그러니까 int 값을 이루는 4 바이트 중 젤 오른쪽의 1 바이트만 들어가는거다 (-128~127의 숫자만 가능)

											2. void write( byte[ ] b)
												: 매개값으로 주어진 배열 b 의 "전체"를 "한번에" 출력한다
													: 배열이 끝까지 채워져있던 말건간에(null 값이던 아니던) 배열 전체 사이즈를 출력하는거 주의  

											3.  void write( byte[ ] b , int off , int len)
												: 매개값으로 주어진 배열 b에서 b[off] 부터 len 개의 내용을 출력한다(배열의 일부를 출력한다)
													: 가장 마지막 매개변수 값이 종료 인덱스가 아니라 출력 갯수임을 주의

											4. void flush( )
												: 출력 버퍼가 다 차지 않아도 잔류하는 모든 바이트를 출력한다
													: 프로그램 중간중간에 데이터 저장하고 싶음 사용한다

											5. close ( )
												: 출력 스트림을 닫는다 + flush 기능 수행한다
												: 안전하게 close 하는 법
													1. AutoCloseable 활용
														: try 구문에 괄호 치고 그 내부에서 스트림 객체 참조변수를 넣으면 try 구문의 종료시 자동으로 close ( ) 실행된다. (자동리소스닫기)
															: 여러 객체를 한번에 넣을 수 있다. 이때 각 객체는 ; 로 구분해놓는다
														: 주의 ) 모든 스트림 객체에 사용 가능한건 아니고 AutoCloseable 이란 인터페이스를 구현한 스트림 클래스에 대하여 가능 ( 근데 대부분 AutoClosealbe 을 구현하긴 한다)
															
														: try( 스트림 객체참조변수 ){
														}
														catch( ){  }
														
													2. 예외구문에 finally 추가
														: finally 는 예외가 발생했건 안했건 꼭 실행되는거 이용하는것 이용
														: 근데 이거 쓰면 이상한 에러 나는데 나중에 확인

														try{

														리소스 오픈& 활용 코드

														} catch{
														예외발생시 발생시킬 오류 문구
														} finally{
															리소스객체.close
														}
	
												: 불안전한 close
													: try 블럭 내부에서 리소스 객체를 close 하는 것
														: try블럭의 경우 블럭 실행하다가 예외 발생함 뒤에 코드는 실행을 안하기 때문에 close 가 실행이 안될  수 있다.

								: 하위 클래스
									: 최상위 클래스의 실체 클래스들
									: 종류
										FileOutputStream
											: 파일로 출력하는 스트림
											: 생성자
												FileOutputStream( String name, boolean append)
													: 첫 param 으로 파일명을 받음
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


												FileOutputStream(Filen f, boolean append)
													: 첫 param 으로 파일 경로를 받음 
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


										PrintStream
										BufferedOutputStream
										DataOutputStream


					2. 문자 기반 스트림
						: 텍스트 데이터를 주고 받을 때 사용
							: 텍스트 데이터 ) 문자로 읽기 가능한 형태로 저장

						: 세부 종류
							: (write( )로) 문자열 타입을 출력할 수 있지만 (read( )로 )문자열 타입으로 입력은 못받는거 주의
							(1) (텍스트)입력스트림
								: 최상위클래스 ) Reader
									: 추상클래스
									: 메서드)
										: 문자 배열 단위로 불러올 순 있어도 문자열 단위론 못불러옴 << 문장 단위로 받아오고 싶다묜 보조스트림 사용
										int read( ) 
											: 1개의 문자를 읽고 이를 int 타입으로 리턴
												: 문자 == 2바이트 이므로 한글까지 입력받을 수 있다
												: 반환값이 읽은값임에도 불구하고 char 타입이 아니라 int 타입인거 주의. 읽은 값을 문자로 사용하고 싶음 강제형변환 해줘야됨
													: 왜 굳이 int 형으로 만들었을까
														: char 타입의 경우 음수를 표현못해서 일단 int 타입으로 확장 시켜 반환한듯?
												
										int read(char[ ] cbuf)
											: 매개변수로 주어진 문자배열의 사이즈 갯수만큼 문자를 입력받아 저장하고, 입력성공한 개수 혹은 -1  (eof) 을 반환함
										int read(char [ ] cbuf , int off , int len)
										void close( ) 
	
								: 하위 클래스)
									: Reader 클래스를 상속 받아서 만들어짐
									: 종류
										FileReader
										BufferedReader
										InputStreamReader


							(2) (텍스트)출력스트림
								: 최상위클래스 ) Writer
									: 추상 클래스
									: 주요 메서드
										: param으로 String 타입도 가능
										void write( int c )
											: 신기하게도 또( 바이트 스트림에서도 한개 단위로 출력할때 출력하는 값의 타입이 int 도 아니면서 매개변수 타입 int 였음) 출력하는 값은 char 형 이면서 매개변수 타입은 int 형임
												: 어쨌뜬 걍 char 형 값을 arg 로 함 된다
												: char 범위 넘어서는 int 값은 안됨을주의? 맞니?

										void write( char[ ] cbuf )
											: 매개값으로 주어진 문자 배열의 값을 한번에 출력함
											:
										void write(String str)
											: 매개값으로 주어진 문자열을 한번에 보냄

										void write( char[ ] cbuf, int off , int len )
											: 매개값으로 주어진 문자배열에서 시작 인덱스와 보낼 값의 개수를 지정하여 출력함
										
										void write( String str , int off , int len)
											: 매개값으로 주어진 문자열에서 시작 문자와 보낼 문자의 개수를 지정하여 출력함

										void flush( )
											: 버퍼에 잔류하는 모든 문자를 출력

										void close( )
											: 출력 스트림을 닫음  

								: 하위클래스
									: Writer 클래스의 구현 클래스들
									: 종류
										FileWriter

											: 생성자
												FileWriter( String name, boolean append)
													: 첫 param 으로 파일명을 받음
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨


												FileWriter(Filen f, boolean append)
													: 첫 param 으로 파일 경로를 받음 
													: 두번째 param 값은 append 할지 , 아님 첨부터 write 할지를 결정
														: 써도 되고 안써도 되는데 안쓰면 디폴트가 false 이고, 이는 append 를 안하고 write 하겠단 의미 (덮어쓰겠다)
														: 만약에 true를 명시하면 append 하겠단 소리가 됨

										BufferedWriter
										PrintWriter
										OutputStreamWriter

				(2)보조스트림
					: 기본 스트림을 보조하는 스트림
						: 기본 스트림 없이 혼자선 못씀 
						: 기본 스트림만 존재한다면 한번에 여러개의 보조 스트림을 사용 가능

					: 삽입 위치
						: 기본 입력 스트림 >>보조입력스트림1>>보조입력스트림2 ... >> 프로그램>>보조출력스트림1 >> 보조 출력스트림2 ...>>기본 출력 스트림
							: 기본 스트림과 프로그램 사이에 샌드위치 됨

			
					: import 해야하는 것들
						1. java.io.IOException 
							: 물론 thorws Exception 하면 따로 불러올 필요는 없음
						2.  java.io.보조스트림클래스
						3.  java.io.기본스트림클래스
							: 레퍼런스변수 타입으로 쓰이거ㅓ나, 생성자 쓰이는 기본 스트림 클래스 모두


					: 보조 기능
						1. 데이터 타입 변환해서 입출력
							: 바이트 기반ㄴ 스트림의 경우 문자 기반 스트림으로 만들어야하는 상황이 꽤 있는데( 바이트 단위로는 유니코드 못 읽으니까) 이때 필요함
							: 문자 변환 보조 스트림) 
								: 보조스트림명 == 원래스트림의최상위클래스명+바꾸자하는스트림의최상위클래스명
									: 최상위클래스의 하위 클래스중 어떤 하위 클래슨지는 param 으로 대입되는 객체로 자동으로 추론해서 하위 클래스명은 생략하게 한 것 같다
									ex) OutputStream fos = new  FileOutputStream(경로); Writer osw = new OutputStreamWriter( fos ); // osw == Writer 클래스의 하위 클래스중 FileWriter 클래스의 객체로 인식됨

								:보조스트림 객체 생성 형식
									 new 보조스트림타입( 기반스트림 객체) ;
										: 기반 스트림 객체로는 직접  괄호 내부서 객체 생성해도 되고 밖에서 미리 객체 만들고 이를 가리키는 레퍼런스 변수를 대입해도 됨

								: 보조스트림 객체 참조 변수
									(1) 변환한 스트림 타입의 참조 변수 (보통 변환한 스트림 타입의 최상위 클래스)
										ex) Writer osw = new OutputStreamWriter( 파일경로 );

									(2) 보조스크림 타입의 참조변수
										ex) OutputStreamWriter ows = new  OutputStreamWriter( 파일경로 );

								: 종류	
									1. OutputStreamWriter
										: 생성자) OutputStreamWriter( OutputStream os) 
					
									2. InputStreamReader
										: 생성자) InputStreamWriter(InputStream is) 
											
								
						2. 입출력 성능을 향상 (버퍼 관련)
							: 기본적으로 존재하는 작은 버퍼와 별개로 추가적인 버퍼를 제공받기 위해 보조 스트림을 사용			
								: 버퍼 ) 데이터 쌓이기를 기다렸다가 꽉 차게 되면 그제서야 데이터를 장치로 보냄으로써 출력 횟수를 줄여 결국 프로그램 실행 속도를 향상시키는 역할을 함 
									: 프로그램과 버퍼 간에는 고속 전송이 된다
									

								: 기본적으로 입출력스트림은 내부에 "작은" 버퍼를 가지긴 함.
									: 그래서 입출력 성능 향상 보조 스트림을 사용하지 않아도 출력스트림 다 썼음 flush ( ) 해줘야 되는것 (물론 close( ) 에 내장돼있어서 직접 flush (  ) 라고 쓰진 않지만)
									: 주의해야할 것은 입력 스트림에도 버퍼가 존재한다( flush( ) 가 있진 않지만)			
								: 버퍼를 비운다 ==  " 버퍼 ----> 목적지 " 로 실제로 데이터 전송한다
									: 버퍼 비우는 기준
										: 출력 스트림의 버퍼 == 버퍼가 꽉 차면
										: 입력 스트림의 버퍼 == 얘는 기준이 뭔지 모르겠음
					
			
							: 성능향상 보조스트림)
								: 보조스트림명 == Buffered기반스트림의최상위스트림
									: 마찬가지로 어떤 하위 스트림을 쓸껀지 직접적으로 명시하진 않고, 객체 생성 당시 param 으로 들어오는 객체의 타임을 자동 인식한다

								: 보조스트림객체 참조변수 선언
									(1) 최상위 클래스 타입으로 선언
										 보조스트림도 InputStream , OutputStream, Reader , Writer 의 최상위 클래스의 하위 클래스 들이라 가능 
									(2) 딱 보조스트림객체의 타입에 맞춰 선언
 
								: 종류)
									1. 바이트 기반 스트림
										(1) BufferedInputStream
											: 생성자
												BufferedInputStream(InputStream is)
										(2) BufferedOutputStream
											: 버퍼가 다 차야지 데이터를 실제로 목적지로 출력한다
											; 생성자
												BufferedOutputStream(OutputStream os)

									2. 문자 기반 스트림
										(1) BufferedReader
											: 생성자
												BufferedReader(Reader rd)
													: 주의해야될것은 BufferedReader 는 (InputStream 을 Reader 로 바꾸고자 쓰는게 아니라) BufferedReader 만의 메서드인 readLine( ) 을 쓰기 위해 사용하는 보조 스트림이기 때문에 BufferedReader 로 생성한 객체는 BufferedReader 타입의 변수로 받아야된다(아니면 굳이 쓴 이유가 없다)
											: String readLine( ) 메서드 제공 
												: 라인 단위(엔터단위)로 문자열을 읽음 << 문장 읽어야되는 상황이면 개유용(기본 스트림의 read( )차원에선 문자 배열 혹은 문자 단위로 밖에 못가져옴)
													: 엔터를 포함하여 버퍼에서 가져오되 엔터는 버림 (엔터 이전 까지의 내용만 실제로 저장함)
														: 엔터 버리고 저장하는거 진짜 주의
													: 라인 단위 == 줄바꿈 == 엔터 == '\r'+'\n'
												: 더이상 읽어올 문자열이 없으면 null 을 리턴
						
							3. 기본타입입출력보조시스템
								: 기본 타입( boolean, char, short , int ..) + 자주쓰는 클래스인 String 타입을 입출력할 수 있음
									: Interger, Character 말하는게 아니라 찐으로 기본타입들을 말하는 거다
								: 주의해야할 것은 기반 스트림으로  바이트 스트림만 사용 가능
								: 종류
									(1) DataInputStream
										: 생성자
											DataInputStream(InputStream is)
												: 마찬가지로 일반적인 InputStream 에는 없는 메서드를 사용하기 위함이므로 생성한 객체는 InputStream 으로 받음 안되고 딱 DataInputStream 으로 받아야된다
										: 메서드 >> read기본타입( ) 꼴 (String 은 예외적으로 UTF)
											1. boolean readBoolean()
											2. byte readByte()
											3. short readShort()
											4. char readChar()
											5. int readInt()
											6. long readLong()
											7. float readFloat()
											8. double readDouble()
											9. String readUTF()
												: 내가 봤을땐 UTF-8 말하는 듯?




									(2) DataOutputStream
										: 메서드 >> write헤딩타입( 매개변수  ) 꼴
											: 매개변수 타입 tip >> 싱수 대입할때의 상수 타입과 비슷(int 이하 정수 >> int , long 정수는 long ,boolean 은 boolean , float 는 float , double 은 double)
											1. void readBoolean(boolean v)
											2. void readByte(int v)
											3. void readShort(int v)
											4. void readChar(int v)
											5. void readInt(int v)
											6. void readLong(long v)
											7. void readFloat(float v)
											8. void readDouble(double v)
											9. void readUTF(String v)

							4. 프린터 보조 스크린
								: 출력하는 메서드를 가지는 보조 스트림
								: System.out 도 출력보조스트림 이라서 println() , print( ) 같은거 쓸 수 있었던거임
									: System.out >> PrintStream 타입
								: 종류
									(1) PrintStream
										: 특이하게 짝꿍은 PrintWirter 이지만 PrintOutputStream 가 아니라 PrintStream 임을 주의
					 					: 생성자
											PrintStream(OuputStream os)

									(2) PrintWriter
										: 생성자
											PrintWriter(Writer w)
								: 메서드 
									: PrintStream 과 PrintWriter 가 똑같은 메서드 사용험
									: print, println 이 오버라이딩 되있는 구조임
									:종류
										void print(여러가지 자료형타입의 매개변수)
										void println(여러가지 자료형타입의 매개변수)
											: 끝에 '\n' 자동 추가해 출력
												: 그러니까 파일과 연결된 스트림에서 println 쓰면 자동으로 줄바꿈 되서 파일로 출력되는거다
													: println 과 readLine( ) 의 궁합이 좋다
											: print() 메서드와 다르게 괄호 안에 암것도 안넣은 버전도 오버라이딩 되있어서 괄호 안에 아무런 arg 없이도 사용 가능											

							5. 객체 입출력 보조 스트림
								: 메모리에 생성된 객체를 파일 or 네트워크로 출력함
								: 기반 스트림은 바이트 스트림만 가능
									(1)ObjectInputStream
										: 객체를 역직렬화함
											: 역직렬화 ) 직렬화 된걸 복원하는 것
												: 바이트 배열을 객체로 복원하는 것
										: 생성자
											ObjectInputStream(InputStream is)
										: 메서드
											object readObject()
												: 리턴 타입이 object 타입이기 때문에 강제형변환해서 사용해야됨
												: 왜그런지 몰라도 예외 발생시키기 때문에 throws Exception 처리하고 써야된다
									(2)ObjectOutputStream
										: 객체를 직렬화 함
											: 직렬화 ) 객체를 바이트 배열로 만드는 것	
												: 모든 객체가 직렬화 가능한 건 아니고 Serialable 인터페이스의 구현 객체일때만 가능하다
										: 생성자
											void writeObject(Serialable sa)
												: 객체를 직렬화 해서 출력함
																								


: 입출력 관련 API
	: API == application programming interface
		: 응용프로그램에서 사용할 수 있게 만든 (어떤 기능을 가진) 인터페이스

	: 입출력관련 API 는 기반 스트림과 보조 스트림을 사용하여 다양한 기능들을 제공한다

	: 콘솔 console
		: 시스템을 사용하기 위해 키보드로 입력받고 모니터로 출력하는 솦웨어
		: 종류
			: 유닉스 , 리눅스 운영체제 >> 터미널
			:  윈도우 운영체제 >> 명령 프롬프트

	: 이클립스의 콘솔 
		: 키보드로 입력받고 내영ㅇ,ㄹ 출력
		: how 입력받을까
			System.in 
				: System == 클래스
				: in
					: 콘솔에서 키보드로 입력된 데이터를 읽기 위해 사용하는 필드
					: System 클래스의 정적 필드로, InputStream 타입이다.
						: public static final InputStream in ;
						: InputStream 타입의 변수 처럼 활용 가능하다
							: 그래서 사실 read( )  같은 것도 쓸 수 있다
							: ex)
								InputStream si = System.in;
								int keyCode = si.read( ); // 한 바이트 읽어온다

								Reader reader = new InputStreamReader(si); // InputStream 타입의 스트림을 기반스트림으로 하여 보조스트림을 활용하여 Reader 타입으로 변환

								BufferedReader br = new BufferedReader( reader );
								String str = br.readLine( ); // BufferedReader 타입의 스트림을 활용하여 문장을 읽어온다


			System.out 
				: System == 클래스
				: out
					: 콘솔에서 모니터로 데이터를 출력하기 위해쓰는 필드
					: System 클래스의 정적 필드로 , PrintStream 타입이다
						: public static final PrintStream out
						: PrintStream 타입의 변수처럼 사용이 가능하다
							: 그래서 print( ) , println( ) , printf( ) 같은 걸 쓸 수 있는거다

			

			System.err >> 노코멘트

			Scanner 클래스
				: 입출력 스트림도 아니고 보조 스트림도 아님
					: 그래도 스캐너 썼음 close( ) ;해야된다
				: 문자 파일이나 바이트 기반 입력스트림에서 모두 사용 가능한 클래스
					: 객체를 만들어 사용한다
					: 근데 특이한건 생성자 매개변수로 InputStream 는 있는데 Reader 타입 매개변수인건 없음
				: java.util.Scanner
					: 유명한 생성자 (생성자 여러가지 오버라이딩 되있긴한데 뭐 지금까지 써본적이 없음)
						1. Scanner( InputStream is )
							: 그래서 Scanner 객체 만들때 System.in 을 arg 로 넣어서 만들었던거

						2. Scanner(File source)
							: 파일 객체를 매변으로 함
						3.  Scanner(String source)
							: 경로 ? 뭐 그런것같다
				: 제공 메서드
					( 1 ) 닫기
						1. void close( ) 
							: 스캐너 객체도 닫는다
					(2) 문자열 읽기
						1. String next( )
							: 단어단위로 읽음(화이트스페이스를 단위로 구분하여 문자열을 읽음)
								: 단순 띄어쓰기나 탭으로도 구분 가능
						2.  String nextLine( )
							: 문장단위로 읽음(띄어쓰기가 아닌 엔터를 기준으로 구분하여 문자열을 읽음.)
								: 엔터까지 버퍼에서 꺼내오는거 맞는데 가져오는 과정에서 엔터 버림(엔터까지 읽어오진 않음)

					(3) 기본타입 읽기 << next기본타입( ) 꼴
						: 주의!!! char 타입은 이렇게까지 쉽게는 못읽어옴
						1. byte nextByte( )
						2. short nextShort( )
						3. int nextInt( )
						4. long nextLong( )
						5. float nextFloat( )
						6. double nextDouble( )
						7. boolean nextBoolean( )

					(4) 더 읽어올것이 있는지조사 
						1. boolean hasNext( )
							: 더 읽어올 토큰이 있으면 true, 아님 false 를 반환
								: 토큰은 int 든 boolean 이든 상관없는거다 (next기본타입으로 불러오기 전까진 어차피 다 문자열이다)
						2. boolean hasNext( String pattern )
							: 다음 토큰이 매변으로 넣은 문자열과 일치하면 true 를 반환함 (아니면 당연히 false)
						3. boolean hasNext기본타입( )
							: 특정 타입의 토큰이 바로 뒤에 있는지 검사한다
								(1) boolean hasNextByte( )
								(2) boolean hasNextShort() 
								(3) boolean hasNextInt( )
								(4) boolean hasNextLong( )
								(5) boolean hasNextFloat( )
								(6) boolean hasNextDouble( )

					(5) 값의 구분기준 커스터마이징
						Scanner useDelimiter( String pattern)
							: delimilter 뜻이 구분자란 뜻임



				: char 타입으로 입력받는법
					: String charAt(int index)
						: scanner 클래스의 메서드가 아니라 String 클래스의 메서드임
							: 직접적으로 scanner 객체에 사용ㅇ할 수 있는 메서드는 없고 scanner 로 일단 문자열을 반환받은다음 String 객체를 대상으로 사용해야됨
						: index 는 0 ~ 문자열길이-1 까지 가능ㄴ
						: 사용 ex)
							Scanner scanner = new Scanner(System.in);
							char c =scanner.next( ).charAt(0); // 가장 앞문자를 불러옴

							
			File 클래스
				: 파일 , 디렉토리 정보를 제공하는 클래스
				: java.io.File		
					: 유명한 생성자
						File( String pathname )
							: 파일의 경로를 매변으로ㅏ여 파일 객체 만든다
								윈도우형식 ) c:/SelfStudyJava/test.txt 
								리눅스형식 ) c:\\SelfStudyJava\\test.txt 
									: \\ 처럼 2번 써야되는건 \자체는 이스케이프 문자이기 때문이다
 							: 실제로 해당 경로에 파일이 존재하지 않더라도 예외가 발생하지 않는다
								: FileNotFoundException 은 존재하지 않는 파일경로로 파일 스트림 객체를  생성할떄 발생하는거다
									: 참고로 파일 경로 뿐 아니라 파일 객체로도 파일 스트림 객체 만들 수 있게 되있다 (ex : FileInputStream(File file ) , FileReader(File file))
								: 해당 경로에 파일,폴더가 존재하지 않는다고 해서 새로 만들어주는 것도 아니다
									: 새로 만들려면 별도의 메서드를 사용한다
						File( URI uri )
							: 인터넷 경로같은걸로 파일 객체 만든다

					: 유명한 메서드
						: 뭔가 리눅스 느낌 난다
			
						(1) 파일 경로 유효 여부 검사
							 boolean exists( )
								: 파일객체 생성할때 생성자 부분에 들어갔던 경로가 유효한 경로인지(실제로 존재하는 경로인지) 검사한다

						(2) 파일 경로가 유효하지 않을때 쓰는 유용한 메서드
							: exists( )로 검사했을떄 false 나왔음 햊줄 수 있는 조치이다
							1. boolean createNewFile ( )
								: 새로운 파일을 생성한다 
							2. boolean mkdir( )
								: 새로운 폴더를 생성한다

						(3) 파일 경로가 유효할때 쓰는 유용한 메서드													: exists( ) 검사했을때 true ㅏ나왔을 떄 할 수 있는 조치
							
							1. 삭제
								(1) boolean delete( )
									: 파일 | 폴더 삭제

							2. 권한 검사
								(1) boolean canRead( )
									: 읽기 권한ㄴ 있는 파일인지 여부 화긴

								(2) boolean canWrite( )
									: 쓰기 권한있는 파일인지 여부 확임
	
								(3) boolean canExcute( )
									: 실행권한 있는 파링인지 여부 확인

							3. 파일인지 폴더인지 종류 검사
								(1) boolean isFile( )
								(2) boolean isDirectory( )

							4. 숨김 여부 검사
								(1) boolean isHidden( )		
				
							5. 경로 관련 정보
								(1) String getName( )
									: 파일의 이름을 리턴
								(2) String getPath( )
									: 전체 경로를 리턴
								
							6. 부모 관련 정보
								: 부모로 파일은 불가하므로 이건 폴더를 대상으로만 쓰는거임
									(1) String getParent( )
										: 부모 디렉터리 경로 리턴
									(2) File getParentFile( )
										: 부모 디렉터리를 FIle 객체로 생성한 후 리턴

							7. 자식 관련 정보
								: 파일이 자식을 가질 순 없으므로 이것도 폴더를 대상으로만 씀
									(1) String[ ]  list( )
										:  해당 폴더의 하위 폴더, 파일 목록을 "String 배열" 형태로 리턴
									(2) String[ ] list(FilenemeFileter filter)
										: 해당 폴더의 하위폴더, 파일 중에 filter 를 충족시키는 것만 String 배열 형태로 리턴

									(3) File[ ] listFiles( )
										: 해당 폴더의 하위 폴더, 파일 들을 "File 배열" 형태로 반환
										: 뒤에 s 붙어있는거 주의

									(4) File[ ] listFiles( FilenameFilter filter)
										: 해당 폴더의 하위 폴더,파일  증에 filter 를 충족시키는 것만 File 배열  형태로 리턴

										

							8. 세부정보
								(1) long  lastModified( )
									: 언제 마지막으로 수정됬는지 리턴
										: 날짜와 시간
								(2) long length( )
									: 파일의 크기를 리턴
										: 단위:


String getName( )
								: 파일 이름 리턴
							6. String get Parent( )
								: 부모 폴더 리턴
							7. File getParentFile( )
								: 부모폴더를 파일 객체로 생성하고 리턴
									: 주의할게 FIle 객체라고 해서 그 객체가 파일만 가리키느게 아니라 폴더까지 가리키는걸 잊지 말아야한다

---------------------------------------------------
Charset 문자셋 << https://www.youtube.com/watch?v=YQH18Jg-oGQ&list=PLR9w0n2BH7rcWz1XUOeAm0S7tdUC3dbD-&index=3 강의 개추
	: 메모리에 저장된 문자 타입의 값을 각각 어떤 숫자로 매치시킬 것인가 정리해놓은 셋.
		: 문자는 문자 그대로 메모리에 저장되는게 아니라 0 과 1 로 (이진수 숫자로) 변환되어 저장되니까
	: 코드포인트 )특정 문자에 매핑된 숫자

	: 종류 ) 
		1. ASCII ) 기본 영문알파벳, 숫자 , 특수기호 , 제어문자 제공
			: 1바이트 짜리
			: ANSI (American National Standard 어쩌구)
				: 아스키코드의 확장판으로 , 다른 나라의 언어도 지원
			
			
				:  1바이트 짜리이고, 7 비트에 정보 저장하고 MSB 에는 나라별 코드를 첨가한다
					: MSB
						: MSB == 0 >> 기본 아스키코드
						: MSB == 1 >> codepage 기능>> 16개국 코드 (EUC-KR , EUC-JP ..)
			
			
						: 나라별 코드
							EUC-KR : 한글전용문자셋
								: 한글 완성형 문자셋 ('과' 를 'ㄱ''ㅘ' 로 구분해서 정리한게 아니라 '과' 그자체로 정리되어있다. 조합형이 아니다). 
								: 누락된 표현이 꽤 많음(뷁같은 맞춤법이 틀린 단어는 단어는 저장이 안되있음)	
									: 뷁을 EUC-KR 로 읽어들이면 ? 로 , 1 바이트로 나온다 << 표 상에 없기 때문에 아예 한글인지 인식도 못한다
								: 가변 비트이다>> (기본) ASCII 대응 문자는 1바이트이지만 나머지 문자들(한글)은 2바이트 취금
									: '가' == B0A1 인데 이걸 분할하면 B0 , A1 으로 저장된다 (2바이트가 딱딱 순서대로 1바이트, 1바이트로 쪼개진다)
										: 그냥 print 로만 출력하면 -80, -95 로 나와서 해석하기 어렵지만 printf("%02X" , 변수) 를 이용하면 ㅅ쉽게 확인할 수 있다 (저장된 값 자체는 같지만- 음수는 보수로 저장되니까 - 음수로 보면 코드가 어케 저장됬는지 확인하기 어려우니)

								: 참고 - MS949
									: window 에서 사용되는 한글 완성형 문자셋
										: EUC-KR 과 다 똑같은데 EUC-KR에 포함되어있지 않은 표현들을 포함( 만들 수 있는 모든 표현 포함하는 듯)한다는 것만 다름
									: 가변비트다>> ASCII 대응 문자는 1바이트, 나머지는 2바이트
			
			
				: 문제점
					: 16개국의 charset에 불필요한 중복 부분이 존재한다 (기본 아스키코드 부분은 각국이 모두 가진다)
					: 나라별 아스키는 동시 사용이 불가하다 
						: 왜 >> 각국 문자에 부여된 코드가 모두 중복되기 때문. 
							:ex ) '가' 가 1000 번에 ,  'は' 가 1000번에 매핑되어있을때 1000 이 뭘 의미하는지 알 수 없어진다.
			
	
		2. Unicode
			: 전 세계적으로 하나로 통합된 문자셋. 각국의 언어를 한번에 모두 사용 가능
			: 유니코드 자체는 인코딩과 관련이 없고 어떤 코드 포인트를 가지는지 에 대한 정보만 있을 뿐이다. 코드 포인트를 어떻게 메모리에 표현하느내 따라 인코딩이 갈린다
				: 유니코드의 코드포인트) 'U+' 와 '16진수숫자' 조합

			: 인코딩방식 종류 (어떻게 코드 포인트를 메모리 상에 저장하는가)
				: 근데 어떤 숫자로 저장됬는지 볼떈 모두 16진수로 보는 편이다(printf 에서 %02X 쓰는 편)
				1. UTF-16
					: 고정 길이 문자 인코딩 방식
						: 영문 , 한글 모두 2바이트
							: 자바에서 char 이 2바이트 인건 "기본적"으론 UTF-16 방식을 택했기 때문(이클립스 에디터에선 다른 인코딩 방식으로도 변경 가능하다. 근데 인코딩 방식을 바꾼다 해서 char 의 바이트 크기가 변한다는건 아니다. 그냥 기본적으로 utf-8 택했으니 2바이트란것)
							: UTF-8과 같은 유니코드 charset을 쓰긴 쓰는거고, 인코딩 방식(그걸 어케 분할 및 고정 비트를 추가할지의 방식이 같지 않기 떄문에)이 다르기 때문에 UTF-8 과 UTF-16 은 다른거라고 하는거다
							: UTF-16 의 경우 한글 범위(( U+0800 ~ U+FFFF 의 범위에서)는 따로 고정 비트가 없다. 

								:ex) '가' 는 유니코드에서 코드포인트가 U+AC00 
									: UTF-16 으로는 AC , 00 으로 저장된다.
					: BOM (Byte Order Mark)
						: 하나의 문자를 앞에서부터 읽어야되는지, 뒤에서부터 읽어야되는지 알려주는(하나의 문자는 2바이트로 이루어져있는데 그 2바이트 중에서 어떠한 바이트를 먼저 읽어야되나) 코드로, 문자열을 저장할떄 문자"열"의 맨 앞에 붙는 2바이트 짜리 코드이다 (문자마다 BOM 코드가 붙는게 아니다)
		
		
				2. UTF-8
					: 가변길이 문자 인코딩 방식
						: 1바이트 ~ 4 바이트 (근데 4바이트 짜린 잘 없다)
							: 기본 아스키코드 값 >> 1 바이트
							: 한글 >> 3 바이트
								:참고로 실제로 3 바이트 전체가 한글 데이터를 나타내는건 아님. utf-8 의경우 코드포인트 범위별로 추가되는 고정 비트가 있는데 한글을 표현하는 코드바이트들이 속한 범위에선 1바이트 크기의 특정 고정 비트가 추가되는거라( U+0800 ~ U+FFFF 의 범위에서는 1110xxxx 10xxxxxx 10xxxxxx 로 1110 과 10과 10이 고정비트),  의미있는 데이터의 크기는 2 바이트라고 보면 됨
								:ex) '가' 는 유니코드에서 코드포인트가 U+AC00 
									: AC00 을 이진수로 나타내면 10101100 00000000
										: 고정 비트 추가하면 11101010 1011000000 10000000 로 즉 EA B0 80 이다


					: 대부분의 시스템의 기본 인코딩 방식
					: UTF-16 과는 다르게 BOM 이 따로 붙진 않음



	: java.nio.charset.Charset 클래스에 정의되어있음
		: nio == new input output

	: 객체 생성 ) 생성자를 사용하지 않고 정적 메서드를 이용 << 근데 Charset 객체 생성하고 이를 활용하는 케이스를 딱히 본적없음 .대부분 String charsetName 을 이용하는 듯
		sol 1. static Charset defaultCharset( )
			: 현재 설정되어있는 디폴트 문자셋 리턴
				: 최소 "파일" 단위까지 지정 "가능" . ( 근데 보통 프로젝트 단위로 설정 )
					: 자바 프로그램은 workspace 아래 여러개 프로그램이 있고 그 프로그램 안에는 여러개의 패키지가 있고 그 패키지 안에는 여러개의 파일이 있는데 그 파일 단위로 지정이 가능하단 말
		sol 2. static Charset forName(String charsetName) throws UnsupportedCharsetException
			: arg 로 쓴 문자셋으로 객체 생성


	: 자주쓰는 메서드
		static boolean isSupported(String charName )
			: 해당 문자셋을 사용할 수 있는 문자셋인지 조사



자바 코드에서 , 이클립스에서 켁스트 파일을 생성할 때 문자셋
	: 텍스트 파일이므로 문자를 저장하므로 사용하는 문자셋이 있다
	: 기본적으로 파일이 저장될 디렉터리 단위로 결정된다 << 디렉터리는 걍 이클립스와 존나 별개로 생성됬었던  거니까 이클립스 기본 방식을 아무리 UTF-8 로 설정했다고 해도 내 컴터 운영체제에서 MS949 인코딩 채택하고 있음 MS949 디렉터리 만들어지는거임
		: UTF-8 로 만들어진 폴더 
			: 걍 무조건 UTF-8 로 저장
				case1. ascii 범위 안에서의 문자만 사용한 파일은 UTF-8 로 저장
				case2. 한글 포함 파일은 UTF-8 로 저장

		: MS949 로 만들어진 폴더
			case1. ascii 범위 안에서의 문자만 사용한 파일은 ANSI( UTF-8 )로 저장
			case2. 한글 포함 파일은 MS949 로 저장
	


자바 입출력 스트림의 인코딩 방식	
	: 기본적으로 플랫폼의 기본 인코딩 방식을 따르기 때문에 파일의 인코딩 방식이 ANSI 일 경우, ANSI 로 인코딩 되고, 파일의 인코딩 방식이 UTF-8일 경우 UTF-8 로 인코딩됨
		: 파일 인코딩 방식 == 파일에 저장된 정보의 형태를 부호화 하는 방식




문자셋 지정이 (자동적이든 명시적이든) 필요한 경우 
	: 아래의 case 들에서 arg 로 문자셋을 주지 않은 케이스는 디폴트 문자셋이 자동으로 지정된거라고 봄 됨
	: 문자셋을 명시적으로 지정하는 경우 대부분 throws UnsupportedEncodingException 이 일어나므로 따로 처리 필요
	case1. 문자열을 byte[ ] 로 변환하는 경우 
		: String 클래스의 getBytes( ) 메서드의 arg 로 대입
			
	case2. byte[ ]를 문자열로 변환하는 경우
		:  byte [] 를 arg 로 하는 String 클래스의 생성자의 arg 로 대입

	
// 이하 확실하지 않은 내용			
	: append 를 위하여든 write를 위하여든 파일과 연결되는 출력 스트림이 바이트 스트림일 경우 파일의 인코딩 방식이 무조건 바뀐다 ( 바이트 스트림은 바이트 값 기준이니까 기존의 인코딩 방식이 뭐였건 ANSI 로 무조건 되는거) . 만약에 기존 파일의 인코딩 방식을 유지하고 싶으면 코드의 첨부터 끝까지 문자 스트림을 사용하여 파일을 열어야한다		
		: 그러니까 바이트 스트림으로 출력 스트림 열었던 이력이 있으면 ( 아무리 해당 출력 스트림을 close( ) 했더라도 ) 후에 문자 스트림을 이용해서 유니코드를 append 하거나 아예 새로 write 하더라도 여전히 ANSI 인코딩 방식이기에 파일이 존나 깨진다
		: 근데 바이트 스트림을 문자 스트림화 시키는 보조 스트림을 생성하는 과정에서 바이트 스트림으로 파일을 처음에 열었더라도 보조스트림을 통하여선 UTF-8 로 제대로 입력되는데 이런 예외도 있는 것 같아

	


	
다형성을 활용하여 코드를 짠다.
	: 최상위클래스타입으로 참조변수 만들고 하위 클래스의 객체를 참조한다
		ex ) 
			OuputStream os = new FileOutputStream( "파일 경로" ) ;

	
			


