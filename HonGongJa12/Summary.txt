스레드 >> 멀티 스레드 >> 프로세스 >> 멀티 프로세스

프로세스 process
	: 운영체제로부터 메모리를 할당받아 실행중인 프로그램 하나

멀티 프로세스
	: 운영체제로부터 메모리를 할당받아 실행중인 프로그램 여러개
		ex)  메모장 여러개 켜논거 , 유튜브랑 네이버 둘다 열어둔것
	: 각 프로세스는 서로 독립적
		: 한 프로세스에서 문제가 발생해도 다른 프로세스에 영향을 주지 않음
			ex) 유튜브 먹통되도 네이버 멀쩡
	: 멀티 태스킹이랑 다른거임

스레드 thread
	: 프로세스 내부에서 코드의 실행 흐름
		: 싱글 스레드 == 하나의 코드 실행 흐름
		: 멀티 스레드 == 여러개의 코드 실행 흐름
	: thread 영단어 == 한 가닥의 실 
		: 한 가지 작업을 위해 순차적으로 실행할 코드를 실처림 이어놓았다 해서 유래된 이름
		
	: 운영체제 os 는 멀티 태스킹을 할 수 있게 자원을 프로세스 마다 적절히 할당해주고, 병렬로 진행시킴
		: 멀티 태스킹) 
			:두가지 이상의 작업을 동시에 처리하는것
			: 멀티 프로세스와 동의어가 "아님"
				: 한 프로세스 내부에 멀티 스레드 생성되있는것도 멀티 태스킹임
					:ex) 유튜브 >> 영상 재생 + 소리 나옴 + 채팅 기능 
			: 스레드 끼리 영향 받음
				: 한 스레드에서 오류 나면 다른 스레드까지도 오류가 발생될 수 있음

		: 병렬로 진행 ) 동시에 여러개의 스레드가 태스크가 실행된다는 거지 
			:서로 독립적이란게 아님 주의
			: 직렬로 진행 ) 하나 끝나야 다음것 실행 ( one by one )

	: thread == 클래스 의 형태로 정의되어 있음
		: public class Thread 
			: 상속 , 구현 여부
				: implements Runnable 
					: interface Runnable 
						: runnable 이란 이름에서 알 수 있다 싶이 클래스가 run( ) 메서드를 가질 수 있게 해줌
						: Abstract methods : 하나 밖에 없음
							: void run ( ) 
								: 스레드가 실행할 내용으로 구현 함 됨 
				: extends Object
					: 모든 클래스의 최상위 클래스
			: 우선순위
				: 우선순위가 높을 수록 우선적으로 실행됨
				: 객체가 만들어진 적있는 스레드의 후속 객체들은 젤 처음 생성되었던 그 객체의 우선순위가 가진 우선순위와 동일함
				: 데몬 스레드 >> 우선순위 낮음
				: 데몬 스레드가 아닌 스레드 >> 우선순위 높음
			: 종료되는 경우
				(1) Runtime 클래스의 exit 메서드가 호출되고, 보안 관리자가 종료 작업을 허용했을때
				(2) 데몬 스레드가 아닌 일반적 스레드에서  run 메서드 호출이 끝났을때
				(3) run 메서드 넘어 전파되는 예외에 의해서


	
	: 스레드 종류
		(1)주 스레드. (main 스레드 할때 그 "주" 가아니다)
			: 평범한 스레드
			: foreground 에서 실행되는 높은 우선순위를 가진 스레드
			: JVM 은 사용자 스레드가 모두 종료되어야 종료됨
			: 종류
			1. 메인 스레드 main thread
				: 자바의 모든 프로그램(애플리케이션) 은 메인 스레드가 main()메서드를 실행하면서 시작
					: 하나의 프로그램엔 최소 main thread 는 존재한다
				: 싱글 스레드 프로그램의 경우 main thread 종료되면 프로그램이 종료되지만(프로그램에 있는 스레드가 main thread밖에 없으니까) 멀티 스레드 프로그램의 경우 모든 스레드가 종료되야 프로그램이 종료된다(main thread 가 종료되더라도 종료되지 않은 작업스레드가 있음 종료 안된다)

			2. 작업 스레드 
				: 메인 스레드 외에 추가적으로 존재하는 스레드들
				: Thread 객체로 생성되면 생성되고, 객체 내부의 start ( ) 메서드를 호출하여 객체 내부의 run( ) 구현 메서드가 실행되면 실행됨
					: 스레드 객체가 생성됬다고 해서 바로 실행되는게 아님

				: 작업 스레드 객체 생성 방법
					: 어쨌뜬 어떤 방법이 됬건간에 run( ) 을 오버라이딩 해야됨
					case1	) Runnable 구현 객체 생성 && java.lang.Thread 클래스의 생성자를 직접 이용해 생성
						: Thread클래스 뿐 아니라 Runnable 구현객체까지 생성해야되긴 하지만 인터페이스 특성상 다중 상속이 가능하다는 장점이 있기에 이 방법을 추천
						: 형식) 
							Thread 레퍼런스변수명 = new Thread ( new 구현클래스명(어쩌구저쩌구 ) );
								: Thread 클래스의 생성자 중에서 Thread(Runnable target) 을 사용하여 스레드 객체를 생성하는 것
								: 물론 괄호 밖에서 구현객체만들고 이를 가리키는 레퍼런스변수를 대신 대입해도 된다
						: 구현 클래스를 재탕할일이 없는 경우 익명구현객체를 만들어도 된다
						: Thread 객체의 레퍼런스 변수에다가 start( ) 적용하는거지 Runnable 구현 객체에 run( ) 적용시키는게 아님을 주의

					case2) Thread 의 자식 클래스의 객체 생성  
						: 당장은 편해보일지 몰라도 클래스의 특성상 다중 상속이 불가하다는 단점이 있기 때문에 비추 	
						: 형식) 
							자식클래스명 레퍼런스변수명 = new 자식클래스명(어쩌구저쩌구) ;
						: 자식클래스를 재탕할 일이 없는 경우 익명자식객체를 만들어도된다
		
					
		(2) 데몬스레드 daemon thread
			: 스레드 객체 생성 후 setDaemon(true); 를 호출하고 start( ) 호출된 스레드 객체
				: 주의 ) 주 스레드의 start(  )호출 이전에 setDaemon(true) 를 호출하는거다
					스레드를 실행하는 start( ) 가 호출되고 나서 setDaemon( true ) 를 호출하면 IllegalThreadStreadException 이 발생함 
			: background 에서 실행되는 낮은 우선순위를 가진 스레드
			: 현재 진행중인 스레드가 데몬 스레드인지 구별하는 법) isDaemon( ) 메서드의 리턴값 체크
			:데몬 스레드가 맞으면 true 리턴
			: 사용자 스레드가 모두 종료되면 자동 종료됨
				:JVM 은 데몬 스레드가 다 종료될때까지 안기달려줌(사용자 스레드만 제대로 종료됨 된다)
			: 대표적 예시
				: 가비지컬렉터
			:daemon == 운영체제의 시슽템 로그를 기록하는 작업을 돕는 역할을 수행하는 프로세스 인것처럼 데몬 스레드는 주 스레드의 작업을 ㄷ돕는 보조적인 역할을 수행하는 스레드이다

	: Thread 를 대상으로 쓰는 메서드들	
		: 인스턴스 멤버가 아니라 정적 메서드이지만 신기하게도 호출하는 위치의 스레드 객체를 대상으로 적용된다
			: native 메서드라서 다른 언어가 해당 메서드를 처리해서 정적 멤버임에도 객체 단위 처리를 시켜준다고 한다
			: ex ) main 스레드 내부서 Thread.sleep(100) ; 하면 메인 스레드를 100 초간 정지시키고
				Fuck 스레드의 내부서 Thread.sleep (100) 하면 Fuck 스레드를 100초간 정지시킨다  
		: 대표 메서드들
			publlic static void sleep(long millis) throw InterruptedException
				: Throws
					: IllegalArgumentException >> millies 값이 음수일 경우
					: IntteruptedException >> 뭔말인지 모르겠다


	: 스레드의 이름
		: 관련 메서드(인스턴스 메서드임을 주의)
			: 스레드의 이름을 알아내는 법 ) 스레드객체.getName();
			: 스레드의 이름을 변경하는 법 ) 스레드객체.setName( String str );

	: ( 생성 당시에 별다른 레퍼런스 변수로 받지 않아서) 참조가 없는 스레드의 참조 얻는 법
		: Thread.currnetThread( ) ;
			: 이 코드를 실행하는 스레드 객체의 참조를 얻게 해주는거지 , 이 코드가 위치한 클래스로부터 생성된 객체의 참조를 얻게 해주는게 아니다(걍 좀 생각하면 얼탱이 없음)
				: 만약에 Thread  객체의 이름을 Runnable 구현 클래스 내에서 바뀌게 하고 싶다면 (생성자 부분에다 .setName( ) 쓰는게 아니라 ) run( ) 부분에서 .setName( ) 을 써야된다
					: run( ) 을 돌리는 대상은 Runnable 구현 객체가 맞으니까 (생성자는 생성자가 쓰인 스레드 객체에 의해 돌려지는거고 - main 스레드에서 실행됬다면 main 객체겠지)
			: 정적 메서드 currentThread( ) 를 이용하여 Thread 클래스를 대상으로 구한다
			: 물론 이 결과를 사용하려면 별도의 레퍼런스 변수에 담아 사용해야한다
				Thread 레퍼런스변수명 = Thread.currentThread(  );
	
	: 스레드 상태
		: 종류
			1. 객체 생성 상태 : new 연산자를 통해 스레드 객체를 생성함 
			2. 실행 대기 상태 : 생성된 스레드 객체를 대상으로 start ( ) 메서드를 호출하여 대기 상태 리스트에 올림
			3. 실행 running 상태 : 운영체제에 의해 간택되어 cpu가 run( ) 메서드를 실행중인 상태
			4, 일시 정지 상태 : 스레드를 실행 중지한 상태 (완전 종료한게 아니라)
 			5. 종료 terminated 상태 : run ( ) 에서 더 실행할 코드가 없는 상태
		: 순서 ) 스레드 객체를 new 연산자를 통해 생성시켰다고 그 스레드가 실행되는게 아니라 그 객체를 대상으로 start( ) 메서드를 사용해서 실행 대기 상태에 올리고 ----> 운영체제에 의해 간택되면 cpu가 run( )메서드를 실행시켜 실제로 실행되고 ----> run( ) 메서드를 끝까지 실행하면 종료된다
			: 운영체제는 실행대기 상태의 스레드중 암거나 하나를 뽑아서 실행한다. 먼저 실행 대기 상태에 올라갔다고 먼저 실행된다는 보장이 없다
			: 실행대기상태 < ---- >  실행 상태 간에 왔다갔다 거릴 수 있다
			: 실행상태 ----> 일시정지 상태로도 살 수 있다
				: 하지만 실행상태<---- 일시정지 로 바로는 불가하고 실행대기상태로 돌리고 실행상태로 가야된다. ( 실행상태<-----실행대기상태<-----일시정지 )
		: 스레드 상태 제어
			: 스레드의 상태를 변경하는 것
			: 상태 제어 메서드
				1. public static void interrupt( ) 
					: " 일시정지상태" 일때 InterruptedException 을 발생시켜 예외처리코드(catch) 에서 실행대기상태 혹은 종료상태로 변화시킴
					: interrupt( ) 호출의 감지 방법
						(1) 일시정지 상태에서 interrupt( ) 호출의 감지가 가능한 특성을 이용 << run 내부서 sleep 쓸일 있음 이 방법 이용
							: 일시정지가 아닌 상태에서 해당 메서드를 사용했으면 당장 실행대기상태 혹은 종료상태로 만들진 않고 추후 일시정지 상태가 됬을때 그제서야 실행대기상태 혹은 종료상태로 넘어간다.
							: 사용방법 )	
									public void run( ) {
										try{
											while(true) {
												.
												.	
												.
											Thread.sleep(1); }

										    }catch(InterruptedException e) {  }
	
										자원정리코드
									}		
								
										: try{ } 구문 내부에 sleep () 할 필요가 없더라도 짧게나마Thread.sleep( 1 ); 을 사용하여 일시정지 상태를 발생시켜 interrupt() 호출의 감지가 가능하게 만들어놔야된다

						(2) interrupt( ) 메서드의 호출을 감지하는 별도의 메서드를 사용 << run 내부서 sleep 쓸 일 없음 이 방법 이용
							: 물론 단순히 run ( ) 내부에 interrupted( ) 나 isInterrupted( ) 이 있다고 멈출 수 있는게 아니라(run( ) 앞부분에 써놨다고 음 ~ 됬어 할게 아니라 )
							 interrupt( ) 발생 이후시점에 run( ) 내부서 interrupted( ) 나 isInterrupted( ) 를 만나야 뭔가 조치를 취할 수 있는거다
							: 메서드 종류
								sol1 . public static boolean interrupterd( ) 메서드 사용 >> Thread "클래스"를 대상으로 사용하고 , interrupt( ) 메서드가 호출됬으면 true 를 리턴 
									: 주의해야할게 interrupted( ) 와 interrupt( ) 는 다른 메서드이다

 								sol2 . public boolean isInterrupterd( ) 메서드 사용 >> Thread "객체"를 대상으루 사용하고 , interrupt( ) 메서드가 호출됬으면 true 를 리턴 
							: 사용 방법 ) 
									public void run( ) {
										
										while(true) {
												.
												.	
												.
											if( Thread.interrupted( ) ){ break; } 

											}
					
										자원정리코드					  
									}										

				2 . publlic static void sleep(int ms)
					: 실행상태 ----> 헤당 시간동안 일시정지 ---> (자동으로) 실행대기 상태로 만들어줌
					: 사용 방법)
						: try{
							Thread.sleep(밀리세컨드단위시간);
							}catch(InterruptedException e){
								interrupt()메서드가 호출되면 실행할 내용
							}	

								: sleep의 arg 로 쓴 시간이 다 지나기 전에 interrupt()가 호츌되면 InterruptedException 이 발생하기 때문에 try .. catch 구문 사용 필요

				3. stop( )
					: stop( ) 로 갑자기 종료하면 스레드가 사용중이던 자원(파일, 네트워크 연결...)들이 불안전한 상태로 나겨지기 때문에 이젠 못쓰게함
					: stop( ) 의 대체제 
						(1) stop 플래그를 제작해 사용 << 비추 ( Thread 객체로 직접 사용하긴 어렵다.  Thread 자식객체가 아니라 구현 객체로 Thread 객체 만드는 경우 레퍼런스 변수가 Thread 타입이라 부모에 없는 메서드는 그 객체 차원에서 못쓰니까)	
							: 사용방볍
								private boolean stop ;
									.
									.		
									.		

								public void run( ){
	
								while(!flag){ 
										실행할 내용
								}
	
								자원 정리하는 코드
								}
						(2)interrupt( ) 매서드를 사용 << 강추
							: 스레드가 일시정지 상태있을때 InterruptedException 을 발생시켜 run( ) 메서드를 정상종료할 수 있음


		: 메인 스레드가 모든 스레드가 종료된 이후에야 종료되게 하기 >> join( ) 사용
			: 그냥 냅두면 메인 스레드에선 스레드 객체 생성 시키고 start( ) 시키는 것 밖에 없어 다른 스레드들 보다 빨리 끝날 확률이 높은데 혼선을 줄이기 위해 메인 스레드가 가장 마지막에 끝나게 하는게 좋다
			: 사용 형식)
				try{
				스레드객체1.join( );
				스레드객체2.join( );
				.
				.
				.

				}catch(Exception e){ } 

					:  생성한 모든 스레드 객체를 대상으로 join( ) 을 쓰고 ,메인 스레드의 끝 부분에 쓴다
					: join( ) 이 적용된 스레드 객체가 종료되어야 다음 라인으로 넘어간다.



		: 기본적으로는 한 스레드가 다 완료되길 기다렸다가 다음 스레드가 실행되는게 아니라 그냥 main 스레드에서 명령문 만나는대로 객체 & run( ) 동작 시키고 다음 명령문 라인으로 튀는 것이기 때문에 각 스레드의 run( ) 에서 출력시킨 내용이 다른 스레드끼리 얽혀 출력되는 것처럼 보일 수도 있다
			: 심지어 run( ) 메서드가 먼저 실행된 스레드가 먼저 해당 run( ) 메서드를 모두 완료한다는 보장도 없다(나중에 실행된 run( ) 이 더 빨리 종료되는 경우도 있다)

			
	: 동기화 메서드 synchronized method
		: 그냥 냅두면 스레드 실행순서가 지멋대로이기 때문에 순서를 지켜 실행되게 하는것
		: 사용해야 하는 경우 ) 하나의 객체를 2개 이상의 스레드가 공유하는 경우
			: 하나의 객체를 (하나의 스레드만 점유하는게 아닌) 2개 이상의 스레드가 공유하는 경우 한 스레드가 사용중인 객체를 다른 스레드가 상태를 변경하여 해당 스레드에서 결과가 이상하게 나올 수 있기 때문

		:임계영역을 지정하는 메서드 >> "잠금"을 걸어 다른 스레드가 동기화 메서드"들"을 실행하지 못하게 함
			: 스레드들이 "공유"하는 객체를 만드는 클래스 내부에서 사용하는거다(스레드 객체를 생성하는 클래스 내부에서 사용하는 메서드가 아니다.)
			: 신기하게도 한 스레드 객체가 사용중인 동기화 메서드에만 잠금이 적용되는게 아니라 다른 "ㅗ든" 동기화 메서드에 잠금이 적용되는거다
				: 물론 동기화 메서드로 지정되지 않은 일반 메서드에는 다른 스레드 객체의 접근이 허용된다 
			: 스레드가 동기화 메서드를 실행 종료할때 그 메서드의 잠금이 풀린다 
		: 기본용어
			: 동기화 ) 작업들 사이에 수행 시기를 맞추는것
				: 사건을 동시에 일어나게 하는 것 뿐 아니라 일정 간격을 두고 사건을 일어나게 하는 것까지 일컫는 말
			: 임계영역 critical section
				: 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드영역

		: static 타입으로는 선언 불가
			: 공유 "객체" 단위로 synchronize 하는거라서 그렇다

	: 스레드 제어
		: 스레드의 상태를 변경해서 스레드를 제어
		; 스레드 객체를 생성하고 start( ) 메서드를 호출하면 바로 실행되는 것이 아니라 실행 대기 상태가 됨.				: 실행대기 상태 ) 언제든지 실행할 준비가 되어있는 상태
		: 운영체제는 실행 대기상태에 있는 스레드 중 하나를 선택해서 실행상태로 만듬
		: 스레드 상태
			: 

notifyAll( ) , wait( ) 
	: 동기화 메서드의 단점 >> 프로그램 효율이 떨어진다 ( 모든 동기화 메서드에 락이 걸리니까)
		: 동기화의 효율을 높이기 위해 만들어진 것이 wait( ) , notify( ) 
	: wait(  ) , notify ( )
		: object 클래스에 정의되어있고 , 동기화 메서드 내에서만 사용 가능
		wait( ) : 작업을 진행할 상황이 안되면 동기화 메서드의 락을 풀고 스레드를 해당 객체의 waiting pool 에 넣는다
		notify( ) : waiting pool 에서 대기중인 스레드 중 하나를 깨운다. 
			: 먼저 왔다고 먼저 빠지는게 아니다. 누굴 특정해서 깨울수없어 보통 notifyAll() 을 쓴다
		notifyAll( ) : waiting pool 의 모든 스레드를 깨운다

	: wait ( )  형식 
		while( 조건불만족인경우){ // 조건 만족하면 탈출
			try{
			wait( ); // 일단 wating pool 에 올리고 일단 다른 스레드 객체가 동기화 메서드에 접근할 수 있게 하고 그를 통해 조치 취한뒤 다시 notify( ) 로 깨워졌을땐 조건 만족이길 바라자.
			} catch(InterruptedException e){ } 
		}

		조건 만족하는경우 실행할 코드
	
	: notify ( )형식
		조건 만족으로 바꿀 가능성이 있는 코드작성
		notifyAll ( );   // waiting pool 에 있는 스레드 객체를 깨워서 다시한번 조건 검사하게 한다


	: 주의 >> 스레드 종료 안되면 프로그램도 종료 안되니까 할 작업을 다 수행한 시점에서는 waiting pool 에 있는 얘가 없어야된다.
		: 해결방법
			sol1 ) synchronized method 내에서 if 문을 활용해 수행 마지막 시점에 애초에 wait( )가 걸리지 않게 설계한다
			sol2 ) synchronized method 내에서 수행 완료 시점을 특정하기 어려우면 notifyAll( ) 만을 내용으로 하는 메서드를 만들고 구현 클래스의 run ( )에서 모든 수행 완료했음 그 메서드를 호출하여 간접적으로 notifyAll( ) 시킨다
				: 맨 마지막으로 종료되는 스레드 객체의 run( ) 뿐 아니라 그 전에 종료되는 스레드 객체의 run( )에도 notifyAll( ) 을 간접적으로 발생시키는게 좋다 
					: 스레드 객체가 종료된다 >> 더이상 wait( ) 을 개선시킬 힘이 없다 >> 남아있는 스레드 객체를 waiting pool 에서 꺼내줄 수 있는 얘가 없다 가 되니까  아예 꺼내주고 죽는것.


	: Semaphore 세마포어 << 나중에 더 보기
		: 공유 객체를 두고 스레드의 경쟁이 심한 경우 사용
		: 경쟁이 심해지면 공유객체는 Heavy Weight lock 상태가 됨
			: Heavy weight lock 상태 == monitor 방식으로 상호 배제를 구현
				: semaphore 방식 >> monitor 방식이 나올 수 있게 영감을 준 알고리즘
		: JVM은 semaphore 방식을 사용하지 않고 synchronized 를 통한 monitor 방식으로 상호 배제를 구현하긴 하지만 , java 표준 api 라이브러리 내부엔 semaphore 클래스도 존재
		: 

	
	//current thread is not owner 오류 >> synchronized 메서드도 아닌데 wait ( ) , notify() 같은거 썼을때
