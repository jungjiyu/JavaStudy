중첩 클래스와 중첩 인터페이스

중첩 클래스 nested class
	: 클래스 내부에 선언한 클래스
	: 한 클래스가 특정 클래스와만 관계를 맺는 경우 내부다 걍 선언하는 것이 합리적
	: 효과
		1. 두 클래스의 멤버들을 서로 쉽게 접근이 가능
		2. 외부에 불필요하게 보여지지 않음(코드의 복잡성 감소) 

	; 종류
		1. 멤버 클래스
			: 클래스의 멤버로써 선언되는 중첩 클래스
			: 세부종류
				: tip	
					바깥클래스명.내부클래스명 == 내부클래스 타입
						: 로컬 클래스만 아님 이렇다 (클래스와 클래스가 직접적 접촉이 있음 이렇다)
					
					바깥클래스객체명. new 내부클래스명( ) 
						: 바깥클래스의 객체가 존재해야 생성이 가능하다.
						: 일단 바깥 클래스의 객체로써 접근했고 사용할 인스턴스 멤버명을 쓰면 되는데 멤버 클래스의 경우 멤버 클래스의 활용은 곧 멤버 클래스의 생성자 사용이니까 내부클래스명의 생성자를 그냥 쓴다.

					new 바깥클래스명.내부클래스명( ) 	
						: 괄호 앞부분이 완전 클래스 클래스 조합이므로 (바깥클래스의 객체에) 종속되지 않은 독립적인 느낌이다 
						: 바깥클래스명.new 내부클래스명( ) 의 형태가 아님에 주의하자

 				: 주의) 어떤 멤버 클레스건 간에 바깥, 내부 클래스는 각각 독립적인 클래스이다(바깥 클래스라고 내부 클래스의 멤버에 함부로 접근할 수 있는게 아니다)


				(1) 인스턴스 멤버 클래스 << 비추. 정적 멤버 클래스 사용을 더 추천
					: 바깥클래스객체를 대상으로하여 사용 가능한 멤버인데 그 종류가 클래스인거

					: inner 인스턴스 클래스의 경우 (outer class 의 객체에 대한) 외부 참조를 가진다
						: outer class 의 객체가 존재해야 inner class의 객체도 존재가 가능하기 때문이다
						: 참고로 inner 클래스의 객체로 한번도 outer class 의 멤버를 사용하지 않으면 숨은 외부 참조를 가진다고 하고, 한번이라도 쓰면 걍 외부참조가 존재한다고 한다
						: 외부 참조를 가지기 때문에 outer 클래스의 멤버도 활용할 수 있다는 장점이 있지만 단점이 ㅈㄴ 크기때문에 인스턴스 클래스 멤버 사용이 비추되는거다
						: 외부 참조로 인한 치명적 단점 ) 외부 인스턴스에 대한 참조가 존재하기 떄문에, 가비지 컬렉션이 인스턴스 수거를 하지 못하여 "메모리 누수"가 생길 수 있다.
							: 오로지 Inner 클래스 객체를 생성하기 위해 생성한 Outer 클래스 객체를 Inner 클래스 객체 생성 이후 한번도 사용하지 않았다고 해서 그 Outer 클래스의 객체는 GC (garbage collector) 대상으로 삼아지지 않고( 직접적으로는 아무도 참조하고 있지 않지만) Inner 클래스 객체가 사용되는한 그 Inner 클래스 객체는 암묵적으로 그 Outer 클래스 객체를 참조하고 있기 때문에 잔존한다. 이는 메모리 누수로 프로그램을 터지게할 가능성이 높다.(OutOfMemoryError로 뻑나서 멈춘다)

					: 내부에서 정적 멤버의 선언이 불가하고 , 인스턴스 멤버의 선언만 가능하다
						: 내부서 정적 멤버를 선언한다고 에러가 나진 않는데 인스턴스 멤버의 의미에 어긋난다.(바깥클래스의 객체를 생성하지 않아도 " 바깥클래스명.인스턴스멤버클래스명.필드명 " 으로 사용이 가능해진다)
						: 헷갈리지 말아야할건 일반적인 클래스의 인스턴스 메서드에서는 정적 메서드의 사용이 가능한거지,  선언이 가능한게 아니다

					: 인스턴스 멤버 클래스의 생성자 활용 ===  바깥 클래스의 인스턴스 멤버 활용
						:  바깥클래스의 정적 메서드 내에서 객체 생성 불가( 인스턴스 멤버 클래스의 생성자 사용 불가)
						: 인스턴스 멤버 클래스의 객체 생성 위해선 바깥 클래스의 객체를 대상으로 생성자가 사용되어야함
					: 객체 생성 방법)
						: 바깥클래스의 외부에서)
							: 형식) 바깥클래스명.내부클래스명 내부클래스의객체참조변수명 = 바깥클래스객체명.new 내부클래스의 생성자
	
							: 근데 인스턴스 멤버 클래스가 있어도 바깥 클래스의 내부서 사용하지, 이런식으로 바깥ㅌ 클래스의 외부에선 사용 잘 안한다
							
						: 바깥클래스의 내부에서)
							: 형식) 내부클래스 내부클래스의객체참조변수명 = new 내부클래스 생성자;
								: 일반적인 타 클래스의 객체 생성하는거랑 존똑이다

					: 인스턴스 멤버 클래스 내부의 멤버 사용 방법)
						: 형식) 인스턴스멤버클래스객체명.멤버명

					: 인스턴스 멤버 클래스 내부에서의 this 객체참조변수 사용법
						this.멤버명 >> 내부 클래스의 멤버 접근
						바깥클래스명.this.멤버명 >> 바깥 클래스의 멤버 접근
							: 바깥 클래스의 객체의 맴버란 뜻
	
				(2) 정적 멤버 클래스
					: 모든 종류의 멤버를 선언할 수 있다(정적, 인스턴스 모두 가능하다)
						: 헷갈리지 말아야할 것은 일반 클래스의 정적 멤버처럼 바깥 클래스의 인스턴스 필드값은 활용하지 못한다. 걍 자체적으로 인스턴스 필드를 가질 수 있단 말이다.

					: inner static 클래스의 경우 외부 참조를 가지지 않는다.
						: outer class 의 객체 없이도 만들어질 수 있기 때문이다.

					: 객체 생성 방법)
						: 바깥 클래스의 외부에서)
							: 형식
								바깥클래스명.내부클래스명 내부클래스의객체참조변수명 = new 바깥클래스명.내부클래스명( )
									: 헷갈릴 수 있겠지만 바깥클래스명.내부클래스명 내부클래스의객체참조변수명 =  바깥클래스명. new 내부클래스명( ) 의 형태가 아니다
									; 바깥클래스의 객체를 필요로 하지 않는다
										: 정적으로 선언된 멤버니까 

						: 바깥 클래스의 내부에서)
							: ??? 예시가 안나와있다. 근데 걍 존나 평범한 객체 선언 형식 썼을땐 잘 됬다
					: 정적 멤버 클래스 내부의 멤버 사용 방법)
						: 형식)
							바깥클래스명.내부클래스명.멤버명 
								: 바깥클래스명.내부클래스명이 찐 내부클래스명인거니까
								 

		2. 로컬 클래스
			: 생성자나 메서드 내부에서 선언되는 중첩 클래스
			: 대부분 블럭의 시작과 종료와 함께 생성,소멸하지만 스레드 객체를 사용할땐 좀 다르다고 한다.
			: 내부의 로컬 변수들은 원래 final 키워드를 사용하여 선언되어야한다
				: java 8 부터는 final 키워드를 붙이지 않아도 자동으로 final 의 특성을 가지게 한다
				: 메서드가 종료되도 스레드 객체 대문에 실행 상태로 존재할 수 있어서 그렇게 강제한거다
			: 주의
				: 로컬 클래스 선언부에 접근제한자와 static을 붙이지 못한다
					: 접근 제한자를 쓰지 못하게 한 이유는 차피 메서드 내부서만 쓰이니까 외부에서의 접근을 제한 할 필요가 없기 때문
					: static 못 붙이는게 당연한게 일반적인 생성자나 메서드 내부서도 정적필든 선언 못한다. 오직 로컬 변수만 선언 가능하다.

				: 로컬클래스 선언부 이후부터 블럭의 내부에서 사용 가능하다
					: 일반적인 클래스의 경우 클래스나 메서드 선언을 뒷부분에 하고 앞에서 호출해도 괜찮지만 로컬 클래스 내부서는 글케함 오류난다	 

			: 선언 형식)
				로컬클래스명 객체참조변수명 = new 로컬클래스생성자;
					: 일반적인 객체 생성과 존똑이다
			

	: 중첩 클래스도 하나의 클래스 이기 때문에 컴파일하면 바이트코드파일(.class) 가 별도로 생성됨
		: 프로젝트 폴더의 bin 폴더 들어가면 확인 가능하다
		: 종류
			: 멤버 클래스일 경우 바이트 코드 파일명) 바깥클래스$멤버클래스.class
			: 로컬 클래스일 경우 바이트 코드 파일명) 바깥클래스$1로컬클래스.class

중첩 인터페이스 nested interface
	: 클래스의 멤버로 선언된 클래스
	: 주의할 것은 인터페이스 내부의 인터페이스를 가리키는 말이 아니라 클래스 내부에 선언된 인터페이스를 말하는 거임
	:효과) 특정 클래스와 인터페이스의 긴밀한 관계 정립 가능
	: 종류
		1. 인스턴스 멤버 인터페이스
			: 바깥 클래스의 객체가 있어야 사용 가능
		2. 정적 멤버 인터페이스
			: 주로 사용. UI 프로그래밍에서 이벤트 처리 목적으로 많이 활용
				: 내부서 객체 필드 를 가질때 그 객체가 특정 형식을 갖추도록 하는 역할.
			: 사용 형식 )
				: 외부 클래스들에서 해당 인터페이스를 implements 받는 경우, 해당 인터페이스 타입의 변수 선언하는 경우
					: 타입 == 바깥클래스명.인터페이스명
	

	: 타입 ) 바깥클래스명.인터페이스명
 



익명 객체
	: 별도의 클래스 선언없이 만든 객체
	: 언제 쓰는가
		: 아래의 3가지 조건이 다 들어맞으면
			1. 다형성 구현 상황에서
				:부모 타입으로 자식객체를 받거나 인터페이스 타입으로 구현 객체를 받는 상황에서)(왜냐하면 익명 객체 타입은 이름이 없어서 해당 타입으로 변수 선언이 불가하니까) 
			2. 일회성으로 쓸 클래스면
				: 여러번 재탕할거면 그냥 클래스 만들어두고 그걸로 생성하는게 더 빠름(일일이 익명객체 생성하는 것보다)
			3. 부모 클래스 혹은 인터페이스에 별다른 멤버 추가 안하고 오버라이딩만 하면 되는 상황에서
				: 다형성 구현 상황이기 때문에 부모 내에 혹은 인터페이스 내에있는 멤버들만 사용이 가능해서 새로운거 추가해도 못씀
	: 익명 객체 종류
		1. 익명 자식 객체
			: 다형성 구현 상황에서 자식 객체를 일회성으로 필요로 하는 경우에(재사용 필요 없는 경우) 굳이 자식 클래스를 만들지 않고 부모 클래스 만으로 생성
			: 형식 )
				부모클래스타입  레퍼런스변수명 = new 부모클래스명( param1, param2 , ... ){ 쏼라싸ㅗㄹ라 };
					: 하나의 문장이기 때문에 세미콜론 써야된다
					: 부모클래스명( param1, param2 , ... ){ 쏼라싸ㅗㄹ라 }부분은 부모 클래스를 상속해서 { 쏼라싸ㅗㄹ라 } 와 같이 자식 클래스를 선언하라는 말이고 , new ... ; 는 이렇게 선언된 익명 클래스의 객체를 생성하겠단 말이다
						: 중괄호 안에는 익명 자식 클래스의 멤버 내용이 들어간ㄴ다
							: 주로 부모 클래스의 메서드를 오버라이딩 하는 내용이 많이 들어간다
 							: 생성자는 포함하지 못한다 
								: 익명 객체의 생성과 동시에 어떤 값을 넣고 싶으면 걍 익명 객체를 사용 말아야된다
								: 익명 자식 객체의 생성시 생성자는 부모의 생성자가 실행된다.
							: 익명자식객체가 부모 클래스 타입으로 선언된거라 중괄호 안의 부모 클래스에 없는 멤버들은 익명자식객체명으로 직접적인 접근은 불가하다.  해당 멤버는 익명 클래스 내부의 멤버들만 사용가능하다(좀 로컬 변수 같은 느낌이다. 일반적인 자동형변환에서랑 같다). 
	
			: 부모 타입의 필드, 로컬변수, 매개변수로 모두 참조 받을 수 있다
			
							

		2. 익명 구현 객체
			: 구현 >> 인터페이스와 관련
			: 다형성 구현 상황에서 인터페이스의 구현 클래스가 특정 위치에서만 사용되면( 재사용되지 않으면) 굳이 구현 클래스를 따로 만들지 않고 인터페이스 만으로 생성한다
			: 형식)
				인터페이스명 레퍼런스변수명 new 인터페이스명( ){ 쏼라싸ㅗㄹ랄 ...};
					: 마찬가지로 하나의 문장이기에 세미콜론을 사용한다
					: 인터페이스는 자체적으론 생성자가 없어도 옆에 괄호를 적어야한다
						: 그럼 익명객체가 생성될때 어떠한 생성자를 이용하여 생성되는 것일까?
						: 중괄호 내부엔 실체 메서드, 실체 메서드 내부서 사용될 값을 선언한다
							: 인터페이스 내부의 모든 추상 메서드는 실체 ㅁ메서드로 구현해놔야된다.

	: 익명 객체의 로컬 변수 사용(스레드 어쩌구저쩌구)
		: 나중에 다시 보기
		: 익명 객체가 블럭이 끝나도 살아있을 수 있기때문에 익명객체서 사용하는 로컬변수 값은 익명객체 내부에 복사해두고 사용한다고 한다. 그리고 값이 변경되면 복사한 값과 달라지기 때문에 내부적으로 final 처리를 해준다(예전엔 직접 해야했지만 요즘엔 알아서 해준다)
