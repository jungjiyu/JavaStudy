1. 난수 출력 : (int)( Math.random()*발생가능난수갯수 ) + 스타트숫자

2. 최대한 간단하게 등급 매기기 : if - else if - else 성질 활용하여 한쪽변만 비교
    ex)
    int score = 69;
		if(score >= 90) {
			System.out.println("점수>=90");
			System.out.println("등급:A");
		}
		
		else if(score >= 80) {
			System.out.println("90>점수>=80");
			System.out.println("등급:b");
		}
		else if(score >= 50) {
			System.out.println("80>점수>=50");
			System.out.println("등급:c");
		}
		else {
			System.out.println("50>점수");
			System.out.println("등급:F");
		}


3. for문 외부에서도 index 쓸 수 있게 하는 법: for 문 밖에서 int i 를 선언
    ex )  
    int i;
    for(i=0;i<10;i++){
    System.out.println(i);
    } 
    System.out.prinln("for문 마지막 i값:"+i-1);


4. 유명한 예외
	1. NullpointerException : 아무것도 가리키고 있지 않는 참조변수 사용시 발생
	2. ArrayIndexOutOfBoundsException : 인덱스 초과하여 사용
	3. Cannot make a static reference to the non-static method 메서드명(매개변수명) from the type 클래스명
		: static 메서드에서 non-static 메서드를 참조하려고 할 때 발생
	4. classCastException
		: 강제형변환시키려는 타입이 잘못됬을때 발생

5. 배열을 첨부터 끝까지 복사시키는 한줄 코드 
	: System.arraycopy(복사시키는배열1 , 0 , 복사받는배열2, 0 , 복사시키는배열1.length);

6. .length
	(1) 문자열길이측정에 사용
	(2) 배열 사이즈 측정에 사용


7. 문법 추측(아마도)
	보편적인 객체 생성법
		new 키워드 사용) new 클래스명( arg )
	특수한 객체 생성법
		1. 새로운 문자열 할당
		2. 중괄호 할당
		3. 열거타입선언

8. 한 블럭 내부에서 똑같은 변수명으로 선언 못하는거지 한 프로그램 내에서는 같은 변수명으로 여러 변수 선언가능하고 이경우 가장 가까운 변수를 사용한다
 




10. 
생성자 오버라이딩 할 경우 param 적은 쪽을 앞쪽에 배치하는게 가독성이 좋고 max 인 param을 가진 생성자를 적극 활용하는게 좋다

public class Student {
	
	String name;
	int age;
	
	Student(){ } // 기본생성자
	
	Student(String  name){ // 생성자1
		this(name , 70); // 똑같은 코드 귀찮게 또 쓰지 않기 위해 첫줄에 this( ) 사용
		System.out.println("1번째 Student 생성자애 들어왔습나다");

	}
	
	Student(int age){ // 생성자2
		this("Trump",age);
		System.out.println("2번째 Student 생성자애 들어왔습나다");

	}
		
	
	Student(String name , int age){ // 생성자3
		this(age,name);
		System.out.println("3번째 Student 생성자애 들어왔습나다");
	}
	
	Student( int age, String name){ // 생성자4
		this.name = name; // 필드명과 겹치는 param명을 사용하기 위해 this 객체( 클래스 자기자신)를 사용
		this.age = age;
		System.out.println("4번째 Student 생성자애 들어왔습나다");

	}
	

}



11. 생성자의 오버라이딩에서 겹치는 부분을 맨 끝 생성자로만 실행했던것처럼, 단순히 클래스 뿐 아니라 전체적인 코드에서 많이 반복되는 부분은 걍 메서드로 대체하는 습관을 기르자(사실 당연한거임)

12. 오버로딩 vs 오버라이딩
	 오버로딩 : (하나에) 많이 싣는다
		1. 생성자 오버로딩: 생성자 여러개 만드는것 ( 생성자들의 이름은 당연히 하나다)
		2. 메소드 오버로딩: 하나의 메서드명으로 여러개의 메서드 만드는것

	오버라이딩 :

13 . 관례적인 이름 규칙
	: 일단 전반적으로 캐멀 케이스 적용됨
		: 클래스명 : 첫글자 대문자로 시작
		: 상수 : 전체 대문자로
		: 필드 : 걍 변수처럼 소문자로 시작
		: 메서드 : 소문자로  시작
		: 객체 : 소문자로 시작
		: 패키지명: 소문자로 시작
		: 접근제한자 : 소문자로 시작
		: 인터페이스 : 대문자로 시작


14. 인스턴스 필드 기본값 설정 방법
	sol1) 걍 필드 선언할때부터 값을 할당해둠
	sol2) 생성자 부분에서 할당함 

15. 정적 멤버 , 인스턴스 멤버 사용법
	(1) 멤버가 선언된 클래스의 외부에서 멤버를 사용하는 경우
		: 정적멤버 - 멤버가 선언된 클래스를 명시하여 사용
		: 인스턴스 멤버 - 객체를 직접 생성하고 객체를 명시하여 사용

	(2) 멤버가 선언된 클래스의 내부에서 멤버를 사용하는 경우
		: 정적 멤버 - ( 정적 메서드, 인스턴스 메서드 모두의 내부에서) 아무것도 명시 안하고 사용 가능 
		: 인스턴스 멤버 	
			1. 정적 메서드 내부에서- 아무리 같은 클래스 내의 인스턴스 멤버라도 그 클래스의 객체를 직접 생성하고 객체를 명시하여 사용
			2. 인스턴스 메서드 내붕에서 - 아무것도 명시 안하고 사용 가능

16. 아무리 봐도 import 할거 다 제대로 했고 죄다 public으로 해놨는데 오류나면 혹시 아예 다른 프로젝트서 import 한건 아닌지 체크해봐라;; 

17. 해당 클래스 내부에선 접근 제한자가 뭘로 되있던간에 접근 제한자 고려 안하고 맘대로 쓸 수 있다( 최고 보안 수준인 private 도 클래스 내부에선 자유롭게 쓸 수 있으니)(다만 final 이면 못바꿈 주의)


18. 클래스 내부의 메서드, 생성자 밖에선 선언용 문장 밖에 못쓴다. 물론 선언과 동시에 초기화 하는건 가능하다. 
		: 주의해야할 것이 for문 같은것도 못쓰므로 만약에 필드로 배열을 가지고 싶으면 일단 클래스 내부의 메서드와 생성자 밖에선 일단 배열참조변수선언하고 사이즈 잡아둔 다음에 생성자 부분에서 for문 써서각 인덱스에 객체를 부여함 된다

19. 잡다한거( static , final , 접근제한자) 설정 tip
	: static == 객체 생성 없이 클래스명만으로도 사용할 수 있게 한다
	: final == 한번 주어진 값을 고정시키고싶다
		: static final >> 클래스 생성 시점에서 고정. 모든 객체가 동일한 고정값 가짐. 상수
			: 반드시 해당 변수 선언과 초기화가 동시에 이루어져야한다(생성자 부분에서 초기화 못한다 - 객체 단위가 아니니까)
		: 그냥 final >> 객체 생성 시점에서 고정. 객체단위로 각각 고정값 가짐. 
			: 변수선언과 동시에 초기화 해놓거나 생성자의 내부에서 값을 초기화 시킬  수 있다.
	: 접근제한자
		: 클래스 ) 1차관문(아무리 멤버들이 public 이라 해도 클래스에 접근 불가면 소용 없음) 
			1. public >> 다른 패키지서도 사용 가능 && 부모클래스가 될 수 있게함
				: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자 관문에 영향안받음
					: public >> 모든 패키지에서접근 가능
					: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
					: default >> 같은 패키지 내에서만 접근가능
					: private >> 자신이 속한 클래스 내부에서만 접근가능 . 
		
				: 생성자 ) 1.5관문.객체 생성 관련 
					: public >> 모든 패키지에서 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public >> 모든 패키지에서 접근 가능
								: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
								: default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능. 

							: 객체 생성 안된 경우
								: 사용불가


					: protected >> 같은 패키지에서 혹은 자식 클래스에서 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
								: default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가

					: default >> 같은 패키지 내부에서만 객체 생성가능
						: 참고로 기본 생성자의 경우(기본생성자 아닌 다른 생성자엔 적용 안됨) 특별히 접근제한자를 쓰지 않는다고 default가 붙는게 아니라 자신이 속한 클래스의 접근 제한자를 따라 가기 때문에 이경우 defualt 는 없다(현재 클래스가 public 이니)
							:객체 생성된 경우
								: public , protected, default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가

					: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능 . 주로 Singleton 원할 때 사용
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default , private >> 자신이 속한 클래스 내부에서만 접근가능. 이

							: 객체 생성 안된 경우
								: 사용불가

					


			2. 암것도 안씀(default) >> 다른 패키지서 사용 불가 
				: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자 관문에 영향안받음
					: public ,protected , default >> 같은 패키지 내에서만 접근가능
					: private >> 자신이 속한 클래스 내부에서만 접근가능 . 

				: 생성자 )  1.5관문.객체 생성 관련 
					: public , protected , default >> 같은 패키지에서만 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default >> 같은 패키지에서만 접근 가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가


					
					: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능 . 주로 Singleton 원할 때 사용
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default , private >> 자신이 속한 클래스 내부에서만 접근가능. 

							: 객체 생성 안된 경우
								: 사용불가


			: 필드 , 메서드 범위 요약 
				: static 인 경우 >> 클래스의 접근 제한 이상
				: static 아닌 경우 >> 생성자의 접근 제한 이상

20. 오버라이딩할때 자식클래스에서 접근 제한을 강화할 수 없는거고(부모클래스의 접근 제한 이하만 가능한거고) , 클래스 내부에서 필드와 메서드는 클래스와 생성자의 접근제한을 약화하는 기능 구현은 불가하다(클래스, 생성자의 접근제한보다 더 아래로 실행시킬 수 없다)


21. 변수, 클래스에서의 자동형변환: 느낌이 다르다
	변수에서의 자동형변환 ) 데이터 손실 최소화 위해 크기가 더 큰 변수에 크기가 더 작은 값이 할당될때 작은 값이 더 커지는 방향으로 일어남
	클래스에서의 자동형변환 ) 부모타입이 크기가 더 작고 자식 타입이 크기가 더 크지만 , 자식 클래스에서 부모 클래스만 쏙 뺄 수 있게 하기 위해 부모타입에 자식타입이 할당될때 자식타입이 부모타입에 맞춰 커팅되는 쪽으로 일어난다


22. 크기는 자식이 더 커도 브랜치로 표현했을때 부모가 더 상위 쪽이다

23. 생성자부분에 arg 가 필요한 클래스라도 배열을 만들 수 있다. 클래스 배열 만들때 " 클래스[] 참조변수명 = new 클래스[사이즈] " 로 배열 만들때 null 값으로 자동초기화 되는 것은 생성자부분의 arg 가 아니라(생성자 호출되지도 않은 상태다) 단순 배열참조변수가 가질 값, 즉 주소값이 올 자리들이다. for문을 통하여 null 로 초기화된 자리에 new 클래스명(arg1,...) ; 를 통하여 객체를 각 인덱스별로 할당해줌 된다.

24. 당장은 arg를 쓰는 생성자만 필요로 할지라도 보편적으로는 기본생성자까지 명시해둔다
	: 혹여라도 상속받는 상황에서 자식 측에서 딱히 arg 를 필요로 하는 부모의 생성자를 쓸 필요가 없을때 아예super(); 없이도 알아서 컴파일러에 의해 실행되게 하기 위함


25. 
상속은 언제 하는가
	: 단순히 무엇을 포함하겠다고 상속한다기 보다는 해당 클래스의 기능을 업그레이드 시키고 싶을때 혹은 버전을 달리하고 싶을때 상속을 한다
		: 예시) 
			:자동차에 바퀴를 추가하고 싶다고 자동차 클래스가 타이어클래스를 상속받는게 아니다.
				: 이러고 싶음 상속받는 대신에 타이어클래스타입의 객체를 클래스 내부서 멤버로 쓴다

			:2020 타이어클래스를 2024 타이어 클래스가 상속받아 멤버의 일부를 오버라이딩하여 타이어의 성능을 업그레이드 시킨다.
	: 그러니까 비슷한 기능의 클래스끼리 상속주고받는단얘기다


26. 
다른 클래스의 객체를 부품으로 사용하고 싶을때 해당 클래스의 객체를 자신의 멤버로 한다(상속받는게 아니라)


27.
추상클래스 vs 인터페이스
: 생성자
	:추상클래스는 멤버로 생성자를 가질 수 있지만 인터페이스는 멤버로 생성자를 가지게 할 수 없다
	:추상클래스건 인터페이스건 new 연산자를 통한 객체 생성은 불가
	: 추상클래스는 자식 클래스의 객체 생성시 super(); 를 통한 객체 생성은 되지만 인터페이스는 생성자 자체가 없어 객체 생성이 되지 않는다

: 인터페이스는 확실히 자동형변환,강제형변환 개념이 있어서 instanceof 연산자 사용가능하다

28.
다형성 구현 가능
	:추상클래스.일반적인 클래스 >> 상속 관계의 클래스를 extends 받았으면
	:인터페이스 >> 같은 인터페이스 혹은 상속관계의 인터페이스를 implements 받았으면

29.

하이딩 vs 오버라이딩

: 오버라이딩
	:인스턴스 메서드를 대상으로 일어나는것이라 런타임에 일어난다(Dynamic binding)
	:자식 클래스의 생성자로 생성된 객체는 기본적으로 자식의 메서드를 참조하고 없으면 부모의 메서드를 참조한다.
	:부모의 메서드로 생성된 객체는 자식 클래스에 선언된 메서드를 참조하지 못한다.

: 하이딩은 
	:static 메서드를 대상으로 일어나는 것으로 컴파일타임때 일어난다(Static binding)
	:어떤 클래스의 생성자로 생성된 객체인가 따라 먼저 참조하는 메서드가 다르다
		: 첫번째론 생성자가 포함된 클래스 내에서 찾고 없음 그 외부 클래스의 static 메서드를 참조한다

놀랍게도 static 멤버는 상속 개념이 아닌이유
	: 그냥 봤을땐 자식클래스 내에서 별도의 객체 명시, 클래스 명시 없이 쓸 수 있어서 상속 받은거라 착각할 수 있는데 아니다
		: 자식 클래스 내서 부모클래스의 인스턴스 메서드는 사실 super.메서드명(); 으로 호출되는거고, 정적 메서드는 부모클래스.메서드명();으로 호출되는거다. 그러니까 생략되서 못알아봤던것이지, 자식 클래스가 상속을 받던 말건 정적 메서드는 사용이 가능했던 것이다.



30. 표현
 실체 어쩌구 << 추상 어쩌구를 실제로 사용할 수 있게 만든거 
	: 실체 메서드, 실체 클래스
	: 추상적인거의 반대가 실체, 실제니까.
 구현 클래스 << 인터페이스를 실제로 사용할 수 있게 만든거
	: implements 의미가 구현하다 라서 그렇다

31 . 점쓰는 경우
	1. 패키지 경로 나타낼때 ( 상위.하위.하위...)
	2. 멤버가 사용되는 대상을 나타낼따 ( 객체.멤버명 , 클래스.멤버명)
	3. 중첩클래스의 타입 ( 바깥클래스명.내부클래스명 )
	4. 중첩멤버 클래스 중 정적멤버클래스의 생성자 (  바깥클래스명.내부클래스명( ) )
	5. 중첩 인터페이스의 타입 ( 바깥클래스명.인터페이스명 )
		
	
32. 자바에서는 c언어와 다르게 배열명(배열시작주소참조변수)이 고정되있지 않고 다양한 배열 객체를 가리킬 수 잇다

