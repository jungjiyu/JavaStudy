0.
WAS == web server + web container
web container == JSP container + Servlet container +...
	Jsp container >> 웹 컨테이너에서 jsp 파일 실행시키는 부분
	servlet container >> 웹 컨테이너에서 servelt 파일 실행시키는 부분


1. jsp html 뭐 그런거에서의 prameter는 주로 다른 페이지로 이동과 동시에 전달되는 데이터를 가리키는 용어로 사용한다  (자바나 c언어서 처럼 매서드 선언부에서 선언된 변수들을 가리키기보다는... 얘네들은 걍 argument 라고 부르자) 


2. html . jsp 이런데에서는 주로 값을 " 를 사용해 입력하고 java script 같은 경우엔 주로 ' 를 사용하여 입력한다

3. context >> 
  : 애플리케이션의 맥락과 흐름을 관리하는 것과 관련된 것
  : 걍 단어로 해석하면 맥락이란 뜻인데, 이는 프로그래밍 내에서도 비슷한ㄴ 의미를 가지는것
    : context 어쩌구 예시
      1. ServletContext
        : 서블릿 컨텍스트. 그러니까 서블릿 애플리케이션의 전체적인 흐름으 관리
            : 그러니까 프로그램의 전반적인 환경관리, 상호 작용 등을 돕는 역할을 하는 객체
              - 서로 다른 서블릿 간의 공유 데이터 관리
              - 프로그램의 설정 정보 관리
              - 세션 관리
                - ... 

4. contextpath	: 서블릿컨테이너 즉 Tomcat 에서 ㅇ웹 상의 어플리케이션(=프로젝트)을 구분하기 위해 사용하는 Path.
		: 그러니까 프로젝트가 여러개고 톰캣은 하나니까 실행할때 프로젝트를 구분하기 위해 Path 를 설정하는거
		: 그러니까 결국 프로젝트 명을 의미한다
	: URL의 일부이다 << 포트번호 다음 한토막이다
		:  http://localhost:8282/Day2/Hello 에서 Day2

	: URL == 도메인:포트번호/contextpath/url매핑
  : URI == URL 에서 도메인 이런거 뺴고 contextpath 이후 부분부터의 경로

5. 경로 비교
	1.  URL
	  System.out.println("URL : " + request.getRequestURL());	---->  /http://localhost/JSP/member/list.do :  전체주소
	
	2. URI
	  System.out.println("URI : " + request.getRequestURI());	  ----> /JSP/member/list.do  :  프로젝트에서부터 현재 페이지를 부른 servlet주소까지
	
	3. ContextPath
	  System.out.println("contextPath : " + request.getContextPath());	---->  /JSP  :   프로젝트명
	
	4. ServletPath
	  System.out.println("servletPath : " + request.getServletPath());	 ----> /member/list.do  : servlet 주소
	
	


6. 인코딩 관련 정리

	(1)Servlat에서는 doPost 메서드 내부서 아래의 세 줄을 기본적으로 적어주는 편
	  request.setCharacterEncoding("UTF-8"); 
	  response.setCharacterEncoding("UTF-8"); 
	  response.setContentType("text/html; charset=UTF-8"); 
	
	  : 일단  `response.setCharacterEncoding("UTF-8")` 는 클라이언트로 부터 받은 request의  문자 인코딩을 설정합니다. 이것이 없으면 기본적으로 ISO-8859-1이 사용되니까 얘는 필수다
	  : response 객체 관련 세팅 에서는  response.setContentType("text/html; charset=UTF-8");  만 해도 문제가 없긴 하지만  response.setCharacterEncoding("UTF-8");  까지 해주는 게 좋다
	      : response.setContentType("text/html; charset=UTF-8")  >> 클라이언트에게 전달되는 응답의 콘텐츠 타입(콘텐츠의 유형과 문자 인코딩)을 설정
	      : `response.setCharacterEncoding("UTF-8")`>>   문자 인코딩을 명시적으로 설정함으로써 코드의 가독성을 높이고, 서블릿의 다른 부분에서도 이를 참조하여 사용할 수 있음.


	(2)JSP 에서는 파일 생성시 코드 윗 부분에 아래와 같은 지시자가 기본적으로 생성됨
	  <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> 
	
	  : 이때 contentType 는 Servlet의  response.setContentType 에 대응하는 거고 , pageEncoding 에서는  response.setCharacterEncoding  에 대응하는 거임
	
	  : ***** 지시자 부분 tip << 지시자 부분에서는 주로 response 객체와 관련된 설정을 지정한다(request 객와 관련된 설정을 여기서 하진 않는다) . request 객체에 관련한 설정은 스크립트릿(<% %>)에서 처리한다.
	      : 그래서 답장 받고 전송하는 코드에서 request.setCharacterEncoding("UTF-8"); 은 해주지만 별도로 response.setContentType("어쪼규") 이런건 안해주는 거다.
	

7.  의미
이클립스에서 서버의 플레이 버튼을 누르는 것 == 서버 재시작(껐다 키는거)
웹 브라우져 창 닫는거 == 클라이언트

7. 쿠키, 세션 , 어플리케이션의 비교
	: 공통점 ) 일반적으로는 클라이언트와 서버가 끊어지면(= 서버가 클라이언트에게 response 를 보낸 이후) 남남이 되지만, 이 세가지를 사용하면 연결이 끊어진 이후에도 서버와 클라이언트간의 관계를 유지할 수 있다

	: 차이점 ) 관계데이터가 저장되는 위치 && 삭제되는 상황
	: 쿠키
		: 저장위치 >> 클라이언트에게 저장된다
		: 삭제 되는 상황 
			(1) 쿠키의 유효 시간이 지남
				1. 원래 속성으로 설정했던 시간이 경과했음
				2. 서버가 쿠키에 접근하여 유효시간을 0 으로 수정함

			(3) 클라이언트가 직접 삭제함

		: (헷갈리지만) 삭제 안되는 상황
			: 해당 브라우져를 아예 닫음 (탭을 닫는게 아니라 아에 큰 X자 눌러서)
			: 서버를 재시작 << 쿠키는 클라이언트에 저장되있는거라 상관 없음

	: 세션
		: 저장 위치 >> 서버에 저장된다
		: 저장 기준 >> JsessionID 그러니까 세션 쿠키
			: 
		: 삭제되는 상황
			(1) 해당 탭만 닫기

	: 어플리케이션
		: 서버에 저장이된다
		: 서버가 종료되지 않는 한 그 내용은 저장된다


10. f12 >> 개발자모드
	: application - cookie >> 생성된 쿠키 확인 및 삭제 가능
	: network - HTTP 메세지 확인 가능


11.
	: 추상 클래스라고 죄다 상속 전용인건 아니다. 그냥 new 연산자를 이용한 객체 생성을 막고 메서드( getInstance( ) )를 이용한 객체 생성을 위해 그렇게 만든걸 수 있다. << arg 에 따라서 자동적으로 다른 자식 클래스의 객체를 생성하게 한다
		: ex >> Calendar 추상클래스의 객체를 생성하기 위해서 Calendar 클래스의 자식 클래스를 직접 만들고 그걸로 객체 생성하는게 아니라 바로 Calendar.getInstance() 로 만든다.
			: Calendar의 getInstance는 "자식" 클래스 타입을 반환합니다.
			그 자식 클래스의 타 c입을 외부에 노출하지 않는 것은, 각 환경의 jdk마다 서로 다른 클래스를 사용하기 때문이죠.
			날짜는 위치나 로케일. 시간대 상황 등에 따라 다 달라지니까요...


12. 각 웹프로젝트 별로 있는 WEB-INF/web.xml 과 Servers 디렉터리에 있는 web.xml 의 차이
	: WEB-INF/web.xml  >> 각 프로젝트마다 독립적으로 존재하고, 각 "프로젝트"에 대한 "개별" 설정을 담당한다
	: Servers 파일의 web.xml >> "서버"의 전체적인 설정을 담당하여, "모든" 프로젝트에 적용되는 설정을 관리한다.
	: 종류가 뭐가 됬건 web.xml 을 쓰는 이유 >> 유지 보수성을 높이기 위해. 
		: 각 파일마다 똑같은거 여러번 쓰고 여러번 수정할 필요가 없으니까


13. jsp 에서 out.println( );  안먹힌다. <br>을 써줘야된다.

14. 스크립트 언어>> 말 그대로 대본. 즉시 실행할 수 있는 언어
	: java script , pyton, php 등
	: 주의해야되는건 html 은 스크립트언어가 아닌 것 같다 (걍 마크업 언어)
	: 인터프리터르 사용하기 때문에 
		: (컴파일러처럼) 기계어로 변환하는 과정을 필요로 하지 않음.
		: 한줄씩 실행시ㅣ기 때문에 실행속도가 느림

15. 인터페이스 >> 상호 작용을 쉽게 할 수 있게 해주는 접점, 시스템

16. 프로세스, 스레드
	: 단위이다
	: 프로세스 process ) os 로부터 자원을 할당받은 "작업"의 단위			: 즉, 실행중인 프로그램
			: 모든 프로그램은 운영체제로부터 자원을 할당받아야 실행될 수 있따
				: 할당받는 자원의 구조
					(1) 코드영역 code >> 프로그래머가 작성한 프록르ㅐㅁ 함수들의 코드가 CPU 가 해석 가능한 기계어 형태로 작성되어있다
						: 정적영역이다
					(2) 데이터 영역 Data >> 코드가 실행되면서 사용되는 전역변수와 같은 지속적인 자료들(static 변수 , 상수 ..)이 모여있다
						: 정적 영역이다
					(3) 스택 영역 Stack >> 지역변수와 같은 함수에 의해 생기는 동적인 자료들을 보관 가능한 공간
						: 함수의 호출과 동시에 메모리가 할당되고, 함수가 종료되면 소멸한다.
					(4) 힙 영역 Heap >> 생성자 , 인스턴스와 같은 사용자에 의해 동적으로 할당되는 데이터를 위한 공간.
						: 스택 영역은 자동적으로 함수의 종료와 함께 없어질 얘들이 모여있던 곳이었다면, 여기는 사용자에 의해 사용자가 지정한 지점에서 없어지거나 지속적으로 있을 얘들을 위한 공간이다.


			: 참고로 "프로그램" 자체는 정적인, 아직 실행되지 않은 파일을 의미한다

	: 스레드 Thread ) 프로세스가 할당받은 자원을 이용하는 "실행 흐름"의 단위

(1)프로세스 >>  프로그램
		: 멀티 프로세스 >> 한 프로세스를 여러 프로세스로 구성하여 각 프로세스 별로 태스크(작업)을 처리하도록 함

	(2) 스레드 >> 한 프로세스 내에서 실행되는 클래스 같은거
17. 멀티 프로세스 , 멀티 스레드 
	: 한 어플리케이션에 대한 처리 방식
	
		: 멀티 스레드 >> 한 프로세스를 여러 스레드로 구성하여 각 스레드 별로 태스크를 처리하도록 함
		: 멀티 프로세스 보다 훨 자주 씀

18. 빌드와 컴파일
	: 컴파일은 빌드의 일부분으로, 바이트 코드로 바꾸는 과정
	: 빌드는 컴파일 하고 링크까지 하는 과정을 통틀어 의미
		: 링크 >> 컴파일된 각 파일에서 필요로 하는 요소들을 찾아 연결해주는 것

19. 원시코드 == 소스코드 , 목적코드 == 바이트코드

20. http 프로토콜
	: stateless >> 연결 종료 이후 클라이언트의 정보를 유지하지 않는다
	: connectionless >> 클라이언트가 server 로부터 response 받으면 server 와의 연결을 끊는다 

21. controller 
	: 조율자의 역할을 하는 무언가
		: 웹 개발에서는 요청을 받고 응답을 내뱉는 역할을 하는 객체 정도

22. convenienece method
	: 편의메서드. 말 그대로 편의를 위한 메서드로, 필수는 아니나 있으면 편한 메서드
	: ex) GenericServlet 의 init( )

23. servlet 의 여러 클래스들

interface ServletConfig
	: Config = Configration 
	: 개별 서블릿이 실행하기 위해 필요한 설정 정보를 제공
		: 설정정보의 형태
			(1) WebServlet
			(2) web.xml
		: 설정정보의 내용 ) 초기 파라미터 (init-param), ServletContext 객체의 주소값 등

	: 개별 서블릿을 생성할때 servlet container 에 의해 호출되어 "익명"객체로(인터페이스니까) 생성되고 (init( ) 의 arg 로 넣어야되서), 그 서블릿의 소멸과 함께 소멸됨.
		: 우리가 직접 servlet 파일에서 호출하여 객체 생성하진 않고, servlet container 가 생성해 둔 servletconfig 객체를 활용하는 거다. 

abstract class GenericServlet implements ServletConfig 
	: 제너릭을 정의한다
	: 대표 메서드
		(1) public void init(ServletConfig config)
			: ServletConfig 객체를 servlet conatiner 에 반영시키는 역할을 한다
			: 이게 실행이 안되면 나중에 ServletConfig 객체를 얻을 수 가 없어서 좆된다
			: 내부적으로 코드 마지막 부분에서 init( ) 을 호출하고 있다
			: 직접적으로 오버라이딩 하는건 비추이다
				: 만약에 오버라이딩 할꺼면 super.init(config) 를 해줘야되는데 이거 쓰는거 까먹으면 좆되서 그렇다

		(2) public void init( )
			: GenericServlet 의 init( ) 자체는 담고 있는 내용이 없고 오버라이딩 당하는 용도로 쓰인다
				: init(ServletConfig config) 의 실행을 보장하고, init(ServletConfig config) 의 실행이후 실행하고 싶은 내용을 적기에 안성 맞춤이다

		(3) public "abstract" void  service(ServletRequest req, ServletResponse res) throws ServletException, IOException
			: abstract 타입이기 때문에 service 메서드를 호출하면 GenricServlet 의 servic 메서드가 호출되는게 아니라 GenericServlet 의 자식클래스인 HttpServlet 에서 오버라이딩한 service 메서드가 실행되게 된다
			: 접근제한자가 "public"이고,  매개변수가 "Servlet"Config , "Servlet"Response 임 을 주목
				: 자식 클래스인 HTTPServlet 에서는 이를 한번 오버라이딩 할 뿐 아니라 오버로딩까지 하고 있다
					: https://www.inflearn.com/questions/758877/service-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C-%ED%95%A0%EB%95%8C-protected


		(4) public void destroy( )
			: 해당 servlet 객체에 대한 자원을 servlet container 에서 해제한다
  


abstract class HttpServlet extends GenericServlet
	: 서블릿 클래스 만들때 기본적으로 부모가 되는 클래스
	: GenericServlet을 부모 클래스로함
	: 대표 메서드
		(1) public void service(ServletRequest req , ServletResponse res) thorws ServletException	
			: GenericServlet 의 service 추상 메서드를 구현한 것(=오버라이딩한거)
			: 실제로 이 메서드를 쓰진 않음. 이걸 오버라이딩해서 가져온 후 service(HttpServletRequest, HttpServletResponse) 을 오버로딩하고자하는 목적이 큼.
				: param 의 형식을 보면 알 수 있다 싶이 httpservlet 전용이 아니기 때문에 HttpServlet 내부의 doPost, doGet 같은 메서드를 사용하지 못하기 때문에 이 자체론 별로 쓸모가 없음
				: 메서드 접근 제한자가 public 인걸 보면 알 수 있다 싶이 별로 건들여도 개의치 않는 no 중요한 얘임

		(2) protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException
			: http request 를 받고 doPost 혹은 doGet 으로 request 를 넘긴다.
			: 오버라이딩한 service 메서드를 오버로딩 한 것
			: servletReqeust , Response 가 아니라 "HTTP"ServletRequest, Response 이기 때문에 httpServlet 내부의 Dopost , DoRequest 와 같은 메서드를 사용할 수 있다
			: 오버라이딩할꺼면 접근제한자가 protected 인걸 잊지 말면서 오버라이딩하고 , "반.드.시." super.service(req, res) 를 해주어야한다.
		

[ ServletContext ]
: web application의 전역에서 공유(사용)할 수 있는 객체이다.

→ 웹 어플리케이션 내 모든 Servlet과 JSP가 공유할 수 있는 정보이다.→ 웹 어플리케이션 시작 시에 생성되고, 종료시에 소멸된다.

→ 단, ServletConfig안에 ServletContext의 주소값이 있기 때문에,

ServletConfig가 있는 객체만 ServletContext의 대상이 된다.





18. servlet --> jsp
	: 참고
		0. https://blogshine.tistory.com/25
		1. https://sallykim5087.tistory.com/122
		1. https://codevang.tistory.com/193
		2.. https://skyfox83.tistory.com/142

	: 동적처리의 역사 ) CGI --> servlet --> jsp
	: 최근 경향 ) jsp 와 servlet 을 섞어 쓴다
	: CGI )
		: 사용자의 요청을 받고, 웹 서버에서 다른 프로그램을 불러내고, 그 처리 결과를 클라이언트에게 보내주는 인터페이스
			: 그러니까 동적인 처리를 할 수 있게 해줬다
		: 단점 ) 멀티 프로세스 방식이여서 서버 부하가 큼
		: 대안 >> 멀티 스레드 기반의 Servlet 등장

	: servlet )  
		: java 언어 기반이고, java 코드 내부에 html 태그를 삽입하는 구조
		: server + applet 
		: 단점 )
			: java 언어 기반이지, html 기반이 아니라 화면 인터페이스 구현하는데 코드가 너무 길게 쓰임
			: 코드가 수정되면 다시 일일이 빌드해야됨

		: 언제 사용 )
			1.  화면 인터페이스 구현과 별 관련 없는 처리할때
			2. controller 구현할때
	: 서블릿의 라이프 사이클 
		: 처음 호출되서 .class로 컴파일되어 메모리에 상주하게 되면 해당 객체를 계속 재활용함, 
		: 참고로 kg 피피티 상으로는 requet 를 받으면 httpservletRequest, httpServletResponse 를 일단 생성한 이후, 해당 servlet 객체의 존재 유무를 찾는다고 되있는데 인터넷에 찾아봄 죄다 servlet 객체 존재유무 먼저 파악하고 (없으면 만든 후) httpservletRequest , httpservletREseponse 객체 만드는 거라 써있어서 일단 후자로 정리함

		1. servlet containter 가 servlet 관련 request 를 받음	
		2. web.xml 을 기반으로 사용자가 요청한 url 이 어느 servlet 에 대한 요청인지 찾는다
		3. 해당 servlet 의 인스턴스 존재 유무를 확인한다(= 해당 servlet 이 메모리에 로딩되어있는지 확인한다)
			case 1) 해당 servlet 이 메모리에 로딩되어있으면 >> 바로 다음단계 이동
				: 서블릿은 최초의 요청이 들어왔을때만 한번만 객체를 생성되고 그거 하나만 주구장창 사용한다(=싱글톤으로 관리된다)

			case 2 ) 해당 servlet 이 메모리에 로딩되어있지 않으면 >> servlet 인스턴스를 새로 생성한다
				1. 해당 servlet 클래스의 생성자를 실행해서 그 servlet 클래스의 인스턴스를 생성한다
				2. servlet container 가 설정정보(web.xml 속은 어노테이션)을 바탕으로 ServletConfig 객체를 생성한다
					: init(ServletConfig config) 의 arg 가 필요하기 때문
					: ServletConfig 객체 ) web.xml의 <servlet> 태그에서 설정한 정보를 서블릿 파일 내에서 추출하는 것을 가능하게 하는 객체
						: <servlet> 내부에서는 서블릿의 이름. 초기 파라미터, 듣등의 여러 속성으ㅡㄹ 결정할 수 있다.

				3.servlet containter 가 앞서 생성한 servlet 의 인스턴스를 대상으로 servletConfig 객체를 arg 로 하여 init(ServletConfig config) 메서드를 호출한다
					: 그러니까 서블릿인스턴스.init(conif객체) ; 한다는거다

				4. 다음의 init( ) 메서드가 실행된다.
						: 일단 init(ServletConfig config) 이건 init( ) 이건 GernericServlet 에 정의된 메서드이다

					 	case1 ) servlet 클래스에서 init(ServletCongfig config) 만 오버라이딩한 경우 << 비추되는 방식
							: 오버라이딩한 init(config) 가 호출된 후 super.init(config) 가 호출되어 실행된다
								: servlet클래스내서 오버라이딩 한 init(config)는 부가적인 기능하는거고 사실상 핵심적인 내용, 즉 ServletConfig 객체를 메모리에 올리는건 super.init(config) 가 하는거라서 오버라이딩할때 필수적으로 super.init(config) 를 쓰지 않으면 좆되게 된다.
 
						case2 ) servlet 클래스에서 init( ) 만 오버라이딩한 경우 << 개추
							: 해당 Servlet 클래스 내에 init(ServletConfig config) 가 오버라이딩 되있지 않으므로 GenericServlet 클래스 내의 init 이 실행되게 된다. 그리고 GenericServlet 클래스 내의 init() 은 마지막에 항상 init( ) 을 호출하게 되있으므로 해당 Servlet 클래스 내에서 오버라이딩 한 init( ) 의 내용이 실행되게 된다
								: 그러니까 init( ) 자체는 init(ServletConfig config) 실행될때 같이 실행할 내용 적는거임

							: 오버라이딩 할꺼면 지켜야하는 형식 )
								@Override
								public void init() throws ServletException{
									...
								}

						case3 ) init(ServletCongfig config) 이건 init() 이건 둘다 오버라이딩 안한 경우
							: 걍 GenericServlet 의 init(ServletConfig config) 만 실행된다.


			5. HttpServletRequest, HttpServletResponse 객체를 생성함
				: (servlet 객체가 이미 있냐 없냐 상관없이 ) HttpServletRequest, HttpServletResponse 객체는 request 마다 새로 생성됨 
					: request 마다 다 같은 내용을 담고 있는게 아니니까
				: HttpServletRequest객체는 http request 의 정보를 servlet 에게 전달하기 위해 사용되는 객체로, 서블릿 컨테이너에서 생성되고, 서블릿에게 전달된다.
				: HttpServletResponse객체는 http response의 정보를 클라이언트에게 전달하기 위해 사용하는 객체로, 마찬가지로 servlet containter 에서 생성되고, 서블릿에게 전달되고, 서블릿은 여기에 response 정보를 담아 반환한다.
			6. HttpServlet에 정의된 service(ServletRequest, ServletRespone) 메서드가 호출되고, 이 메서드 내부에서  HttpServlet에 정의된 또다른 메서드인 service(HttpServletRequest , HttpServletResponse ) 메서드를 호출한다
				: HttpServlet에 정의된  service(ServletRequest, ServletRespone) 의 param 타입을 보면 알 수 있듯이 부모 타입이고 내부적으로 어떤 자식 타입이냐에 따라서 내부에서 호출하는 service(  )메서드가 달라진다.

				: 오버라이딩하는 경우   service(HttpServletRequest , HttpServletResponse )  메소드를 주로 오버라이딩한다. 
					@Override
					protected void service( HttpServletRequest , HttpServletResponse ) throws ServletException,IOException{
						...
						super.service();
					}

			7. service( ....) 메서드는 arg 로 들어온 HttpServletRequest 따라서  doGet 혹은 doPost 를 호출한다
			8. doGet ( ) 혹은 doPost(  )에서 동적 페이지를 생성하고, response을 보낸다

			9. "하나"의 request 에 대한 resposne 가 모두 끝나면(=service(... ) 가 종료되면 ) HttpServletRequset 와 HttpServletResponse 두 객체는 모두 소멸 된다.
				: HttpServletResponse , HttpServleetRequest 는 각각 serivce(  )메서드가 실행되는 동안에만 메모리에 상주하고 있는거다

			9.자원해제시  destroy() 메서드를 호출되고, 실행된다.
				: 자원해제 
					case1. 서블릿을 수정
					case2. 서버 종료
				
				: 오버라이딩 할꺼면 지켜야하는 형식)
					@Override
					protected void destroy( ){
					...
					super.destroy();
					}

			
	
	: jsp ) 
		: html 코드 기반이고, 자바 코드가 삽입되는 구조
		: Java Server Page
		: 장점
			: html 언어 바로 사용 가능하고, 다양한 태그를 활용하여 자바 코드도 쉽게 삽입 가능
			: 코드를 수정하면 알아서 컴파일해줄껄?
		: Servlet 을 기반으로 한다
		: jsp 파일이 실행되는 과정
			: jsp 컨테이너는 jsp 파일을 서블릿 소스로 변환하는 과정까지만 담당하고, 변환된 서블릿의 수행은 서블릿 컨테이너로 넘어가서 실행한다
			1. 웹 서버로부터 HTTPrequest 중에서도 jsp 파일을 요청하는 request 를 JSP컨테이너가 받음 
			2. 기존에 request 되었던 jsp 파일이닞
				(1) 웹
				(2) jsp 가 서블릿컨테이너에서 서블릿 소스코드로 변환됨
				(3) 서블릿 소스코드는 자동으로 컴파일 된 후 실행되어 결과를 html 형태로 클라이언트에게 돌려줌

		:사용자에게 결과를 보여주는 View 층을 담당 
			: html 코드 사용이 편리해서 그렇다


	: 
		
			
