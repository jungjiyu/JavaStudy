1. 난수 출력 : (int)( Math.random()*발생가능난수갯수 ) + 스타트숫자

2. 최대한 간단하게 등급 매기기 : if - else if - else 성질 활용하여 한쪽변만 비교
    ex)
    int score = 69;
		if(score >= 90) {
			System.out.println("점수>=90");
			System.out.println("등급:A");
		}
		
		else if(score >= 80) {
			System.out.println("90>점수>=80");
			System.out.println("등급:b");
		}
		else if(score >= 50) {
			System.out.println("80>점수>=50");
			System.out.println("등급:c");
		}
		else {
			System.out.println("50>점수");
			System.out.println("등급:F");
		}


3. for문 외부에서도 index 쓸 수 있게 하는 법: for 문 밖에서 int i 를 선언
    ex )  
    int i;
    for(i=0;i<10;i++){
    System.out.println(i);
    } 
    System.out.prinln("for문 마지막 i값:"+i-1);


4. 유명한 예외
	1. NullpointerException : 아무것도 가리키고 있지 않는 참조변수 사용시 발생
	2. ArrayIndexOutOfBoundsException : 인덱스 초과하여 사용

5. 배열을 첨부터 끝까지 복사시키는 한줄 코드 
	: System.arraycopy(복사시키는배열1 , 0 , 복사받는배열2, 0 , 복사시키는배열1.length);

6. .length
	(1) 문자열길이측정에 사용
	(2) 배열 사이즈 측정에 사용


7. 문법 추측(아마도)
	보편적인 객체 생성법
		new 키워드 사용) new 클래스명( arg )
	특수한 객체 생성법
		1. 새로운 문자열 할당
		2. 중괄호 할당
		3. 열거타입선언

8. 한 블럭 내부에서 똑같은 변수명으로 선언 못하는거지 한 프로그램 내에서는 같은 변수명으로 여러 변수 선언가능하고 이경우 가장 가까운 변수를 사용한다
 




10. 
생성자 오버라이딩 할 경우 param 적은 쪽을 앞쪽에 배치하는게 가독성이 좋고 max 인 param을 가진 생성자를 적극 활용하는게 좋다

public class Student {
	
	String name;
	int age;
	
	Student(){ } // 기본생성자
	
	Student(String  name){ // 생성자1
		this(name , 70); // 똑같은 코드 귀찮게 또 쓰지 않기 위해 첫줄에 this( ) 사용
		System.out.println("1번째 Student 생성자애 들어왔습나다");

	}
	
	Student(int age){ // 생성자2
		this("Trump",age);
		System.out.println("2번째 Student 생성자애 들어왔습나다");

	}
		
	
	Student(String name , int age){ // 생성자3
		this(age,name);
		System.out.println("3번째 Student 생성자애 들어왔습나다");
	}
	
	Student( int age, String name){ // 생성자4
		this.name = name; // 필드명과 겹치는 param명을 사용하기 위해 this 객체( 클래스 자기자신)를 사용
		this.age = age;
		System.out.println("4번째 Student 생성자애 들어왔습나다");

	}
	

}



11. 생성자의 오버라이딩에서 겹치는 부분을 맨 끝 생성자로만 실행했던것처럼, 단순히 클래스 뿐 아니라 전체적인 코드에서 많이 반복되는 부분은 걍 메서드로 대체하는 습관을 기르자(사실 당연한거임)

12. 오버로딩 vs 오버라이딩
	 오버로딩 : (하나에) 많이 싣는다
		1. 생성자 오버로딩: 생성자 여러개 만드는것 ( 생성자들의 이름은 당연히 하나다)
		2. 메소드 오버로딩: 하나의 메서드명으로 여러개의 메서드 만드는것

	오버라이딩 :

13 . 관례적인 이름 규칙
	: 일단 전반적으로 캐멀 케이스 적용됨
		: 클래스명 : 첫글자 대문자로 시작
		: enum 상수 : 전체 대문자로
		: 필드 : 걍 변수처럼 소문자로 시작
		: 메서드 : 소문자로  시작
		: 객체 : 소문자로 시작
		: 패키지명: 소문자로 시작
		: 접근제한자 : 소문자로 시작


14. 인스턴스 필드 기본값 설정 방법
	sol1) 걍 필드 선언할때부터 값을 할당해둠
	sol2) 생성자 부분에서 할당함 

15. 정적 멤버 , 인스턴스 멤버 사용법
	(1) 멤버가 선언된 클래스의 외부에서 멤버를 사용하는 경우
		: 정적멤버 - 멤버가 선언된 클래스를 명시하여 사용
		: 인스턴스 멤버 - 객체를 직접 생성하고 객체를 명시하여 사용

	(2) 멤버가 선언된 클래스의 내부에서 멤버를 사용하는 경우
		: 정적 멤버 - ( 정적 메서드, 인스턴스 메서드 모두의 내부에서) 아무것도 명시 안하고 사용 가능 
		: 인스턴스 멤버 	
			1. 정적 메서드 내부에서- 아무리 같은 클래스 내의 인스턴스 멤버라도 그 클래스의 객체를 직접 생성하고 객체를 명시하여 사용
			2. 인스턴스 메서드 내붕에서 - 아무것도 명시 안하고 사용 가능

16. 아무리 봐도 import 할거 다 제대로 했고 죄다 public으로 해놨는데 오류나면 혹시 아예 다른 프로젝트서 import 한건 아닌지 체크해봐라;; 

17. 해당 클래스 내부에선 접근 제한자가 뭘로 되있던간에 접근 제한자 고려 안하고 맘대로 쓸 수 있다( 최고 보안 수준인 private 도 클래스 내부에선 자유롭게 쓸 수 있으니)(다만 final 이면 못바꿈 주의)


18. 클래스 내부의 메서드, 생성자 밖에선 선언용 문장 밖에 못쓴다. 물론 선언과 동시에 초기화 하는건 가능하다. 

19. 잡다한거( static , final , 접근제한자) 설정 tip
	: static == 객체 생성 없이 클래스명만으로도 사용할 수 있게 한다
	: final == 한번 주어진 값을 고정시키고싶다
		: static final >> 클래스 생성 시점에서 고정. 모든 객체가 동일한 고정값 가짐. 상수
			: 반드시 해당 변수 선언과 초기화가 동시에 이루어져야한다(생성자 부분에서 초기화 못한다 - 객체 단위가 아니니까)
		: 그냥 final >> 객체 생성 시점에서 고정. 객체단위로 각각 고정값 가짐. 
			: 변수선언과 동시에 초기화 해놓거나 생성자의 내부에서 값을 초기화 시킬  수 있다.
	: 접근제한자
		: 클래스 ) 1차관문(아무리 멤버들이 public 이라 해도 클래스에 접근 불가면 소용 없음) 
			1. public >> 다른 패키지서도 사용 가능 && 부모클래스가 될 수 있게함
				: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자 관문에 영향안받음
					: public >> 모든 패키지에서접근 가능
					: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
					: default >> 같은 패키지 내에서만 접근가능
					: private >> 자신이 속한 클래스 내부에서만 접근가능 . 
		
				: 생성자 ) 1.5관문.객체 생성 관련 
					: public >> 모든 패키지에서 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public >> 모든 패키지에서 접근 가능
								: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
								: default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능. 

							: 객체 생성 안된 경우
								: 사용불가


					: protected >> 같은 패키지에서 혹은 자식 클래스에서 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
								: default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가


					: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능 . 주로 Singleton 원할 때 사용
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default , private >> 자신이 속한 클래스 내부에서만 접근가능. 이

							: 객체 생성 안된 경우
								: 사용불가

					: 참고로 생성자만 단순히 접근제한자를 쓰지 않는다고 default가 붙는게 아니라 자신이 속한 클래스의 접근 제한자를 따라 가기 때문에 이경우 defualt 는 없다 


			2. 암것도 안씀(default) >> 다른 패키지서 사용 불가 && 부모클래스가 될 수 없게함
				: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자 관문에 영향안받음
					: public ,protected , default >> 같은 패키지 내에서만 접근가능
					: private >> 자신이 속한 클래스 내부에서만 접근가능 . 

				: 생성자 )  1.5관문.객체 생성 관련 
					: public , protected , default >> 같은 패키지에서만 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default >> 같은 패키지에서만 접근 가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가


					
					: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능 . 주로 Singleton 원할 때 사용
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default , private >> 자신이 속한 클래스 내부에서만 접근가능. 

							: 객체 생성 안된 경우
								: 사용불가


			: 필드 , 메서드 범위 요약 
				: static 인 경우 >> 클래스의 접근범위 이하
				: static 아닌 경우 >> 생성자의 접근범위 이하

