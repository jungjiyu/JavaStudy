1. 난수 출력 : (int)( Math.random()*발생가능난수갯수 ) + 스타트숫자

2. 최대한 간단하게 등급 매기기 : if - else if - else 성질 활용하여 한쪽변만 비교
    ex)
    int score = 69;
		if(score >= 90) {
			System.out.println("점수>=90");
			System.out.println("등급:A");
		}
		
		else if(score >= 80) {
			System.out.println("90>점수>=80");
			System.out.println("등급:b");
		}
		else if(score >= 50) {
			System.out.println("80>점수>=50");
			System.out.println("등급:c");
		}
		else {
			System.out.println("50>점수");
			System.out.println("등급:F");
		}


3. for문 외부에서도 index 쓸 수 있게 하는 법: for 문 밖에서 int i 를 선언
    ex )  
    int i;
    for(i=0;i<10;i++){
    System.out.println(i);
    } 
    System.out.prinln("for문 마지막 i값:"+i-1);


4. 유명한 예외
	1. NullpointerException : 아무것도 가리키고 있지 않는 참조변수 사용시 발생
	2. ArrayIndexOutOfBoundsException : 인덱스 초과하여 사용
	3. Cannot make a static reference to the non-static method 메서드명(매개변수명) from the type 클래스명
		: static 메서드에서 non-static 메서드를 참조하려고 할 때 발생
	4. classCastException
		: 강제형변환시키려는 타입이 잘못됬을때 발생

5. 배열을 첨부터 끝까지 복사시키는 한줄 코드 
	: System.arraycopy(복사시키는배열1 , 0 , 복사받는배열2, 0 , 복사시키는배열1.length);

6. .length
	(1) 문자열길이측정에 사용
	(2) 배열 사이즈 측정에 사용


7. 문법 추측(아마도)
	보편적인 객체 생성법
		new 키워드 사용) new 클래스명( arg )
	특수한 객체 생성법
		1. 새로운 문자열 할당
		2. 중괄호 할당
		3. 열거타입선언

8. 한 블럭 내부에서 똑같은 변수명으로 선언 못하는거지 한 프로그램 내에서는 같은 변수명으로 여러 변수 선언가능하고 이경우 가장 가까운 변수를 사용한다
 




10. 
생성자 오버라이딩 할 경우 param 적은 쪽을 앞쪽에 배치하는게 가독성이 좋고 max 인 param을 가진 생성자를 적극 활용하는게 좋다

public class Student {
	
	String name;
	int age;
	
	Student(){ } // 기본생성자
	
	Student(String  name){ // 생성자1
		this(name , 70); // 똑같은 코드 귀찮게 또 쓰지 않기 위해 첫줄에 this( ) 사용
		System.out.println("1번째 Student 생성자애 들어왔습나다");

	}
	
	Student(int age){ // 생성자2
		this("Trump",age);
		System.out.println("2번째 Student 생성자애 들어왔습나다");

	}
		
	
	Student(String name , int age){ // 생성자3
		this(age,name);
		System.out.println("3번째 Student 생성자애 들어왔습나다");
	}
	
	Student( int age, String name){ // 생성자4
		this.name = name; // 필드명과 겹치는 param명을 사용하기 위해 this 객체( 클래스 자기자신)를 사용
		this.age = age;
		System.out.println("4번째 Student 생성자애 들어왔습나다");

	}
	

}



11. 생성자의 오버라이딩에서 겹치는 부분을 맨 끝 생성자로만 실행했던것처럼, 단순히 클래스 뿐 아니라 전체적인 코드에서 많이 반복되는 부분은 걍 메서드로 대체하는 습관을 기르자(사실 당연한거임)

12. 오버로딩 vs 오버라이딩
	 오버로딩 : (하나에) 많이 싣는다
		1. 생성자 오버로딩: 생성자 여러개 만드는것 ( 생성자들의 이름은 당연히 하나다)
		2. 메소드 오버로딩: 하나의 메서드명으로 여러개의 메서드 만드는것

	오버라이딩 :

13 . 관례적인 이름 규칙
	: 일단 전반적으로 캐멀 케이스 적용됨
		: 클래스명 : 첫글자 대문자로 시작
		: 상수 : 전체 대문자로
		: 필드 : 걍 변수처럼 소문자로 시작
		: 메서드 : 소문자로  시작
		: 객체 : 소문자로 시작
		: 패키지명: 소문자로 시작
		: 접근제한자 : 소문자로 시작
		: 인터페이스 : 대문자로 시작


14. 인스턴스 필드 기본값 설정 방법
	sol1) 걍 필드 선언할때부터 값을 할당해둠
	sol2) 생성자 부분에서 할당함 

15. 정적 멤버 , 인스턴스 멤버 사용법
	(1) 멤버가 선언된 클래스의 외부에서 멤버를 사용하는 경우
		: 정적멤버 - 멤버가 선언된 클래스를 명시하여 사용
		: 인스턴스 멤버 - 객체를 직접 생성하고 객체를 명시하여 사용

	(2) 멤버가 선언된 클래스의 내부에서 멤버를 사용하는 경우
		: 정적 멤버 - ( 정적 메서드, 인스턴스 메서드 모두의 내부에서) 아무것도 명시 안하고 사용 가능 
		: 인스턴스 멤버 	
			1. 정적 메서드 내부에서- 아무리 같은 클래스 내의 인스턴스 멤버라도 그 클래스의 객체를 직접 생성하고 객체를 명시하여 사용
			2. 인스턴스 메서드 내붕에서 - 아무것도 명시 안하고 사용 가능

16. 아무리 봐도 import 할거 다 제대로 했고 죄다 public으로 해놨는데 오류나면 혹시 아예 다른 프로젝트서 import 한건 아닌지 체크해봐라;; 

17. 해당 클래스 내부에선 접근 제한자가 뭘로 되있던간에 접근 제한자 고려 안하고 맘대로 쓸 수 있다( 최고 보안 수준인 private 도 클래스 내부에선 자유롭게 쓸 수 있으니)(다만 final 이면 못바꿈 주의)


18. 클래스 내부의 메서드, 생성자 밖에선 선언용 문장 밖에 못쓴다. 물론 선언과 동시에 초기화 하는건 가능하다. 
		: 주의해야할 것이 for문 같은것도 못쓰므로 만약에 필드로 배열을 가지고 싶으면 일단 클래스 내부의 메서드와 생성자 밖에선 일단 배열참조변수선언하고 사이즈 잡아둔 다음에 생성자 부분에서 for문 써서각 인덱스에 객체를 부여함 된다

19. 잡다한거( static , final , 접근제한자) 설정 tip
	: static == 객체 생성 없이 클래스명만으로도 사용할 수 있게 한다
	: final == 한번 주어진 값을 고정시키고싶다
		: static final >> 클래스 생성 시점에서 고정. 모든 객체가 동일한 고정값 가짐. 상수
			: 반드시 해당 변수 선언과 초기화가 동시에 이루어져야한다(생성자 부분에서 초기화 못한다 - 객체 단위가 아니니까)
		: 그냥 final >> 객체 생성 시점에서 고정. 객체단위로 각각 고정값 가짐. 
			: 변수선언과 동시에 초기화 해놓거나 생성자의 내부에서 값을 초기화 시킬  수 있다.
	: 접근제한자
		: 클래스 ) 1차관문(아무리 멤버들이 public 이라 해도 클래스에 접근 불가면 소용 없음) 
			1. public >> 다른 패키지서도 사용 가능 && 부모클래스가 될 수 있게함
				: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자 관문에 영향안받음
					: public >> 모든 패키지에서접근 가능
					: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
					: default >> 같은 패키지 내에서만 접근가능
					: private >> 자신이 속한 클래스 내부에서만 접근가능 . 
		
				: 생성자 ) 1.5관문.객체 생성 관련 
					: public >> 모든 패키지에서 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public >> 모든 패키지에서 접근 가능
								: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
								: default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능. 

							: 객체 생성 안된 경우
								: 사용불가


					: protected >> 같은 패키지에서 혹은 자식 클래스에서 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected >> 같은 패키지에서 혹은 자식 클래스에서 접근가능
								: default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가

					: default >> 같은 패키지 내부에서만 객체 생성가능
						: 참고로 기본 생성자의 경우(기본생성자 아닌 다른 생성자엔 적용 안됨) 특별히 접근제한자를 쓰지 않는다고 default가 붙는게 아니라 자신이 속한 클래스의 접근 제한자를 따라 가기 때문에 이경우 defualt 는 없다(현재 클래스가 public 이니)
							:객체 생성된 경우
								: public , protected, default >> 같은 패키지 내에서만 접근가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가

					: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능 . 주로 Singleton 원할 때 사용
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default , private >> 자신이 속한 클래스 내부에서만 접근가능. 이

							: 객체 생성 안된 경우
								: 사용불가

					


			2. 암것도 안씀(default) >> 다른 패키지서 사용 불가 
				: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자 관문에 영향안받음
					: public ,protected , default >> 같은 패키지 내에서만 접근가능
					: private >> 자신이 속한 클래스 내부에서만 접근가능 . 

				: 생성자 )  1.5관문.객체 생성 관련 
					: public , protected , default >> 같은 패키지에서만 객체 생성 가능
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default >> 같은 패키지에서만 접근 가능
								: private >> 자신이 속한 클래스 내부에서만 접근가능.

							: 객체 생성 안된 경우
								: 사용불가


					
					: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능 . 주로 Singleton 원할 때 사용
						: static 아닌 필드 , 메서드 ) 객체를 대상으로 접근. 2관문. 
							:객체 생성된 경우
								: public , protected ,default , private >> 자신이 속한 클래스 내부에서만 접근가능. 

							: 객체 생성 안된 경우
								: 사용불가


			: 필드 , 메서드 범위 요약 
				: static 인 경우 >> 클래스의 접근 제한 이상
				: static 아닌 경우 >> 생성자의 접근 제한 이상

20. 오버라이딩할때 자식클래스에서 접근 제한을 강화할 수 없는거고(부모클래스의 접근 제한 이하만 가능한거고) , 클래스 내부에서 필드와 메서드는 클래스와 생성자의 접근제한을 약화하는 기능 구현은 불가하다(클래스, 생성자의 접근제한보다 더 아래로 실행시킬 수 없다)


21. 변수, 클래스에서의 자동형변환: 느낌이 다르다
	변수에서의 자동형변환 ) 데이터 손실 최소화 위해 크기가 더 큰 변수에 크기가 더 작은 값이 할당될때 작은 값이 더 커지는 방향으로 일어남
	클래스에서의 자동형변환 ) 부모타입이 크기가 더 작고 자식 타입이 크기가 더 크지만 , 자식 클래스에서 부모 클래스만 쏙 뺄 수 있게 하기 위해 부모타입에 자식타입이 할당될때 자식타입이 부모타입에 맞춰 커팅되는 쪽으로 일어난다


22. 크기는 자식이 더 커도 브랜치로 표현했을때 부모가 더 상위 쪽이다

23. 생성자부분에 arg 가 필요한 클래스라도 배열을 만들 수 있다. 클래스 배열 만들때 " 클래스[] 참조변수명 = new 클래스[사이즈] " 로 배열 만들때 null 값으로 자동초기화 되는 것은 생성자부분의 arg 가 아니라(생성자 호출되지도 않은 상태다) 단순 배열참조변수가 가질 값, 즉 주소값이 올 자리들이다. for문을 통하여 null 로 초기화된 자리에 new 클래스명(arg1,...) ; 를 통하여 객체를 각 인덱스별로 할당해줌 된다.

24. 당장은 arg를 쓰는 생성자만 필요로 할지라도 보편적으로는 기본생성자까지 명시해둔다
	: 혹여라도 상속받는 상황에서 자식 측에서 딱히 arg 를 필요로 하는 부모의 생성자를 쓸 필요가 없을때 아예super(); 없이도 알아서 컴파일러에 의해 실행되게 하기 위함


25. 
상속은 언제 하는가
	: 단순히 무엇을 포함하겠다고 상속한다기 보다는 해당 클래스의 기능을 업그레이드 시키고 싶을때 혹은 버전을 달리하고 싶을때 상속을 한다
		: 예시) 
			:자동차에 바퀴를 추가하고 싶다고 자동차 클래스가 타이어클래스를 상속받는게 아니다.
				: 이러고 싶음 상속받는 대신에 타이어클래스타입의 객체를 클래스 내부서 멤버로 쓴다

			:2020 타이어클래스를 2024 타이어 클래스가 상속받아 멤버의 일부를 오버라이딩하여 타이어의 성능을 업그레이드 시킨다.
	: 그러니까 비슷한 기능의 클래스끼리 상속주고받는단얘기다


26. 
다른 클래스의 객체를 부품으로 사용하고 싶을때 해당 클래스의 객체를 자신의 멤버로 한다(상속받는게 아니라)


27.
추상클래스 vs 인터페이스
: 생성자
	:추상클래스는 멤버로 생성자를 가질 수 있지만 인터페이스는 멤버로 생성자를 가지게 할 수 없다
	:추상클래스건 인터페이스건 new 연산자를 통한 객체 생성은 불가
	: 추상클래스는 자식 클래스의 객체 생성시 super(); 를 통한 객체 생성은 되지만 인터페이스는 생성자 자체가 없어 객체 생성이 되지 않는다

: 인터페이스는 확실히 자동형변환,강제형변환 개념이 있어서 instanceof 연산자 사용가능하다

28.
다형성 구현 가능
	:추상클래스.일반적인 클래스 >> 상속 관계의 클래스를 extends 받았으면
	:인터페이스 >> 같은 인터페이스 혹은 상속관계의 인터페이스를 implements 받았으면

29.

하이딩 vs 오버라이딩

상속 클래스에서 자식 클래스에 부모클래스의 멤버와 같은 이름의 멤버가 선언되어있는 경우
	필드>> 정적이냐 인스턴스냐 상관없이 오버라이딩이 아닌 하이딩 이 일어남
	메서드>> 정적이면 하이딩 인스턴스면 오버라이딩
package staticPractice; 
public class Parent { 
  String name ="Parent"; 
  Parent(){ 
    System.out.println("Parent생성자 실행"); 
 } 
 static void mtd() { 
   System.out.println("i am a parent"); 
} 
} 

package staticPractice; 
public class Child extends Parent{ 
  String name = "Child"; 
  Child(){ 
    System.out.println("Child 생성자 실행"); 
 } 
 static void mtd() { 
   System.out.println("i am a child"); 
} 
} 


package staticPractice; 
public class Run { 
  public static void main(String[] args) { 
    Child child = new Child(); 
    child.mtd(); 
    System.out.println(child.name); 
    Parent parent = new Child(); 
    parent.mtd();// 오버라이딩 된게 아니다 
    System.out.println(parent.name);// 오버라이딩 된게 아니다 
 } 
} 


: 오버라이딩
	:인스턴스 메서드를 대상으로 일어나는것이라 런타임에 일어난다(Dynamic binding)
	:자식 클래스의 생성자로 생성된 객체는 기본적으로 자식의 메서드를 참조하고 없으면 부모의 메서드를 참조한다.
	:부모의 메서드로 생성된 객체는 자식 클래스에 선언된 메서드를 참조하지 못한다.

: 하이딩은 
	:static 메서드를 대상으로 일어나는 것으로 컴파일타임때 일어난다(Static binding)
	:어떤 클래스의 생성자로 생성된 객체인가 따라 먼저 참조하는 메서드가 다르다
		: 첫번째론 생성자가 포함된 클래스 내에서 찾고 없음 그 외부 클래스의 static 메서드를 참조한다

놀랍게도 static 멤버는 상속 개념이 아닌이유
	: 그냥 봤을땐 자식클래스 내에서 별도의 객체 명시, 클래스 명시 없이 쓸 수 있어서 상속 받은거라 착각할 수 있는데 아니다
		: 자식 클래스 내서 부모클래스의 인스턴스 메서드는 사실 super.메서드명(); 으로 호출되는거고, 정적 메서드는 부모클래스.메서드명();으로 호출되는거다. 그러니까 생략되서 못알아봤던것이지, 자식 클래스가 상속을 받던 말건 정적 메서드는 사용이 가능했던 것이다.



30. 표현
 실체 어쩌구 << 추상 어쩌구를 실제로 사용할 수 있게 만든거 
	: 실체 메서드, 실체 클래스
	: 추상적인거의 반대가 실체, 실제니까.
 구현 클래스 << 인터페이스를 실제로 사용할 수 있게 만든거
	: implements 의미가 구현하다 라서 그렇다

31 . 점쓰는 경우
	1. 패키지 경로 나타낼때 ( 상위.하위.하위...)
	2. 멤버가 사용되는 대상을 나타낼따 ( 객체.멤버명 , 클래스.멤버명)
	3. 중첩클래스의 타입 ( 바깥클래스명.내부클래스명 )
	4. 중첩멤버 클래스 중 정적멤버클래스의 생성자 (  바깥클래스명.내부클래스명( ) )
	5. 중첩 인터페이스의 타입 ( 바깥클래스명.인터페이스명 )
		
	
32. 자바에서는 c언어와 다르게 배열명(배열시작주소참조변수)이 고정되있지 않고 다양한 배열 객체를 가리킬 수 잇다

33. while , if 의 조건문 부분에서 새로운 변수 선언이 불가한거지 미리 만든 변수에 객체 생성, 할당은 가능하다. 근데 괄호쳐야 인식 됨을 주의
	ex) 
	int a ;
	while( (a=10) <9 ){ 어쩌구 저쩌구 }


34. for 문으로 간단하게 char 형 배열에 a 부터 z까지 저장하기
for(int i ='a' ; i <='z' ; i++){
	ary[ i - 'a'] = (char)i;
}


35 추상클래스, 인터페이스는 직접 객체를 생성하지 못하는거지 그 타입으로 레퍼런스 변수는 만들 수 있다
	ex) new InputStream();은 못하지만 InputStream is; 는 가능 

36. 한 스레드로 뭔가 순차적인 출력을 해야할때는 스레드의 run( ) 내부서 반복문 돌리는게 좋다
	: run ( ) 내부서 한번만 실행하게 하고 스레드 객체를 여러번 순차적으로 생성시키는게 더 어렵기 때문에 한 스레드 객체 내부에서 반복문을 돌리는게 깔끔하다
		: ex) 
public class A extends Thread{
int index;
A(int index){
this.index = index;
}
public void run(){
	System.out.println(index);
}
}
로 정의하고 메인스레드서

for(int i = 0 ; i <10 ; i++){
	A a = new A(i);
	a.start();
}
를 썼을때
0 1 2 3 4 5 6 7 8 9 처럼 예쁘게 출력된다는 보장이 없지만( 대부분 9 2 8 3 7 0 4 6 5 1 처럼 무작위 순서로 더럽게 나옴)

public class A extends Thread{

public void run(){
	for(int i=0;i<10;i++){
	System.out.println(i);
	}
}
}
로 run()내부에 반복문 쓰고 메인스레드서
A a = new A();
a.start();
한번만 쓰는게 훨씬 간단하고 출력도 실제로 이쁘게 나온다




33. call by value 
	: 자바는 call by value 라서 arg 로 넘긴 레퍼런스 변수를 타 메서드에서 다른 객체를 가리키게 했다고 해도 해당 메서드를 벗어나면 소용 없는 짓이 된다.
		: 예시 )
			public static void main(String[] args) {
				
				int[] ary = new int[10];
				for(int i  =  0 ; i <5;i++) {
					mthd(ary); // mthd 내부에서 ary 가 다른 객체를 가리키게 한다
					System.out.println(ary); // 똑같은 주소만 나온다
				}	
			}
		
		
			public static void mthd(int[] ary) {
				ary = new int[100];	
			}

		: 해결방법 << 일단 c언어처럼 포인터 개념으로 call by reference 흉내를 내진 않는다
			(1) 타 메서드에서의 변경사항을 반영하고 싶은 레퍼런스 변수를 필드로 만들어서 모든 메서드가 공유하게 한다
			(2) return 값으로 그 객체의 주소를 넘긴다 << 근데 이건 딱히 변경사항을 반영한다기 보다는 걍 새로운 값 생성해서 넘겨준거임.
				: 예시

			public static void main(String[] args) {
				
				int[] ary = new int[10];
				for(int i  =  0 ; i <5;i++) {
					ary = mthd(); 
					System.out.println(ary); // 변경하고 싶은 내용이 적용됬다
				}	
			}
		
		
			public static int[] mthd( ) {
				int [] ary = new int[100];	
				return ary;
			}

	: 주의 ) 다른 메서드에서 변경한 사항이 적용되지 않는거지 같은 메서드내에서 어떤 블럭의 내부에서 적용됬다 하더라도 그 메서드 내에선 다 적용된다. 그리고 또 주의해야할 것은 블럭 내의 변경 사항이 적용되는 것은 이미 블럭 외부서 선언되었던 변수의 경우에 가능한거고 블럭 내부서 선언된 변수는 그 블럭의 로컬 변수로 그 블럭을 벗어나면 없어진다는 것을 잊지 말아야한다
		: try-catch 구문의 경우에도 적용되는 사항이다
			: 다만 주의해야 할 것은 try 블럭 내부서 초기화를 시켜야 try 구문 내에서 수정을 하든지 말든지 할 수 있다. 그냥 변수 선언만 하고 try 구문 내에서 수정한 것을 try 구문 밖에서 사용하려고 하면 오류난다. 내 생각엔 try {} 구문 내에 모든 내용이 실행된다는 보장이 없으니까 컴파일 차원에서 에러 발생시키는 것 같다
			
				public class Main {
					public static void main(String[] args) {
						int i=0 ; // 걍 int i; 만 하면 뒤에 System.out.println(i) 부분서 에러난다
						try {
							i=10;
						}catch(Exception e) {}
						System.out.println(i);
					}
				
				}
	
		: 또다른 예시
			
				public static void main(String[] args) {
					int[] tmp = new int[15];								for(int i = 0 ; i <10;i++) {	
						System.out.println(tmp); // if 문 블럭 내부서 변경한 내용이 블럭 밖에서도 적용 >> 같은 메서드 내부에 있는거니까
						if((i+1) %2 == 0) {
							tmp = new int[15];
						}
					}
				}		
					

34. 왜그런진 모르겠는데 문자 배열의 경우 문자배열명을 단독으로 출력하면 문장으로 변환되서 출력되고 , 문자 배열 + 다른 문자열하고 출력하면 배열의 주소가 출력된다
	: 다른 타입의 배열의 경우 배열명을 단독으로 출력해도 배열의 주소가 나온다


35. 시간 메서드
	currentTimeMillis()
		: ms 단위
		: 운영체제가 관리하는 시간값을가져온다(시스템 시간을 가져옴)(외부데이터 가져온다)
			:1970 01 01 부터 일정 ms 만큼 시간이 흐른 걸 사용한다
		: 사용법 ) System.currentTimeMillis()
		: 활용 )
			: 시간 재기 시작할때 한번 호출해서 시간 저장하고 시간 재기 종료할때 두번째로 호출해서 시간 저장하고 두 시간의 차를 구한다
		
		: 주의 )
			: ms --> s 단위로 바꿀댄 /1000 을 하는거지 , *1000 을 하는게 아니다
				: s --> ms 단위로 바꿀때나 *1000 하는거다 
	


36. 파일 읽기
	: 되도록 걍 문자 스트림으로 읽기
		: 만약에 문장으로 읽어들어야하는 상황이면 보조스트림 BufferedReader 쓰고 readLine() 을 이용하기

37. import
	: 클래스 뿐 아니라 인터페이스도 import 해와서 써야된다
	: System. 어쩌구로 쓰는 메서드는 별다른거 import 안해도 걍 쓸 수 있다


38. 년 월 일 시간 예쁘게 출력하기
	>> ???

39. 메서드나 생성자 내부에서 this.멤버명 으로 안쓰고 this 자체로도 쓸 수 있다. 이때 this 는 객체 자체를 의미한다
	ex)
public boolean equals(Object o) {
        if (this == o) return true; // 만일 현 객체 this와 매개변수 객체가 같을 경우 true
    }


40. 줄바꿈 ) \n == \r == \r\n == 한번 줄바꿈  >> \n , \r 로 나눠 출력하면 두번 줄바꿈이 된다.

41) 자주 보이는 용어
	1. cannot be instantiated. >> 객체를 만들 수 없다
	2. resource >> 외부의 데이터(File , Network , db)
	3. charSet >> 추후 마저 기록
		: Character Set 와 동의어다. 즉 한국어로 해석함 문자 집합이다
		: 문자 집합 ) 인코딩,디코딩 과정을 위해 필요한 약속
			: 문자의 인코딩 , 디코딩
				: 인코딩 ) 문자열 객체로  배열객체 얻음
				: 디코딩 ) 배열객체로 문자열 객체 얻음 
				: 인코딩 , 디코딩 방식 종류 ) 
					(1) ANSI
						: 아스키코드 기반
						: 문자 == 1 바이트

					(2) UTF-8
						: 유니코드를 나타낼 수 있음
						: 문자의 종류 따라서 차지하는 바이트 크기가 다름( 한국어 == 3바이트 , 아스키코드 == 1바이트 ...)
						: 한글을 조합으로 구현(과 == ㄱ + ㅘ)
					(3) EUC-KR
						: ANSI 의 한국어 확장판.  근데 UTF-8 에 비해 정확도 떨어짐	
							: 한글을 조합형이 아닌 완성형이기 때문(과 == 과)

						: 문자의 종류 따라서 차지하는 바이트 크기가 다름(한국어 == 2바이트 아스키코드 == 1바이트)

					: 디코딩 ) 기계어를 문자(유니 아스키 코드)로 변환
			: 왜필요>> 어떤 방식 택하느냐 따라 깨질 수도 있고, 사이즈가 달라진다


	4. case - sensitive
		: 대소문자 구분
	5. offset
		: 시작위치
	6. canonical
		: canonical 자체적인 의미는 원형, 기본이란 뜻으로, 자바에서는 절대 경로 뭐 이런것처럼 상대적인 것과 상반되는 개념으로 쓰인다
		: absolute 보다도 더 절대적인 느낌.
			: File file = new File("/home/./././Test.txt"); 일때
				file.getAbsolutePath() 의 경우 file 객체를 생성할때 arg로 한 절대경로 그 자체인 /home/./././Test.txt 를 반환하지만
				file.getCanonicalPath() 의 경우 찐(?) 절대경로인 /home/Test.txt 를 반환한다
42) 유명한 interface
	1. Runnable
		: run ( ) 메서드를 가지고 있고, 이 인터페이스의 구현 객체를 Thread 클래스 생성자의 arg  로 사용하여 Thread 객체를 만들 수 있다
	2. Serializable
		: 입출력스트림 통해서 보낼 수 있는 객체


43 ) 자바 api 사전에서 선언부에 있는 "thorws 어떤예외 " >> try catch(어떤예외) 내부서 호출해야된다.(예외가 발생하든 안발생하든 뭊조건 그 예외를 반환하게 되있어서 그렇다) 하지만 선언부에 없고 밑에 설명부분에 throws 어떤예외2 로 되있는 건 따로 try catch(어떤예외2) 처리 안하고 써도 된다.




44) 유독 String 관련한 작업에서 char 이 다른 타입들보다 좀 튀는편인데(String--> char 할때 parse 어쩌구 아니고 charAt( )가 별도로 있음 ,  char[ ] --> String 으로 가능 ) 이는 String 과 char 이 워낙 다른 타입들보다 긴밀한 관계를 가져서 그렇다고 암기하자


45) 대소문자 구분없이 순수 내용상의 동일성 판단하는 법
	(1) 걍 이미 만들어져있는 equalsIgnoreCase( )를 사용한다
	(2) 직접 두단계 작업을 한다
		1. toUppercase () 혹은 toLowercase( ) 로 일단 다 규격을 맞춘다
		2. equals( ) 로 비교한다


46) 뭔가 헷갈리는 문자열 <---> wrapper 클래스<---> 기본타입
	public static ?? valueOf(!!!)
		: 각 wrapper 클래스들, String 클래스 가 가지고 있음
		: 반환값은 valueOf( ) 를 메서드로 가지는 클래스의 타입
		: 매개변수 타입은 String 클래스의 경우 Object 로 모든타입 다 가능하고, wrapper 클래스들은 각각 String 타입과 자기자신의 일반 버전 타입 총 2개가 가능하다 
			ex) Integer 클래스에는 valueOf(String str) , valueOf(int i) 총 2개 있고 반환값은 Integer.  Character 클래스엔 valueOf(String str), valueOf(Character c) 총 2 개 있고 반롼값은 Character
	일반타입 --> 문자열
		1. XXX.parseXXXX(문자열)
			: Character 에는 예외적으로 없다
		2.valueOf
	다른 타입의 값으로 문자열 만들기는 쉽다 >> String.vauleOf(값)
		: valueOf()의 매변 타입이 Object 이기 떄문에 심지어 char 까지 쉽게 변환 가능하고 , static 타입이기 때문에 걍 String 클래스를 대상으로 사용하면 된다
	문자열로 다른 타입의 값을 만들기는 살짝 까다롭다 >> XXXX.parseXXX(문자열객체) 혹은 문자열객체.charAt(인덱스)
		: parseXXX는 static 이긴 헤도 String 클래스의 static 이 아니라 각 Wrapper 클래스의 static 메서드이기 때문에 일일이 대상클래스 맞춰줘야되고,  문자는 예외적으로 이를 지원하지 않고 String 클래스의 인스턴스 멤버인 charAt() 을 사용해야된다


47) 베열 타입 한번에 출력하기
	String str = Arrays.toString(배열명); 이용 
		: 물론 import java.util.Arrays ; 해줘야됨


48 ) 객체가 new 연산자로 생성자를 호출하는 방식으로만 생성되진 않는다. static 메서드를 사용하여 객체를 생성시키는 클래스도 있다 
	: ex) InetAddress

49 ) mutex 뮤텍스 vs semaphore 세마포어
	: 둘다 동기화 도구임. 
		: 여러개의 프로세스 혹은 스레드가 공유된 자원(객체)에 동시에 접근할떄 한번에 하나의 프로세스만 접근할 수 있도록 제한하는데 쓰이는 도구이다
	: 뮤텍스
		:한번에 한 스레드 , 프로세스만 소유할  수 있는 키 
			: 키 ) 특정한 객체로 , 이 객체를 소유한 스레드.프로세스만이 공유자원에 접근 가능

		: 동기화 대상이 하나인 상황
		: 자원 소유가 가능
	: 세마포어 
		: 한번에 여러개의 스레드, 프로세스가 접근할 수 있는 '값' 
			: 값이지, 객체가 아니다
		: 동기화 대상이 여러개인 상황


50 ) String 의 메서드 중 getBytes() 의 리턴값을 byte배열 타입의 레퍼런스변수가 바로 받을 수 있는 것은( byte[] 레퍼런스변수 = new byte(n) 없이 바로 레퍼런스 변수에 할당할 수 있는 것은 ) 아마도 getBytes( )자체가 배열 객체를 반환하기 때문인것 같다 . (new byte(n) 해야 인덱스 단위로 값 집어넣을 수 있는것도 결국 배열 객체 생성해야 그 배열을 사용할 수 있게 되는 이치니까) 생각해보면 byte[] 레퍼변수명 = {1,2,3,.. } ; 이런것도 객체 생성되서 가능한 일이니까.

51 ) 인코딩 방식 결정
	: 자바 소스 코드 내의 getBytes() , new String(byte[] bytes) 의 경우
		>> default 는 소스코드가 속한 파일의 문자셋을 따름 
		>> charset 이나 charsetaName으로 따로 지정하면 그 지정한 문자셋으로 인코딩 가능
	: 자바 프로그램 외부에서 만든 파일에서 불러오는 경운 어케되는진 모르겠음.


52 ) 문자열 <----> 기본 타입
	: 기본 타입을 문자열로
		(1) String 클래스에 정의된 static valueOf(Object obj ) 활용
			: 주의 >> String 클래스 뿐 아니라 wrapper 클래스들에도 static valueOf(해당타입의 매개변수), static valueOf(String str) 이 있다 
				: static valueOf() 메서드는 arg 를 자신이 선언되어있는 클래스의 값으로 변환해주는거라고 생각함된다.  
					: tip>> 죄다 static 이므로 앞에 대상으로 쓰인 클래스명을 확인하면 어떤 값을 반환하는지 알기 쉽다
						: ex) 
							String.valueOf(10) >> String 클래스를 대상으로 쓰였으므로 String 객체를 반환한다
							Integer.valueOf(10) >> Integer 클래스를 대상으로 쓰였으므로 Integer 객체를 반환한다
					: 주의 ) 
						1. String 클래스에 선언된 valueOf() 만 arg 타입이 Obj 여서 모든 타입의 값을 arg 로 받을 수 있다
						2. Character 클래스엔 valueOf(String str) 이 오버로딩 되있지 않고 오직 valueOf(Char c) 만 있다

		(2) 각 wrapper 클래스에서 오버라이딩한 toString( )을 활용
			: Character 에도 정의되어있으니 맘껏 사용 가능
			: static 으로도 , 인스턴스로도 있으니 편한대로 씀 됨
				ex ) Integer.toString(10); // static toString() 이용
				     integerVal.toString(); // toString() 이용

	: 문자열을 기본타입으로
		(1) 문자를 제외하곤 Wrapper 클래스에 정의된 static parse기본타입명(기본타입매개변수) 를 활용
			: parse >> 기본적으로는 문장을 문법적으로 분석하다 란 뜻인데 프로그래밍에서는 주로 ( 기존과 다른 형식으로) 디코딩 한다는 의미로 쓰인다.
			: Character 클래스의 경우에는 아예 문자열을 문자로 바꾸는 개념의 메서드가 없음
			: ex ) String str = Integer.parseInt("200");

		(2) 문자만 String 클래스의 charAt(0) 을 활용


53) 생성자가 private 이거나 아예 없다고 하더라도 객체를 만들 수 없는건 아니다. 해당 클래스의 메서드를 이용해서 객체를 생성할 수 있게 만들어논 클래스도 있다
	ex ) java.lang.Class 


54) JVM , JRE , JDK 이란?
	: JVM < JRE < JDK
		: JDK
			: java development kit .
			: 자바 컴파일러 즉 JAVAC 를 포함한다
			: .java 소스파일로 .class 바이트 코드 파일을 생성한다
 				: JRE 를 포함
					: 개발자는 JDK 를 설치하여 프로그래밍을 한다( 모두 아우르니까)
					: 사실 개발자가 아니라 실행만이 목적이라면 JDE 만 설치해도 된다. 굳이 소스 코드를 바이트 코드로 변환하는 과정이 필요없는거니까

		: JRE
			: 자바 런타임 환경 . Java Runtime Envioornment
			: 자바 클래스 로더와 라이브러리를 포함하는 환경으로 , JVM 이 원활하게 작동할 수 있도록한다.
				: 바이트코드를 필요한 라이브러리와 결합하여 JVM 에 넘긴다
			: JVM 을 포함

		: JVM 
			: 자바 가상 머신 java virtual machine
				: 자바 프로그램을 (운영체제에 관계없이) 실행시켜줌 && 프로그램의 메모리를 관리해줌
			: Garbage Collection 을 포함한다
				: 메모리를 관리하는 프로세스로 , 프로그램에서 사용하지 않은 메모리를 찾아 제거하여 효율적인 메모리 관리를 하게 해준다

55) 정적이다 == static 이다 == 컴파일 타임에 결정된다. 동적이다 == 런타임에 결정된다.


56) 클래스 내부의 블럭들
	1. static 블록
		: 찐으로 static{ .... } 꼴
		: 클래스가 로드된 이후 클래스의 초기화 시점에서 실행시킬 코드가 담긴 블럭이다
		: 한 클래스 내부에 여러개가 올 수 있다
		: 주로 static 필드를 초기화시키는데 사용한다
		: static 메서드랑 다른거임

	2. 인스턴스 블록
		: 찐으로 { ... } 꼴
		: 클래스의 객체 생성시 실행시킬 코드가 담긴 블럭이다
		: 생성자가 실행되기도 이전에 실행된다
		: 주로 인스턴스 필드를 초기화시키는데 사용한다
		: 생성자랑 다른거임 


57) 지연초기화 lazy initialization
	: 필드의 초기화 시점을 그 값이 처음 필요할때까지 늦추는 기법
		: 값이 전혀 쓰이지 않으면 초기화도 안일어난다
	: 정적 필드 뿐 아니라 인스턴스 필드 모두에 사용할 수 있다
	: 떄에 따라서 효율적일 수도 있고 비효율적일 수도 있다 << 양날의 검
		: 장점) 클래스, 인스턴스의 생성 시 초기화 비용은 준다
			: 그러니까 초기화 하는데 메모리가 덜 들어간다
		: 단점) 지연초기화되는 필드에 접근하는 비용이 크다
			: 그러니까 지연 초기화 되는 메모리를 쓸때 일반적인 필드보다 메모리가 더 필요하다
		: 지연초기화를 하는게 효율적인 경우 ) 초기화하는데 많은 비용이 들고 && 사용 빈도가 낮은 필드
			: 이걸 그냥 한눈에 판단하긴 어렵구 지연 초기화 적용 전후의 성능을 측정해봄으로써 판단한다.

	: 멀티스레드 환경에서의 지연 초기화
		: 둘 이상의 스레드가 공유하는 필드의 경우 지연초기화는 안쓰는게 좋다
	: 


